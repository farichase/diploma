
/*
   Модуль функций прогонки.
   
   Основные функции модуля:
   
   SolveEquations --- функция запуска решения уравнений в словах в конфигурации прогонки.
   ([PRTC]) => ([PRTC])
   
   PostProcessPRTC --- обработка конфигурации после прогонки (и решения уравнений).
   (((e.equations)(e.restrictions)(e.assignments))^*)(e.MultisetOfCalls)
   ([NonClashPRTC])^*
   =>
   (((e.equations)(e.restrictions)(e.assignments))^*)(s.Log)((call [functioncall])|\Lambda
   
   GenerateNextLevel --- построение очередного узла в дереве вычислений программы по результатам прогонки.
   Формат:
   [ParentNodeName](t.NumberOfGeneratedChildren) 
   ((e.ParentRestrictions)(e.ParentEquations)(e.ParentLets)(e.ParentFullConfiguration)[ParentStack])
   ([PatternFunctionName] (Try e.ArgumentOfPatternFunction)(SubstTo e.CurrentPatternOfRightSide)(e.OtherPatterns))
   (((e.equations)(e.restrictions)(e.assignments))^*)
   (s.Log)
   ((call [functioncall])|\Lambda)
   =>
   (Node Undriven|Ready [NewNodeName] ((Push|Always|[restriction]^+) (Equations) ()([FullConfig])[Stack]))^*
   
   AssignTimeStamps --- назначение временных меток вызовам в выражении.
   [Expr] => [Expr]
   
   ParametrizeAllEq --- замена рефал-данных в уравнениях на абстрактные переменные.
   
   Drive --- функция прогонки.
   
   ClashLeft --- функция сопоставления с образцом слева (она же запускает функцию сопоставления справа, не видимую вне модуля).
   ((e.equations)(e.restrictions)(e.assignments)(e.Clashes)(s.Log))=>((e.equations)(e.restrictions)(e.assignments)((Delayed e.Clashes))(s.Log))^*
   
   Структуры данных в прогонке.
   
   [ClassicEquality] ::= (AreEqual (s.IfIsChanged)([EqualityExpr])([EqualityExpr]))
   [SimpleCallEqualities] ::= (AreEqual (s.IfIsChanged)((call [DataExpr]))([EqualityExpr])) [SimpleCallEqualities]| 
   
   [Stack]::= ([StackLevel]^+)
   [StackLevel]::= ((assign (var l t.varname)([StackExpression])))
   [StackExpression] :: = | ('*' [StackExpression]) [StackExpression] | s.X [StackExpression] 
			| (par s.partype e.parname) [StackExpression] | (var l t.stackvarname) [StackExpression]
   
   [NonClashPRTC]::= Zero |
	([ClassicEquality]^* (Desired [SimpleCallEqualities])
	((assign (par t.type t.name) ([DataExpr])))^*)
	((assign (var t.type t.name) ([DataExpr])))^*)
	((Delayed))
	(s.Log)
   
   [PRTC]::= Zero |
	([ClassicEquality]^* (Desired [SimpleCallEqualities])
	((assign (par t.type t.name) ([DataExpr])))^*)
	((assign (var t.type t.name) ([DataExpr])))^*)
	([Clash]^* (Delayed [Clash]^*))
	(s.Log)
   [Clash]::= (([DataExpr]) to ([PatternExpr]))
   [DataExpr]::= |('*' [DataExpr])[DataExpr]|[Symbol][DataExpr]|(par t.type t.name)[DataExpr]|(call t.fname (args (arg [DataExpr])))
   [PatternExpr]::= |('*' [PatternExpr])[PatternExpr]|[Symbol][PatternExpr]|(var t.type t.name)[PatternExpr]
   [EqualityExpr]::= |('*' [EqualityExpr])[EqualityExpr]|[Symbol][EqualityExpr]|
	(par t.type t.name)[EqualityExpr]|(weval t.type t.name)[EqualityExpr]|(var t.type t.name)[EqualityExpr]|
	(call t.fname (args (arg [DataExpr]))) --- это не ошибка, внутри вызова может быть только [DataExpr]
*/

$EXTERN prefal;
/* из модуля AnalyzeFunDef.ref */
$EXTERN AnalyzePattern, AnalyzeOpenVarsSet;
/* из модуля basics.ref */
$EXTERN MSCPError;
/* из модуля basics.ref */
$EXTERN MaxElementPowerMS, RandomMaxElementMS, ExtractElNameMS, MaxElementMS, ReplaceMSEl,IfASubMultiSet,Substitute, IterateSubstitute, GetParList;
/* из модуля basics.ref */
$EXTERN IfIncluded, CompareMultiSets, SubtractSetFromSet, FindMSIntersection, SubtractMS,SubtractEl,
    InsertInMultiSet,MergeSets, SetMinus;
/* из модуля basics.ref */
$EXTERN LogAnd, LogAndMerge, LogOrMerge, LogOr, FindTerm, TermContradiction, LessGenericPattern, IsTerm,IfGround, 
        IfConstant, IfBounded, SetIntersect;
/* из модуля basics.ref */
$EXTERN FreshIndex, CurrentIndex,RenewIndices,MyInc, MyOne, MyZero, MyMax, MyAdd, MySub, MyIfNotLess, MytoBool, MyMin, MyNewLevel;
/* из модуля WordEquations.ref */
$EXTERN IfProcessible, IterateProcessQWEs, ParametrizeExpression, PlaceTwoSidesInEquality,NormalizeInequalityBlock,ScreenNegatives;
/* из модуля WordEqsCases.ref */
$EXTERN ProcessLinearInequality;
/* из модуля stack.ref */
$EXTERN YieldDecomposition, Lazy_Stack_Substitution,DecompAfterIndefinite;

/* из модуля accessMSCP.ref */
$EXTERN IsContradictory,NullifyPRTC,GetPRTCDelayedCl,PutPRTCDelayedCl,DeleteLastPRTCClash,PutPRTCClash,GetPRTCClash,
    PutPRTCAsg,GetPRTCAsgs,ReplacePRTCAsgs,
    PutPRTCRestr,GetPRTCRestrs,GetPRTCCallRestrs,PutPRTCCallRestr,
    PRTCOutputForm, GenerateFreshPRTC,
    ReplacePRTCCallRestrs,ReplacePRTCClashes,GetPRTCAllClashes,
    ReplacePRTCEqs,ReplacePRTCDelayedCl,
    GetPRTCAllEqs,PutPRTCNewEq, ReplacePRTCNewEqs, GetPRTCNewEqs, GetPRTCGenEqs, ReplacePRTCAllEqs, AddPRTCGenericEqs,
    SubstInNewEqs, SubstInAllEqs, FormEquationBlock,
    GetPRTCNegativeInfo,AddPRTCNegativeInfo,ReplacePRTCNegativeInfo, GetNewEqsFromEqs;
$EXTERN PutNodeNewEqsToOld, GetNodeConfFromStack, PutNodeEqs, GenerateNewNode,
    PutNodeConfig, PutNodeStack, PutNodeStatus, PutNodeRestrictions,
    GetStackTop, GetNodeStack, GetNodeConfig, GetNodeEqs, PutNodeNegEqs, GetNodeRestrictions,
    GetEBAsgs, GetEBNewEqs, GetEBProgramDataAsgs, IntegrateEBEqsInPRTC, CheckVarDependencies,
    FormatPRTCToPrint;

/* из модуля WordEquations.ref */
$EXTERN IterateSWEforEB, IterateWEforPRTCs;

/*
    Проверка, может ли выражение оказаться пустым.
   Возвращает вызов, от которого зависит ответ на вопрос, является ли оно пустым.
   Вход:
   ((call [args])|\Lambda)[stack_expression]
   Выход:
   ((call [args])|\Lambda)(s.Log), s.Log='N'|'F'
*/
IfMayBeEmpty {
    (e.Indefinite) = (e.Indefinite)('N');
    ()(call e.call) e.z = <IfMayBeEmpty ((call e.call)) e.z>;
    (e.Indefinite)(call e.call) e.z = <IfMayBeEmpty (e.Indefinite)e.z>;
    (e.Indefinite)(var l e.var) e.z = <IfMayBeEmpty (e.Indefinite)e.z>;
    (e.Indefinite)(t.sort e e.parname) e.z = <IfMayBeEmpty (e.Indefinite)e.z>;
    (e.Indefinite)e.Z = (e.Indefinite)('F');
}

/*
    Главная функция для решения уравнений в словах.
   На входе:
   ([PRTC]) (может быть, что PRTC = Zero)
   На выходе:
*   ([PRTC]) 
*/
$ENTRY SolveEquations {
    t.PRTC, <IsContradictory t.PRTC> : 'T' = ;
/*
    	t.PRTC,
        <GetPRTCNewEqs t.PRTC> : e.equations
	 = <PostProcessEquations 
             <SubstituteWevals <IterateSWEforEB <IterateWEforPRTCs 
                <FormEquationBlock 
                     <ParametrizeAllEq e.equations> t.PRTC
                >
        >>>>; 
*/

    t.PRTC
    , <GetPRTCNewEqs t.PRTC> : e.equations
    , <GetPRTCCallRestrs t.PRTC> : e.CR
    , <GetPRTCRestrs t.PRTC> : e.ActiveRestrs
    , <FormEquationBlock <ParametrizeAllEq e.ActiveRestrs e.equations (Desired e.CR)> t.PRTC> : (Inactive e.InactiveEqs)t.EB
        =  
        <Br 'SolveEqMode=0'> 
        <SubstituteWevals 
            (e.InactiveEqs) <IterateWEforPRTCs t.EB> t.PRTC
        >;
}

/*
    Заключительная обработка конфигураций прогонки после решения уравнений.
   [PRTC]^* => [PRTC]^*
*/
PostProcessEquations {
    = ;
    t.PRTC e.Confs
    , <IsContradictory t.PRTC>: 'T'
        = <PostProcessEquations e.Confs>;
/*
    	((e.equations (Desired e.calls))(e.restrictions)(e.assignments)((Delayed e.Clashes))(s.Log))e.Confs = 
		((<DeleteMultipleEqs () e.equations> (Desired <DeleteMultipleEqs () e.calls>))(e.restrictions)(e.assignments)((Delayed e.Clashes))(s.Log))
		<PostProcessEquations e.Confs>; 
*/
    t.PRTC e.Confs  
        = t.PRTC <PostProcessEquations e.Confs>;
}


/*
   Удаление повторных уравнений из блока уравнений.
   ([ClassicEquality]^*)[ClassicEquality]^* 
   =>[ClassicEquality]^* 
*/
DeleteMultipleEqs {
    e.PosEq (Desired e.CallEq) = <DeleteMultipleEqs e.PosEq>(Desired <DeleteMultipleEqs e.CallEq>);
    e.PrEq (AreEqual (s.Log)t.LHS t.LHS) e.PrEq2 = <DeleteMultipleEqs e.PrEq e.PrEq2>;
    e.PrEq (AreEqual (s.Log)t.LHS t.RHS) e.PrEq2 (AreEqual (s.Log2)t.RHS t.LHS) e.PrEq3 = <DeleteMultipleEqs e.PrEq e.PrEq2 e.PrEq3>;
    e.PrEq (AreEqual (s.Log)t.LHS t.RHS) e.PrEq2 (AreEqual (s.Log2)t.LHS t.RHS) e.PrEq3 = <DeleteMultipleEqs e.PrEq e.PrEq2 e.PrEq3>;
    e.PrEq = e.PrEq;
}

/*
    Проверка, входит ли данное уравнение в заданный блок уравнений.
   ([CheckedClassicEquality]^*)([NonCheckedClassicEquality]^*)[ClassicEquality] =>
   [CheckedClassicEquality]^*
*/
CheckNewEq4Multiplicity {
    e.NPEq (AreEqual (s.Log1)(t.LHS)(e.RHS)) e.NPEq2 (AreEqual (s.Log2)(t.LHS) (e.RHS)) 
        = () e.NPEq (AreEqual (s.Log1)(t.LHS)(e.RHS)) e.NPEq2;
    e.NPEq (AreEqual (s.Log1)(t.LHS)(e.RHS)) e.NPEq2 (AreEqual (s.Log2)(t.LHS) (e.RHS2)) 
        = (AreEqual ('F')(e.RHS)(e.RHS2)) e.NPEq (AreEqual (s.Log1)(t.LHS)(e.RHS)) e.NPEq2;
    e.NPEq (AreEqual (s.Log)(t.LHS)(e.RHS)) 
        = () e.NPEq (AreEqual (s.Log)(t.LHS)(e.RHS));
}

/**************************************************************************************
   
                     ОБЩИЕ ФУНКЦИИ ПРОГОНКИ
    
**************************************************************************************/

/*
   Выбор функции для выталкивания (если это необходимо) по результатам попытки сопоставления. 
   Вход:
   (((e.equations)(e.restrictions)(e.assignments))^*)(e.MultisetOfCalls)
   ([NonClashPRTC])^*
   Выход:
   (((e.equations)(e.restrictions)(e.assignments))^*)(s.Log)((call [functioncall])|\Lambda)
   s.Log = 'F' => невозможность сопоставления во всех ветвях прогонки;
   s.Log = 'N' => имеется вызов функции, без уточнения которого нельзя установить, успешно ли сопоставление;
   s.Log = 'T' => сопоставление возможно (независимо от значений вызовов функций).
*/
$ENTRY PostProcessPRTC {
/* 1. Все возможные конфигурации прогонки содержат противоречия => сопоставление невозможно. */
    ()() = ()('F')();
/*
   2. Ни в одной конфигурации прогонки нет неопределенностей, и есть хотя бы одна конфигурация, не содержащая противоречий
	=> безотносительное сопоставление возможно. 
*/
    (e.ProcessedConfs)() = (e.ProcessedConfs)('T')();
/* 3. Мультимножество вызовов, порождающих противоречия, непусто => нужно найти в нем элемент с наибольшим весом. */
    (((e.Eqs)(e.Restrs)(e.Asgs)) e.ProcessedConfs)(e.MSCalls)
            = <Putout 1 'Multiset of calls to be resolved:'>
            <Putout 1 e.MSCalls>
            ()('N')((<FindTightNarrowing (e.Restrs)e.ProcessedConfs>)
            <ExtractElNameMS <MaxElementMS (e.MSCalls)>>);

/* 4. Блок Desired текущей конфигурации пуст => она помещается в конфигурации, не содержащие неопределенностей. */
    (e.ProcessedConfs)(e.MSCalls) t.PRTC e.Confs
    , <GetPRTCCallRestrs t.PRTC> : 
    , <PRTCOutputForm t.PRTC> : t.NodePRTC
        = <PostProcessPRTC (e.ProcessedConfs t.NodePRTC)(e.MSCalls)e.Confs>; 

/* 5. Противоречивая конфигурация просто удаляется. */
    (e.ProcessedConfs)(e.MSCalls) t.PRTC e.Confs
    , <IsContradictory t.PRTC> : 'T' 
        = <PostProcessPRTC (e.ProcessedConfs)(e.MSCalls) e.Confs>; 

/* 6. В случае непустого блока Desired текущей конфигурации все вызовы, на которые в нем имеются сужения, добавляются в мультимножество неопределенностей. */
    (e.ProcessedConfs)(e.MSCalls) t.PRTC e.Confs
    , <GetPRTCCallRestrs t.PRTC> : e.calls
        = <PostProcessPRTC (e.ProcessedConfs <PRTCOutputForm t.PRTC>)<AddCallsToMS (e.calls)(e.MSCalls)> e.Confs>; 
}

FindTightNarrowing {
/* Проба! */ (e.x) e.y = ;
    (e.Narrowings) = e.Narrowings;
    ()e.Other = ;
    (e.Narrowings)((e.Eqs)(e.Restrs)(e.Asgs)) e.Other
        = <FindTightNarrowing <SetIntersect (e.Narrowings)(e.Restrs)>e.Other>;
}

/*
    Добавление вызова из блока Desired во взвешенный список вызовов, неопределенных в данном сопоставлении.
   Вызов, уточняемый явно, имеет больший вес, чем вызов, вовлечённый только в уравнения 
   (уточняемый только неявно).
   Вход:
   ((call [functioncall])^*)((t.Weight (call [functioncall]))^*)
   Выход:
   ((t.Weight (call [functioncall]))^*)
*/
AddCallsToMS {
    ()(e.MSCalls) = (e.MSCalls);
    ((AreEqual (s.Log)(t.call)((weval e e.Z))) e.calls)(e.MSCalls)
        = <AddCallsToMS (e.calls)(<InsertInMultiSet (e.MSCalls)(<MyOne> t.call)>)>;
    ((AreEqual (s.Log)(t.call)(e.Val)) e.calls)(e.MSCalls)
        = <AddCallsToMS (e.calls)(<InsertInMultiSet (e.MSCalls)(<MyInc <MyOne>> t.call)>)>;
}

/*
    Прогонка одного правила определения функции закончена.
   Обрабатываем ее результат.
   Вход:
   [ParentNodeName](t.NumberOfGeneratedChildren) 
   ((e.ParentRestrictions)(e.ParentEquations)(e.ParentLets)(e.ParentFullConfiguration)[ParentStack])
   ([PatternFunctionName] (Try e.ArgumentOfPatternFunction)(SubstTo e.CurrentPatternOfRightSide)(e.OtherPatterns))
   (((e.equations)(e.restrictions)(e.assignments))^*)
   (s.Log)
   ((call [functioncall])|\Lambda)
   Выход:
   (Node Undriven|Ready [NewNodeName] ((Push|Always|[restriction]^+) (Equations) (e.ParentLets)([FullConfig])[Stack]))^*
*/
$ENTRY GenerateNextLevel {
/* 1. Ни одной дочки порождено не было, предложений в выражении больше не осталось. */
    (s.CurrNum)()(e.Negative) 
    t.NodeName (0) t.Node (t.fname (Try e.CurrConfig)(SubsTo e.CurrentRightSide)(/* No sentences */))()('F')() t.Status
        = () t.Status;

/* 2. На последнем сопоставлении получено противоречие, предложений в выражении больше не осталось. */
    (s.CurrNum)(e.Set)(e.Negative)t.NodeName t.NodeChildren t.Node (e.PatternConfig(/* No sentences */))()('F')() t.Status
        = (e.Set) t.Status;

/* 3. Все ветви узла порождены, предложений в выражении больше не осталось. */
    (s.CurrNum)(e.Set)(e.Negative)t.NodeName t.NodeChildren t.Node (e.PatternConfig(/* No sentences */))()('T')() t.Status
        = (e.Set s.CurrNum) t.Status;

/* 4. Все ветви узла порождены, но остались еще предложения в определении функции. */
    (s.CurrNum)(e.Set)(s.Mode e.Negative)t.NodeName t.NodeChildren t.Node
    (t.fname (Try e.CurrConfig)(SubsTo e.CurrentRightSide)(((s.PatternType)(e.LHSDef)e.RHSDef)e.OtherDefinitions))()(s.Log)()t.Status
    , <Dg 'PatternType'> : e.Z
    , <Br 'PatternType='s.PatternType> : 
    , <GetNodeEqs <PutNodeNewEqsToOld t.Node>> : e.ParentEquations
    , <GenerateFreshPRTC (e.LHSDef)(e.CurrConfig)> : t.NewPRTC
    , <AddPRTCNegativeInfo 
        <ReplacePRTCAllEqs t.NewPRTC e.ParentEquations> 
            e.Negative
    > : t.NewGeneratedPRTC                
        = <GenerateNextLevel 
            (<Add s.CurrNum 1>)
            (<InsertIfMod s.Mode s.CurrNum e.Set>)
            (Unmod e.Negative) t.NodeName t.NodeChildren 
            t.Node
            (t.fname (Try e.CurrConfig)(SubsTo e.RHSDef)(e.OtherDefinitions))
            <PostProcessPRTC 
                ()()<Putout 1 'New Clash: No '<FreshIndex 'prtc_ind'>> <Putout 1 <FormatPRTCToPrint t.NewGeneratedPRTC>><Putout 1>
                    <Drive s.PatternType ( ) <ClashLeft s.PatternType 0 t.NewGeneratedPRTC>>
            >
            t.Status
        >;
/*
    5. Выяснилось, что необходимо выталкивать вызов функции --- порождаем единственную
   дочку узла дерева, содержащую конфигурацию, где этот вызов активен.
   Данная конфигурация затем заменит собой конфигурацию родительского узла. 
   ВООБЩЕ ГОВОРЯ, этот вызов может находиться через несколько уровней декомпозиции.
   Пример: 
   <F (<G e.x <H e.x> e.x>)(<G e.x e.x e.x>)> 
   F {t.1 t.1 = 'T';}
   Нужно толкать не G, а H!
   Поэтому это предложение должно быть переписано.
   Декомпозиция должна происходить по подстановке.
   Может быть 1 - тогда она совпадает с ленивой.
   Может быть inf - тогда она совпадает с аппликативной.
   Может быть (e.call) - значит, разбираем до указанного вызова.
*/
    (s.CurrNum)(e.Set)(s.Mode e.Negative) t.NodeName (t.NodeChild) t.Node
        (t.fname (Try e.CurrConfig)(SubsTo e.RHSDef)(e.OtherDefinitions))()('N')((e.Narrowings)t.call)t.Status
    , <GenerateNewName t.NodeName (t.NodeChild)> : t.NewNodeName
    , <GetNodeEqs t.Node> : e.Eqs
    , <GetNodeConfig t.Node> : e.Config
    , <GetNodeStack t.Node> : e.Stack
    , e.Stack : ((assign (var l e.vardata)(e.CurrProcessedCall))e.ThisLevel) e.OtherLevels
    , e.Narrowings :
        {/* EMPTY */
            = <PutNodeRestrictions 
                <PutNodeStatus 
                    <PutNodeStack
                        <PutNodeConfig 
                            <PutNodeEqs 
                                <GenerateNewNode t.NewNodeName> 
                                e.Eqs
                            >
                            e.Config
                        >
                        <DecompAfterIndefinite t.call (e.Stack)(var l e.vardata t.fname) e.CurrConfig>
                    >
                Ready
                > 
                Push
            > (Unchanged) Driven;
        e.Restrs
        , <ExtractNegativeInfo 
            ((((New)(Grammar)(Negative)(Numeric)(Generic))(<AddTrivRestrs (e.CurrConfig)e.Restrs>)()))e.Negative> : e.NewNegative
            = <PutNodeRestrictions 
                <PutNodeStatus 
                    <PutNodeStack
                        <PutNodeConfig 
                            <PutNodeNegEqs 
                                <PutNodeEqs 
                                    <GenerateNewNode t.NewNodeName> 
                                    <SubstInAllEqs (e.Restrs)e.Eqs>
                                > 
                                e.Negative
                            >
                        <IterateSubstitute (e.Restrs)e.Config>
                        >
                        <DecompAfterIndefinite 
                            <IterateSubstitute (e.Restrs)t.call> 
                            (<IterateSubstitute (e.Restrs)e.Stack>)(var l e.vardata t.fname) <IterateSubstitute (e.Restrs)e.CurrConfig>
                        >
                    >
                    Ready
                > 
                e.Restrs
            > 
            <GenerateNextLevel 
                (s.CurrNum)(<InsertAllNum <Add s.CurrNum 1> (e.OtherDefinitions) e.Set s.CurrNum>)
                (Mod <ScreenIfNeeded (e.NewNegative) e.Negative>)t.NodeName (<Add t.NodeChild 1>) t.Node
                        (t.fname (Try e.CurrConfig)(SubsTo e.RHSDef)(e.OtherDefinitions))()('T')() t.Status
            >;
        };        
/*
    6. Порождается ветвь, не содержащая уравнений или рестрикций - 
   остальные предложения определения функции можно не проверять. 
*/

    (s.CurrNum)(e.Set)(s.Mode e.Negative) t.NodeName (t.NodeChild) t.Node /* ((e.OldRestrictions)(e.ConfigEquations)(e.Lets)(e.FullConfig) */
	(t.fname (Try e.CurrConfig)(SubsTo e.CurrentRightSide)(e.OtherDefinitions))
        ((((New)(Grammar e.1)(Negative e.NewNeg)(Numeric e.2)(Generic e.4))()(e.assignments))e.OtherConfigs)('T')() t.Status
    , <GetNodeEqs t.Node> : e.Eqs
    , <GetNodeStack t.Node> : e.Stack
    , <GenerateNewNode <GenerateNewName t.NodeName (t.NodeChild)>> : t.NodeBlank
    , <PutNodeNegEqs 
        <PutNodeEqs 
            <PutNodeRestrictions t.NodeBlank Always> 
            e.Eqs
        >
        e.NewNeg
    > : t.NewNode
        =
        <GetNodeConfFromStack
            <PutNodeStack 
                <PutNodeNewEqsToOld t.NewNode>
                <StackTransform 
                    (<IterateSubstitute (e.assignments)<AssignTimeStamps e.CurrentRightSide>>)
                    (e.Stack)
                >
            >
        >
        (<InsertIfMod Mod s.CurrNum e.Set>)t.Status;
                        
/* 7. Порождается очередная ветвь. */
    (s.CurrNum)(e.Set)(e.Negative) t.NodeName (t.NumChilds) t.Node
	(t.fname (Try e.CurrConfig)(SubsTo e.CurrentRightSide)(e.OtherDefinitions))
        (((e.equations)(e.restrictions)(e.assignments))e.OtherConfigs)('T')()t.Status
    , <GenerateNewNode <GenerateNewName t.NodeName (t.NumChilds)>> : t.BlankNode
    , <GetNodeStack t.Node> : e.Stack
    , <PutNodeEqs <PutNodeRestrictions t.BlankNode e.restrictions> e.equations> : t.NewNode
    , <GetNodeConfFromStack 
        <PutNodeStack	
            t.NewNode 
            <StackTransform 
                (<IterateSubstitute (e.assignments)<AssignTimeStamps e.CurrentRightSide>>)
                (<IterateSubstitute (e.restrictions) e.Stack>)
            >
        >> : e.NewChildConf
    , (e.Negative) :
        {(s.St e.NegExpr)
        , <ExtractNegativeInfo 
            (((e.equations)
            (<AddTrivRestrs (e.CurrConfig)e.restrictions>)
            (e.assignments))e.OtherConfigs) e.NegExpr
        > : e.NewNegative
            = e.NewChildConf
            <GenerateNextLevel (s.CurrNum)(e.Set) 
                (Mod <ScreenIfNeeded (e.NewNegative) e.NegExpr>)
                t.NodeName
                (<MyAdd t.NumChilds 1>) 
                t.Node                                
                (t.fname (Try e.CurrConfig)(SubsTo e.CurrentRightSide)(e.OtherDefinitions))
                (e.OtherConfigs)('T')()t.Status
            >;
        (Mod e.NegExpr)
            = e.NewChildConf
            <GenerateNextLevel (s.CurrNum)(e.Set)
                (e.Negative)
                t.NodeName
                (<MyAdd t.NumChilds 1>) 
                t.Node                                
                (t.fname (Try e.CurrConfig)(SubsTo e.CurrentRightSide)(e.OtherDefinitions))
                (e.OtherConfigs)('T')()t.Status
            >;
        };
}

InsertAllNum {
    s.Num (/* EMPTY */) e.Set = e.Set;
    s.Num (t.Rule e.Other) e.Set
        = <InsertAllNum <Add s.Num 1> (e.Other)e.Set s.Num>;
}

InsertIfMod {
    s.Mod s.CurrNum e.1 s.CurrNum e.2 = e.1 s.CurrNum e.2;
    Unmod s.CurrNum e.Set = e.Set;
    Mod s.CurrNum e.Set = e.Set s.CurrNum;
}

ReplaceFalse {
    e.1 False e.2 = (OR ('T') (() to ()));
    e.Z = e.Z;
}

ScreenIfNeeded {
    (t.x e.1) t.xx e.2 = <ReplaceFalse <ScreenNegatives Init t.x e.1 t.xx e.2>>;
    (e.1) e.2 = <ReplaceFalse e.1 e.2>;
}

/*
    Применение подстановок к стеку.
   ((assign (var l e.name)(e.Val))^*)(e.restrictions)e.Stack 
*/
SubstituteInStack {
    (e.ThisLevelProcessed)(e.restrictions)() = (e.ThisLevelProcessed);
    (e.ThisLevelProcessed)(e.restrictions)()e.OtherLevels = (e.ThisLevelProcessed)<SubstituteInStack ()(e.restrictions)e.OtherLevels>;
    (e.ThisLevelProcessed)(e.restrictions)((assign (var l e.stackvarname)(e.Val))e.ThisLevel)e.OtherLevels
        = <SubstituteInStack 
                (e.ThisLevelProcessed (assign (var l e.stackvarname)(<IterateSubstitute (e.restrictions)e.Val>)))
                (e.restrictions)(e.ThisLevel)e.OtherLevels
        >;
}

/*
    Даны два семейства уравнений. Соединить их, исключая эквивалентные.
   ([Equation]^*)[Equation]^* => [Equation]^*
*/
MergeEquations {
    (e.Eqs1 (AreEqual (s.Log1)(e.1)(e.2)) e.Eqs2) 
    e.Eqs11 (AreEqual (s.Log2)(e.1)(e.2)) e.Eqs12
        = <MergeEquations (e.Eqs1 e.Eqs2) e.Eqs11 (AreEqual (s.Log1)(e.1)(e.2)) e.Eqs12>;
    (e.Eqs1 (AreEqual (s.Log1)(e.1)(e.2)) e.Eqs2) 
    e.Eqs11 (AreEqual (s.Log2)(e.2)(e.1)) e.Eqs12
        = <MergeEquations (e.Eqs1 e.Eqs2) e.Eqs11 (AreEqual (s.Log1)(e.1)(e.2)) e.Eqs12>;
    (e.Eqs) 
    e.Eqs11 (AreEqual (s.Log) (e.1)(e.1)) e.Eqs12 
        = <MergeEquations (e.Eqs) e.Eqs11 e.Eqs12>;
    (e.Eqs1) e.Eqs2 = e.Eqs1 e.Eqs2;
}

/*
    Дано выражение, возможно, содержащее вызовы функций.
   Пронумеровать эти вызовы по времени их порождения, если они ещё не пронумерованы.
   [Expr] => [TimedCallsExp]
*/
$ENTRY AssignTimeStamps {
    /* EMPTY */ = /* EMPTY */;
    ('*' e.0) e.1 = ('*' <AssignTimeStamps e.0>) <AssignTimeStamps e.1>;
    (call t.fdata (args (arg e.Arg))) e.Other
    , t.fdata : (t.fname t.timestamp)
        = (call t.fdata (args (arg <AssignTimeStamps e.Arg>))) <AssignTimeStamps e.Other>;
    (call t.fname (args (arg e.Arg))) e.Other 
        = (call (t.fname <FreshIndex 'time_stamp'>) (args (arg <AssignTimeStamps e.Arg>))) <AssignTimeStamps e.Other>;
    t.x e.1 = t.x <AssignTimeStamps e.1>;
}

/*
    Преобразование стека при передаче в верхнюю его переменную нового значения.
   Вход:
   ([expression])[Stack]
   Выход:
   ([FullConfiguration])[Stack]
*/
StackTransform {
/* Верхняя переменная стека - его низ; производим декомпозицию подстановки. */
    (e.NewVal)(((assign (var l t.stackvar) (e.Val2)))) 
        = <YieldDecomposition  ((assign (var l t.stackvar) (e.NewVal)))>;

/* В противном случае подставляем верхний уровень стека в следующий за ним. */
    (e.NewVal)(((assign (var l t.stackvar) (e.Val2)) e.LowerLevel) e.OtherStack) 
        =   <StackTransformAux 
                <Lazy_Stack_Substitution 
			((assign (var l t.stackvar) (e.NewVal)) e.LowerLevel)
			(e.OtherStack)
                >
            >;
}


/*
    Продолжение преобразования стека --- уже без замены на новое значение.
   Результат --- стек, либо не содержащий вызовов, либо содержащий в нижней переменной вызов.
   Вход:
   [Stack]
   Выход:
   [Stack]
*/
StackTransformAux {
/* Получен вызов в стеке - остановка подстановок. */
    ((assign (var l t.stackvar) ((call e.call)))e.LowerLevel)e.OtherLevels
        = ((assign (var l t.stackvar) ((call e.call)))e.LowerLevel)e.OtherLevels;
/* Дошли до низа стека - декомпозиция. */
    ((assign (var l t.stackvar) (e.Val))) 
        = <YieldDecomposition  ((assign (var l t.stackvar) (e.Val)))>;
/* Иначе продолжаем подстановки. */
    ((assign (var l t.stackvar) (e.Val))e.LowerLevel)e.OtherLevels 
        =		
        <StackTransformAux 
            <Lazy_Stack_Substitution 
                ((assign (var l t.stackvar) (e.Val)) e.LowerLevel)
                (e.OtherLevels)
            >
        >;
}

/*
    Вновь порожденной дочерней ветви узла, в котором осуществляется прогонка, присваивается имя.
   Вход:
   ([NodeName])([MyNumber])
   выход:
   ([NodeName])
*/
GenerateNewName {
    (e.NodeName)(e.NodeChildren) = (e.NodeName e.NodeChildren);
}

$ENTRY AddNewNegativesToPRTCs {
    ((e.equations)(e.restrictions)) = ;
    ((e.equations)(e.restrictions))t.PRTC e.Other
    , <GetPRTCNegativeInfo t.PRTC> : e.Negatives
        = <AddPRTCNegativeInfo t.PRTC <ExtractNegativeInfo (((e.equations)(e.restrictions)()))e.Negatives>>
        <AddNewNegativesToPRTCs ((e.equations)(e.restrictions)) e.Other>;
}

$ENTRY ExtractNegativeInfo {
    ( ) e.CurrentNegative = /* EMPTY */;
    (((e.equations)(e.restrictions)(e.assignments))e.OtherConfigs) e.CurrentNegative
    , <GetNewEqsFromEqs e.equations> : 
        {t.Eq e.Other
            = <ExtractNegativeInfo (e.OtherConfigs) e.CurrentNegative>;
        /* EMPTY */
            = <NegativeScreening (<ExtractNegativePatterns (( )( )( ))<IterateSubstitute (e.restrictions)e.restrictions>>) e.CurrentNegative>
                <ExtractNegativeInfo (e.OtherConfigs) e.CurrentNegative>;
        };
}



/*
    Пока что здесь экранируются только те негативные сопоставления,
   которые полностью повторяют уже имеющиеся. В принципе должны экранироваться все,
   которые являются частными случаями уже имеющихся. 
*/
NegativeScreening {
    (e.1 t.Clash e.2) e.3 (OR t.Log t.Clash) e.4 = ;
    (  ) e.OldNegatives = ;
    t.NewNegative e.1 (OR t.Log t.NewNegative) e.2 = ;
    (e.NewNegative) e.OldNegatives = (OR (<GetClashesPatternType ()e.NewNegative>) e.NewNegative);
}

$ENTRY GetClashesPatternType {
    (e.Patterns)((e.Expr) to (e.Pattern)) e.Other
        = <GetClashesPatternType (e.Patterns ('*'e.Pattern)) e.Other>;
    (e.Patterns) /* EMPTY */ = <AnalyzeOpenVarsSet ( )<AnalyzePattern ( )( )e.Patterns>>;
}

ExtractNegativePatterns {
    (e.Assignments)(assign t.par (e.Val)) e.OtherAsgs
    , <ParametrizeExpression var(e.Assignments)()e.Val > : (e.NewAsgs)(e.Pattern)
        = ((t.par) to (e.Pattern))<ExtractNegativePatterns (e.NewAsgs)e.OtherAsgs>;
    (e.Assignments)(AreEqual (s.Log)(e.LHS)(e.RHS)) e.OtherAsgs
    , <FreshIndex 'vart_ind'> : t.name
        = ((('*'e.LHS)('*'e.RHS)) to ((var t t.name)(var t t.name)))
        <ExtractNegativePatterns (e.Assignments)e.OtherAsgs>;
    (e.Assignments) = /* EMPTY */;
}

$ENTRY CheckNarrowingsScreening {
    (e.Restrs)(/* EMPTY */) = /* EMPTY */;
    (e.Restrs)(t.Node2 e.Other)
    , <GetNodeRestrictions t.Node2> : e.RestrsToCompare
    , e.RestrsToCompare :
        { Push
            = t.Node2;
        e.Z
        , <ExtractNegativePatterns (()()())e.RestrsToCompare> : e.PrimitiveClashes
        , <GetClashesPatternType ()e.PrimitiveClashes> : s.PType
        , <SubstituteInClashes 1 (e.Restrs) e.PrimitiveClashes> : e.NewClashes
        , <Br 'PatternType='s.PType> :
        , <GenerateFreshPRTC e.NewClashes> : t.NarrPRTC
        , <Putout 1 'Narrowings screening, clash No. '<FreshIndex 'prtc_ind'>>
        <Drive s.PType ( ) <ClashLeft s.PType 0 t.NarrPRTC>>
            : {/* EMPTY */
            , <Dg s.PType> : e.X
                = <CheckNarrowingsScreening (e.Restrs)(e.Other)>;
            e.PRTCs
            , <TrivialPRTC e.PRTCs> : 'T'
            , <Dg s.PType> : e.X
                = t.Node2;
            e.PRTCsWithRestrictions
            , <Dg s.PType> : e.X
                = <CheckNarrowingsScreening (e.Restrs)(e.Other)>;
            };
        };
}

/*
******************************************************************************************
   ФУНКЦИИ ПЕРЕВОДА УРАВНЕНИЙ КОНФИГУРАЦИИ В ЧИСТЫЕ УРАВНЕНИЯ В СЛОВАХ
   И ОБРАТНО
*******************************************************************************************
*/


/*
    Объединяем заготовки для уравнений в словах блоков desired calls и блоков equalities.
   e.Equalities(Desired e.Equalities) 
   => (e.ParameterList)(e.ParametrizedEqs)(Desired e.Equalities) 
*/

$ENTRY ParametrizeAllEq {
    e.AllEqs (Desired e.CallEqs) 
            = <ParametrizeAllEq Started (()()())()e.AllEqs e.CallEqs>;
    Started (e.ParameterList)(e.ParametrizedEqs) 
            = (e.ParameterList)(e.ParametrizedEqs);
    Started (e.ParameterList)(e.ParametrizedEqs) (assign t.par (e.Expr)) e.Rest
    , <ParametrizeExpression weval (e.ParameterList)()e.Expr> : (e.UpdParList)(e.ParamExpr)
        = <ParametrizeAllEq Started (e.UpdParList)(e.ParametrizedEqs) e.Rest>;
    Started (e.ParameterList)(e.ParametrizedEqs) (AreEqual (s.Log)(e.Expr1)(e.Expr2)) e.Rest
    , <ParametrizeExpression weval (e.ParameterList)()e.Expr1> : (e.UpdParList)(e.ParamLHS)
    , <ParametrizeExpression weval (e.UpdParList)()e.Expr2> : (e.NewParList)(e.ParamRHS)
        = <ParametrizeAllEq
            Started
            (e.NewParList)
            (e.ParametrizedEqs (AreEqual ('T')(e.ParamLHS)(e.ParamRHS)))
            e.Rest
        >;
}

/* Подстановка данных вместо переменных типа weval во все конфигурации, порожденные этапом прогонки. */
SubstituteWevals {
    (e.InactiveEqs)t.PRTC = ;
/*
    Пусть блок уравнений порождает новые подстановки на weval-данные.
   Что это даёт?
   Если появилась подстановка на переменную - кладём его в assignments и всё.
   На параметр - добавляем рестрикцию (возможно, с введением новых параметров) .
   Назначение на вызов - кладём в Desired.
   На weval-переменную - значит, конфигурация обработана не полностью. См. ниже.
   
   ВСЕ уравнения в положительном блоке, наследуемые узлом-потомком, могут содержать только параметры, но не переменные, weval-переменные
   и вызовы. Если в положительном блоке New появились иные уравнения:
   1) если они содержат вызовы - значит, вызов должен толкаться.
   2) если они содержат прочие weval-переменные - эти переменные оказываются в with-блоке образца.
   А КАК БЫТЬ, если в двух частях уравнения есть weval и параметры?
   
   ПОДРАЗУМЕВАЕМ, что в самом блоке уравнений все weval-рестрикции уже подставлены.
*/
    (e.InactiveEqs) t.EB e.Other t.PRTC
    , <IsContradictory t.EB> : 'T' 
        = <SubstituteWevals (e.InactiveEqs) e.Other t.PRTC>;
    (e.InactiveEqs) t.EB e.Other t.PRTC
    , <GetEBAsgs t.EB> : e.WevalAsgs
    , <GetEBProgramDataAsgs t.EB> : e.RefAsgs
    , <IterateSubstitute (e.WevalAsgs)e.RefAsgs> : e.NewRefAsgs
    , <IntegrateEBEqsInPRTC (e.InactiveEqs) t.PRTC t.EB> : t.NewPRTC
        = 
        <SubstituteEqResultsInConf (e.NewRefAsgs) t.EB t.NewPRTC>
        <SubstituteWevals (e.InactiveEqs) e.Other t.PRTC>;
}

SubstituteEqResultsInConf {
    (e.Asgs ((assign t.call (e.Val))e.OtherCallAsgs)) t.EB t.PRTC
    , <CheckVarDependencies (e.Val) t.EB> : 
        {
            'T' 
                = <SubstituteEqResultsInConf 
                    (e.Asgs(e.OtherCallAsgs)) 
                    t.EB 
                    <PutPRTCCallRestr t.PRTC (AreEqual ('F')(t.call) (e.Val))>
                >;
            'F' 
                = <SubstituteEqResultsInConf 
                    (e.Asgs (e.OtherCallAsgs)) t.EB t.PRTC
                >;
        };
    (e.Asgs ()) t.EB t.PRTC
    , <GetPRTCCallRestrs t.PRTC> : t.1 e.1
    , <GetEBAsgs t.EB> : e.EBAsgs
    , <Substitute (e.EBAsgs) t.1 e.1> : e.NewCallRestrs
        = <ReplacePRTCCallRestrs t.PRTC e.NewCallRestrs>;
    ((e.ParAsgs)(e.VarAsgs)()) t.EB t.PRTC
    , <GetEBAsgs t.EB> : e.Asgs
    , <AssignParValues ()()<IterateSubstitute (e.Asgs)e.ParAsgs>> : (e.NewRestrictions)(e.WevalAssignments)
    , <Substitute (e.WevalAssignments) e.VarAsgs> : e.NewAssignments
    , <PutPRTCAsg t.PRTC e.NewAssignments> : t.NewPRTC
    , <Substitute (e.NewRestrictions) <GetPRTCAsgs t.NewPRTC>> : e.NewAsgs
        =
        <PutPRTCRestr
        <SubstInAllEqs 
            (e.NewRestrictions)
	    <SubstInAllEqs (e.WevalAssignments)
            <ReplacePRTCAsgs t.NewPRTC e.NewAsgs>
	    >
        >
        e.NewRestrictions
        >;
}

AssignParValues {
    (e.NewRest)(e.WevAsg) = (e.NewRest)(e.WevAsg); 
    (e.NewRest)(e.WevAsg) e.1 (assign (par t.type e.name) ((weval t.type e.weval))) e.2
        = <AssignParValues 
            (e.NewRest)(e.WevAsg (assign (weval t.type e.weval) ((par t.type e.name))))
            <Substitute ((assign (weval t.type e.weval) ((par t.type e.name)))) e.1 e.2>
            >;
    (e.NewRest)(e.WevAsg) (assign t.par (e.Expr)) e.Rest
    , <GenerateNewParameterAssignments (e.WevAsg)()e.Expr> : (e.NewAsg)(e.NewExpr) 
        = <AssignParValues (e.NewRest (assign t.par (e.NewExpr)))(e.NewAsg) e.Rest>;
}


/*
   Избыточные подстановки - те, которые описывают свойства переменных, не задействованных в описании рефал-данных,
   либо в выражениях, связывающих разные переменные между собой.
   Например,
   (assign (weval e x)((call e.call))), причём (weval e x) больше нигде не встречается.
   
   Функция удаляет такие подстановки из конфигурации уравнений в словах.
   Формат
   ({(assign (weval e.var)(e.refaldata))|(assign (weval e.var)(e.MultisetOfWevals)(e.WevalExpression))}^*)
   ((AreEqual (s.Log)((e.Multiset)(e.WevalExpression))(((e.Multiset)(e.WevalExpression)))^*)
   ({(assign (weval e.var)(e.refaldata))|(assign (weval e.var)(e.MultisetOfWevals)(e.WevalExpression))}^*)
   (Desired e.calls)(e.Restrictions)(e.Assignments)((Delayed))(s.Log)
   =>
   ((AreEqual ((s.Log)(e.Multiset)(e.WevalExpression))((s.Log)(e.Multiset)(e.WevalExpression)))^*)
   ({(assign (weval e.var)(e.refaldata))|(assign (weval e.var)(e.MultisetOfWevals)(e.WevalExpression))}^*)
   (Desired e.calls)(e.Restrictions)(e.Assignments)((Delayed))(s.Log)
*/
DeleteExcessiveAssignments {
    (e.ProcessedAssignments)(e.NewEquations)() t.PRTC
        = (e.NewEquations)(e.ProcessedAssignments) t.PRTC;
/*
    Три правила закомментировано 15.12.16 из-за теста StrangePal.ref c аргументом t.1 e.1.
   Здесь бестолково вычисляются бессмысленные подстановки, нужно аккуратнее. 
*/

/*
    (e.ProcessedAssignments)(e.NewEquations)((assign (weval e e.weval) t.refaldata) e.ParameterList)e.Config=
        <DelExcAssgn1 
		(assign (weval e e.weval) t.refaldata)
		<IfVarIsInEq (weval e e.weval) e.NewEquations e.ProcessedAssignments e.ParameterList>
		(e.ProcessedAssignments)(e.NewEquations)(e.ParameterList)e.Config
	>;
   
    (e.ProcessedAssignments)(e.NewEquations)((assign (weval s.type e.weval) ((var s.type e.refaldata))) e.ParameterList)e.Config=
        <DelExcAssgn1 
		(assign (weval s.type e.weval) ((var s.type e.refaldata)))
		<IfVarIsInEq (weval s.type e.weval) e.NewEquations e.ProcessedAssignments e.ParameterList>
		(e.ProcessedAssignments)(e.NewEquations)(e.ParameterList)e.Config
	>;
   
    (e.ProcessedAssignments)(e.NewEquations)((assign (weval s.type e.weval) ((par s.type e.refaldata))) e.ParameterList)e.Config=
        <DelExcAssgn1 
		(assign (weval s.type e.weval) ((par s.type e.refaldata)))
		<IfVarIsInEq (weval s.type e.weval) e.NewEquations e.ProcessedAssignments e.ParameterList>
		(e.ProcessedAssignments)(e.NewEquations)(e.ParameterList)e.Config
	>;
*/
    (e.ProcessedAssignments)(e.NewEquations)((assign t.weval e.other) e.ParameterList) t.PRTC 
        = <DeleteExcessiveAssignments 
            (e.ProcessedAssignments(assign t.weval e.other))
            (e.NewEquations)
            ( e.ParameterList)
            t.PRTC
        >;
}

/*
    Вспомогательная для DeleteExcessiveAssignments
   Формат
   (assign (weval e e.var)(e.refaldata))
   s.Log
   ({(assign (weval e.var)(e.refaldata))|(assign (weval e.var)(e.MultisetOfWevals)(e.WevalExpression))}^*)
   ((AreEqual ((s.Log)(e.Multiset)(e.WevalExpression))((s.Log)(e.Multiset)(e.WevalExpression)))^*)
   ({(assign (weval e.var)(e.refaldata))|(assign (weval e.var)(e.MultisetOfWevals)(e.WevalExpression))}^*)
   (Desired e.calls)(e.Restrictions)(e.Assignments)((Delayed))(s.Log)
   =>
   ((AreEqual ((s.Log)(e.Multiset)(e.WevalExpression))((s.Log)(e.Multiset)(e.WevalExpression)))^*)
   ({(assign (weval e.var)(e.refaldata))|(assign (weval e.var)(e.MultisetOfWevals)(e.WevalExpression))}^*)
   (Desired e.calls)(e.Restrictions)(e.Assignments)((Delayed))(s.Log)
*/
DelExcAssgn1 {
    (assign t.weval t.refaldata)'F'(e.ProcessedAssignments)(e.NewEquations)(e.ParameterList)e.Config
        =
        <DeleteExcessiveAssignments (e.ProcessedAssignments)(e.NewEquations)(e.ParameterList)e.Config>;
    (assign t.weval t.refaldata)'T'(e.ProcessedAssignments)(e.NewEquations)(e.ParameterList)e.Config
        =
        <DeleteExcessiveAssignments (e.ProcessedAssignments (assign t.weval t.refaldata))(e.NewEquations)(e.ParameterList)e.Config>;
}

/*
    Подстановка данных рефала вместо представляющих их переменных типа weval.
	(([WordEquation]^*)
	((assign (weval e.vardata)(e.RefalExpr))|(assign (weval e.vardata)(e.Multiset)([WevalExpression]))^*)
        )
	[PRTC]
   => [PRTC]
*/


/*
    Разделение подстановок weval на подстановки в параметры, в иные рефал-данные и в другие переменные weval, 
    которые тут же применяются к подстановкам на рефал-данные.
   Вход:
   ((assign (weval e.vardata)(e.RefalExpr))^*)((assign (weval e.vardata)(e.Multiset)([WevalExpression]))^*)
   [(assign (weval e.vardata)(e.MultiSet)([WevalExpression]))|(assign (weval e.vardata)(e.RefalExpr))]^*
   Выход:
   (Restrictions (assign (par e.pardata)(e.Expr))^*)
   (Other (assign (var e.vardata)(e.Expr))|(assign (call e.calldata)(e.Expr))|(assign (weval e.vardata)(e.Expr))^*)
*/
SortWEAsgn {
    (e.RefalAsgn)(e.WEAsgn) = <FindParameterAssignments ()()e.RefalAsgn>;
    (e.RefalAsgn)(e.WEAsgn) (assign (weval e.data) (t.RefalData)) e.assignments
        = <SortWEAsgn 
            (e.RefalAsgn <SubstituteAllWEAsgnInRA ()(assign t.RefalData ((weval e.data))) e.WEAsgn e.assignments>
            )
            (e.WEAsgn)
            e.assignments
        >;
    (e.RefalAsgn)(e.WEAsgn) (assign (weval e.data)(e.Complexity)(e.Val)) e.assignments 
        =
        <SortWEAsgn 
            (e.RefalAsgn)(e.WEAsgn (assign (weval e.data)(e.Complexity)(e.Val))) e.assignments
        >;
}

/* Применение подстановок weval, связывающей его с другими weval, в подстановки на данные рефала. */
SubstituteAllWEAsgnInRA {
    (e.Processed)(assign t.RefalData ()) e.assignments = (assign t.RefalData (e.Processed));
	
    (e.Processed)(assign t.RefalData ((weval e.name) e.Val)) e.assignments 
        = 
        <SubstituteAllWEAsgnInRA1 
            <IfDecompWE (weval e.name) e.assignments>
            (e.Processed)(assign t.RefalData ((weval e.name) e.Val)) e.assignments
        >;

    (e.Processed)(assign t.RefalData (t.1 e.Val)) e.assignments
        = 
        <SubstituteAllWEAsgnInRA (e.Processed t.1)(assign t.RefalData (e.Val)) e.assignments>;
}

/* Ищем составное значение для переменной типа weval, описывающей конфигурацию рефал-данных. */
IfDecompWE {
    t.Var = ('F')t.Var;
    t.Var (assign t.WE t.RefalData)e.assignments = <IfDecompWE t.Var e.assignments>;
    t.Var (assign t.Var t.Complexity (e.Val)) e.assignments = ('T')(e.Val);
    t.Var (assign t.Var2 t.Complexity2 (e.Val)) e.assignments = <IfDecompWE t.Var e.assignments>;
}

SubstituteAllWEAsgnInRA1 {
    ('F')t.Var (e.Processed)(assign t.RefalData (t.Var e.Val)) e.assignments
        =
        <SubstituteAllWEAsgnInRA (e.Processed t.Var)(assign t.RefalData (e.Val)) e.assignments>;
    ('T')(e.VarVal) (e.Processed)(assign t.RefalData (t.Var e.Val)) e.assignments 
        =
        <SubstituteAllWEAsgnInRA (e.Processed)(assign t.RefalData (e.VarVal e.Val)) e.assignments>;
}		

/*
    Отделение подстановок параметров от прочих подстановок.
   Всем переменным типа weval, попадающим в описание этого параметра, ставятся в соответствие свежие параметры. 
*/

FindParameterAssignments {
    (e.FinalParAsgmts)(e.NParsgm) = (Restrictions e.FinalParAsgmts)(Other e.NParsgm);
    (e.FinalParAsgmts)(e.NParAsgm)(assign (par e.pardata)(e.Val))e.other 
        = <FindParameterAssignments 
            <ChangeWevals2Pars (e.FinalParAsgmts)()()(assign (par e.pardata)(e.Val))> 
            e.NParAsgm e.other
        >;
    (e.FinalParAsgmts)(e.NParAsgm)(assign e.npa) e.other 
        = 
        <FindParameterAssignments (e.FinalParAsgmts)(e.NParAsgm (assign e.npa)) e.other>;
}

/*
    Как только оказывается, что параметр порождает новый параметр,
   все уже обработанные назначения не-параметров записываются в необработанные,
   и появляется новое назначение (assign (weval [type] [name])((par [type ][Fresh_ParInd]))),
   которое подставляется во все назначения, исключая назначения параметров, в
   которых уже не присутствуют переменные weval 
*/

ChangeWevals2Pars {
    (e.FinalAsgmts)(e.Processed)(e.NewPars)(assign (par e.pardata)())e.other
        = (e.FinalAsgmts(assign (par e.pardata)(e.Processed)))() e.NewPars e.other;
    (e.FinalAsgmts)(e.Processed)(e.NewPars)(assign (par e.pardata)((weval e e.vardata) e.Val))e.other 
        =
        <ChangeWevals2Pars 
            (e.FinalAsgmts)
            (e.Processed (par e <FreshIndex 'pare_ind'>))
            (e.NewPars (assign (weval e e.vardata)((par e <CurrentIndex 'pare_ind'>))))
            (assign (par e.pardata)(e.Val))
            <SubstituteParsInWEAsgns 
                (assign (weval e e.vardata)((par e <CurrentIndex 'pare_ind'>)))
            e.other>
        >;
    (e.FinalAsgmts)(e.Processed)(e.NewPars)(assign (par e.pardata)((weval t e.vardata) e.Val))e.other 
        =
        <ChangeWevals2Pars 
            (e.FinalAsgmts)
            (e.Processed (par t <FreshIndex 'part_ind'>))
            (e.NewPars (assign (weval t e.vardata)((par t <CurrentIndex 'part_ind'>))))
            (assign (par e.pardata)(e.Val))
            <SubstituteParsInWEAsgns 
                (assign (weval t e.vardata)((par t <CurrentIndex 'part_ind'>)))
                e.other>
        >;
    (e.FinalAsgmts)(e.Processed)(e.NewPars)(assign (par e.pardata)((weval s e.vardata) e.Val))e.other
        =
        <ChangeWevals2Pars 
            (e.FinalAsgmts)
            (e.Processed (par s <FreshIndex 'pars_ind'>))
            (e.NewPars (assign (weval s e.vardata)((par s <CurrentIndex 'pars_ind'>))))
            (assign (par e.pardata)(e.Val))
            <SubstituteParsInWEAsgns 
                (assign (weval s e.vardata)((par s <CurrentIndex 'pars_ind'>)))
                e.other>
        >;
    (e.FinalAsgmts)(e.Processed)(e.NewPars)(assign (par e.pardata)((var e e.vardata) e.Val))e.other 
        =
        <ChangeWevals2Pars 
            (e.FinalAsgmts)
            (e.Processed (par e <FreshIndex 'pare_ind'>))
            (e.NewPars (assign (var e e.vardata)((par e <CurrentIndex 'pare_ind'>))))
            (assign (par e.pardata)(e.Val))
            <SubstituteParsInWEAsgns 
                (assign (weval e e.vardata)((par e <CurrentIndex 'pare_ind'>)))
                e.other>
        >;
    (e.FinalAsgmts)(e.Processed)(e.NewPars)(assign (par e.pardata)((var t e.vardata) e.Val))e.other 
        =
        <ChangeWevals2Pars 
            (e.FinalAsgmts)
            (e.Processed (par t <FreshIndex 'part_ind'>))
            (e.NewPars (assign (weval t e.vardata)((par t <CurrentIndex 'part_ind'>))))
            (assign (par e.pardata)(e.Val))
            <SubstituteParsInWEAsgns 
                (assign (weval t e.vardata)((par t <CurrentIndex 'part_ind'>)))
                e.other>
        >;
    (e.FinalAsgmts)(e.Processed)(e.NewPars)(assign (par e.pardata)((var s e.vardata) e.Val))e.other
        =
        <ChangeWevals2Pars 
            (e.FinalAsgmts)
            (e.Processed (par s <FreshIndex 'pars_ind'>))
            (e.NewPars (assign (weval s e.vardata)((par s <CurrentIndex 'pars_ind'>))))
            (assign (par e.pardata)(e.Val))
            <SubstituteParsInWEAsgns 
                (assign (weval s e.vardata)((par s <CurrentIndex 'pars_ind'>)))
                e.other>
        >;
    (e.FinalAsgmts)(e.Processed)(e.NewPars)(assign (par e.pardata)(('*' e.Val1) e.Val2))e.other 
        =
        <ContinueChW2P (e.Processed)(e.Val2) 
            <ChangeWevals2Pars
                (e.FinalAsgmts)()(e.NewPars)(assign (par e.pardata)(e.Val1))e.other
            >
        >;
    (e.FinalAsgmts)(e.Processed)(e.NewPars)(assign (par e.pardata)(t.1 e.Val))e.other
        =
        <ChangeWevals2Pars
            (e.FinalAsgmts)(e.Processed t.1)(e.NewPars)(assign (par e.pardata)(e.Val))e.other
        >;
}

/* Закончили порождать параметры в скобках - соединяем результаты и продолжаем вне скобок. */
ContinueChW2P {
    (e.BefBrack)(e.AfterBrack)(e.FinalAsgmts(assign (par e.pardata)(e.InBrack)))() e.other 
        = <ChangeWevals2Pars (e.FinalAsgmts)(e.BefBrack ('*' e.InBrack))()(assign (par e.pardata)(e.AfterBrack))e.other>;
}
/* Подстановка вновь порожденного параметра в назначение, полученное из уравнений в словах. */
SubstituteParsInWEAsgns {
    t.NewPar = ;
    t.NewPar (assign t.RefalData (e.Val)) e.other
        = (assign t.RefalData (<Substitute t.NewPar e.Val>)) <SubstituteParsInWEAsgns t.NewPar e.other>;
}

/*******************************************************************************************
   ФУНКЦИИ ПЕРВИЧНОГО АНАЛИЗА УРАВНЕНИЙ В СЛОВАХ
********************************************************************************************/


/*
    Если имеются уравнения, в которых можно что-то уточнить - уточняем,
   иначе возвращаем всю конфигурацию. 
*/

OptimizeEquations {
/*
    	(e.equations)(e.restrictions)(e.assignments)(e.Clashes)(s.Log) =
		<OptimizeEquations1 (<IfProcessible () e.equations>) (e.equations)(e.restrictions)(e.assignments)(e.Clashes)(s.Log)>; 
*/
	t.PRTC = t.PRTC;
}

/*
    Пока что здесь действие отменено. Подразумевается, что дополнительная проверка на данном этапе не дает никаких новых
   возможностей уточнить уравнения. 
*/

OptimizeEquations1 {
/*
    	((e.PrEq)(e.equations1)'T')(e.equations)(e.restrictions)(e.assignments)(e.Clashes)(s.Log)=
		<OptimizeEquations 
			<ProcessEqualityLeft (e.equations1)(e.restrictions)(e.assignments)(e.Clashes)(s.Log)(e.PrEq)>
		>; 
*/

    ((e.PreQ)(e.equations1)s.NotT)(e.equations)(e.restrictions)(e.assignments)(e.Clashes)(s.Log)
        =
        (e.equations)(e.restrictions)(e.assignments)(e.Clashes)(s.Log);
}

SubstituteAllNewData {
     t.PRTC
     , <GetPRTCRestrs t.PRTC> : e.Restrs
     , <GetPRTCAsgs t.PRTC> : e.Asgs
          = <SubstInAllEqs (e.Restrs) <SubstInNewEqs (e.Asgs) t.PRTC>>;
}

/*******************************************************************************************
   ФУНКЦИИ СОПОСТАВЛЕНИЯ В ПРОГОНКЕ
********************************************************************************************/


$ENTRY Drive {
/* 1. Гроздь прогонки, соответствующая данному правилу, построена. */
    s.PatternType (e.ProcPRTC) = e.ProcPRTC;
/*
    2. Имеется тождественное сопоставление. Все сопоставления, следующие за ним, не рассматриваются!
   Такие случаи могут возникнуть из-за наличия в образцах свободных е-переменных! 
*/

/*   (e.ProcPRTC) t.PRTC e.OtherPRTC, 
    <GetPRTCClash t.PRTC> : ,
    <GetPRTCRestrs t.PRTC> :
         = e.ProcPRTC <SolveEquations t.PRTC>; 
*/

/*
    3. Имеется неразрешенное сопоставление из-за наличия в нём вызовов, существенно
   задействованных при его решении.
   ВНИМАНИЕ! Не смотрим на распределение параметров, сразу считаем, что нужно выталкивать эти вызовы. 
*/
    s.PatternType (e.ProcPRTC) t.PRTC e.OtherPRTC
    , <GetPRTCClash t.PRTC> : /* EMPTY */
    , <SolveEquations t.PRTC> :
    { /* EMPTY */
        = <Putout 1 '    PRTC No.'<CurrentIndex 'prtc_ind'>' FAILED in equation block:'><Putout 1 <FormatPRTCToPrint t.PRTC>><Putout 1>
        <Putout 1 '---------------------------------------------------------------------------'>
        <Putout 1>
        <Drive s.PatternType (e.ProcPRTC) e.OtherPRTC>;
    t.CurrentPRTC
    , <CurrentIndex 'DriveType'> : 'N'
        = <Drive s.PatternType (e.ProcPRTC <ReplacePRTCNegativeInfo t.CurrentPRTC >) e.OtherPRTC>;
    t.CurrentPRTC
    , <PutData t.CurrentPRTC> :  
    , <CurrentIndex 'prtc_ind'> : s.PRTCInd
    , <TestNegativeBlock t.CurrentPRTC> :            
        { /* EMPTY */
            = <Br 'DriveType=C'>
            <Putout 1 '***************** END OF NEGATIVE TESTING PRTC No.'s.PRTCInd'  *************************'>
            <Putout 1>
            <Putout 1 '    PRTC No.'s.PRTCInd' FAILED in negative block:'><Putout 1 <FormatPRTCToPrint t.PRTC>><Putout 1>
            <Putout 1 '---------------------------------------------------------------------------'>
            <Putout 1>
            <Br 'DriveType=C'><Drive s.PatternType (e.ProcPRTC) e.OtherPRTC>;
        t.NewPRTC
            = 
            <Br 'DriveType=C'>
            <Putout 1 '***************** END OF NEGATIVE TESTING No.'s.PRTCInd' *************************'>
            <Putout 1>
            <Putout 1 '    PRTC No.'s.PRTCInd' Class '<CurrentIndex 'DriveType'>' IS COMPLETED:'><Putout 1 <FormatPRTCToPrint t.PRTC>><Putout 1 ' to'><Putout 1 <FormatPRTCToPrint t.NewPRTC>>
            <Putout 1 '---------------------------------------------------------------------------'>
            <Putout 1>
            <Drive s.PatternType (e.ProcPRTC <AddFreeNegatives s.PatternType t.NewPRTC>) 
                <AddNewNegativesToPRTCs ((<GetPRTCAllEqs t.NewPRTC>)(<GetPRTCRestrs t.NewPRTC>))e.OtherPRTC>
            >;
        };
    };
    
/* 4. Сопоставление еще не завершено. */
    s.PatternType (e.ProcPRTC) t.PRTC e.OtherPRTC
        = <Drive s.PatternType (e.ProcPRTC) 
        <AddFreeNegatives s.PatternType <ClashLeft s.PatternType 0 t.PRTC>> 
        e.OtherPRTC>;
}

AddFreeNegatives {
    'D' t.PRTC
    , <GetPRTCCallRestrs t.PRTC > : /* EMPTY */
    , <GetPRTCGenEqs t.PRTC > : e.GenEqs
    , <GetPRTCRestrs t.PRTC> : e.Restrs
    , <GetPRTCAsgs t.PRTC> : e.Asgs
    , <IterateSubstitute(e.Restrs)e.Restrs> : e.RR
        = <AddPRTCNegativeInfo t.PRTC <DeterministicMarkov Whole (e.GenEqs e.RR)(e.RR)
        (<GetFVs e.Asgs>)>>;
    s.Log t.PRTC = t.PRTC;
}

GetFVs {
    e.1 (assign (var e t.name)((par e t.name2)e.x)) e.2
        = (assign (var e t.name)((par e t.name2)e.x))<GetFVs e.1 e.2>;
    e.1 (assign (var e t.name)(e.x(par e t.name2))) e.2
        = (assign (var e t.name)(e.x(par e t.name2)))<GetFVs e.2>;
    e.Z = ;
}

DeterministicMarkov {
    Whole (e.GenEqs)(t.Rest e.Other)(e.FVs)
        = <DeterministicMarkov Single t.Rest <SetMinus (e.GenEqs) (t.Rest)>(e.FVs)><DeterministicMarkov Whole (e.GenEqs)(e.Other)(e.FVs)>;
    Whole (e.GenEqs)( )(e.FVs) = ;
    Single (assign (par e t.name0)(e.1 (par e t.name1)e.Const t.1 (par e t.name2)e.2))(e.OtherStructures)(e.FVs)
    , <IfBounded e.Const t.1 > : 'T'
    , e.FVs : e.F1 (assign t.var (e.x1 (par e t.name1))) e.F2
    , e.FVs : e.F3 (assign t.var2 ((par e t.name2) e.x2)) e.F4
    , <ExtractNegativePatterns (()()())(assign (par e t.name1)((par e t.name1)e.Const t.1(par e t.name2)))>
        : (((par e t.name1)) to ((var e e.var0)e.Pattern t.PattPart(var e e.var)))
    , <GenRepeatedNegatives (e.Const t.1)(e.Pattern t.PattPart)(e.OtherStructures)> : e.RepeatedNegatives
        = 
        (OR ('D')(((par e t.name1)) to ((var e e.var0) e.Pattern t.PattPart (var e e.var)))e.RepeatedNegatives)
        <ReplaceFalse <ScreenNegatives Init <NormalizeInequalityBlock ( )
            <GenerateMarkovEndingConditions 
                (e.RepeatedNegatives)
                (assign (par e t.name1)((par e t.name1)e.Const))
                ((var e e.var0) e.Pattern t.PattPart)>
        >>>
        <DeterministicMarkov Single (assign (par e t.name0)((par e t.name2)e.2))(e.OtherStructures)(e.FVs)>;
    Single e.Other (e.FVs) = ;
}

GenRepeatedNegatives {
    (e.1 (par e.data) e.2)(e.3 (var e.vardata) e.4)(e.Structures)
    , <FindTerm (par e.data) e.Structures> 
    : {
        'T' = (((par e.data)) to ((var e.vardata))) <GenRepeatedNegatives (e.2)(e.4)(e.Structures)>;
        'F' = <GenRepeatedNegatives (e.2)(e.4)(e.Structures)>;
    };
    (e.Z)(e.W)(e.Structures) = /* EMPTY */;
}

PutData {
  t.CurrentPRTC
      = <Putout 1 'Testing negative block in No.'<CurrentIndex 'prtc_ind'>': '>
        <Putout 1 <FormatPRTCToPrint t.CurrentPRTC>><Putout 1>;
}

GenerateMarkovEndingConditions {
    (e.RepeatedNegatives)(assign (par e t.name1)((par e e.par)))(e.Condition) = /* EMPTY */;
    (e.RepeatedNegatives)(assign (par e t.name1)(e.Expr t.Last))(e.Condition)
    , <FilterNegatives (e.RepeatedNegatives)(e.Expr t.Last)> : e.NewNegatives
        = (OR ('T')((e.Expr t.Last) to (e.Condition)) e.NewNegatives)
        <GenerateMarkovEndingConditions (e.NewNegatives)(assign (par e t.name1)(e.Expr))(e.Condition)>;
}

FilterNegatives {
    (((t.par) to (e.Expr)) e.Other)(e.Structure)
    , <FindTerm t.par e.Structure>
    : {
        'T' = ((t.par) to (e.Expr))<FilterNegatives (e.Other)(e.Structure)>;
        'F' = <FilterNegatives (e.Other)(e.Structure)>;
    };
    ( )(e.Structure) = ;
}

DeleteEmpty {
    e.1 (OR (s.Log)) e.2 = e.1 <DeleteEmpty e.2>;
    e.1 (OR (s.Log) e.11 ((e.Expr) to ((var e t.Name)))e.12) e.2
    , <FindTerm (var e t.Name) e.11 e.12> : 'F'
    , e.11 e.12
        : {t.1 e.smth
            = <DeleteEmpty e.1 (OR (s.Log) e.11 e.12) e.2>;
        /* EMPTY */
            = False;
        };
    e.Z = e.Z;
}

$ENTRY TestNegativeBlock {
    t.PRTC
    , <ReplaceFalse <GetPRTCNegativeInfo t.PRTC>> : /* ReplaceFalse здесь маскирует просочившуюся False где-то в других вызовах! */ 
        {(OR e.Clashes) e.OtherClashes
        , <DeleteEmpty (OR e.Clashes) e.OtherClashes>
            : {
                False = /* EMPTY */;
                
                e.NewClashes
                    = <TestNegativeBlock Started ( )t.PRTC e.NewClashes>;
                };
        /* EMPTY */ = t.PRTC;
        };
    Started (e.ProcessedNegative) t.PRTC
        = <ReplacePRTCNegativeInfo t.PRTC e.ProcessedNegative>;
    Started ( ) t.PRTC e.NewClashes
    , <GetPRTCRestrs t.PRTC> : e.Restrs
    , <IterateSubstitute (e.Restrs)e.Restrs> : e.SubRestrs
    , <NormalizeInequalityBlock (e.SubRestrs)e.NewClashes>
    : {
        e.1 False e.2 = /* EMPTY */;
        t.1 t.2 e.Z
        , <ScreenNegatives Init t.1 t.2 e.Z> 
        : {
            False
                = /* EMPTY */;
            e.NotContr
                = <TestNegativeBlock Started (e.NotContr)t.PRTC>;
        };
        e.Other = <TestNegativeBlock Started (e.Other) t.PRTC>;
};
    Started (e.ProcessedNegative) t.PRTC (OR (s.PatternType) e.Clashes) e.OtherClashes
    , <GetPRTCRestrs t.PRTC> : e.Restrs
    , <IterateSubstitute (e.Restrs)e.Restrs> : e.SubRestrs
    , <SubstituteInClashes 0 (e.SubRestrs) e.Clashes (Delayed)> : e.NewClashes (Delayed)
    , <GenerateFreshPRTC e.NewClashes> : t.NegativePRTC
    , <Br 'PatternType='s.PatternType> : 
    , <Putout 1 'Driving negative clash No. '<FreshIndex 'prtc_ind'>> : 
    , <Drive s.PatternType ( ) <ClashLeft s.PatternType 0 t.NegativePRTC>>
        : { 
            /* EMPTY */
            , <Dg 'PatternType'> : e.P
                = <TestNegativeBlock Started (e.ProcessedNegative) t.PRTC e.OtherClashes>;
            e.PRTCs
            , <TrivialPRTC e.PRTCs> : 'T'
            , <Dg 'PatternType'> : e.P
                = /* EMPTY */ ;
            e.PRTCsWithRestrictions
            , <Dg 'PatternType'> : e.P
            , <ExtractBestConditions (e.SubRestrs)e.PRTCsWithRestrictions> 
                : {NotGood
                , <SimplifyNegativeBlocks ( )( )e.NewClashes> : (e.NewConds)
                    = <TestNegativeBlock Started (e.ProcessedNegative e.NewConds) t.PRTC e.OtherClashes>;
                e.NewConds
                    = <TestNegativeBlock Started (e.ProcessedNegative e.NewConds) t.PRTC e.OtherClashes>;
                }
        };
}

ExtractBestConditions {
    e.Z = NotGood;
    (e.SubRestrs) e.1 t.PRTC e.2
    , <GetPRTCNewEqs t.PRTC> : t.1 e.x
        = NotGood;
    (e.UsedData) t.PRTC e.Other
    , <GetPRTCRestrs t.PRTC> : e.Newly
    , <IterateSubstitute (e.Newly)e.Newly> : t.x e.SubNewly
    , <ExtractNegativePatterns ((e.UsedData)()()) t.x e.SubNewly> : e.NewPatterns
     = (OR ('D')e.NewPatterns) <ExtractBestConditions (e.UsedData) e.Other>;
    (e.UsedData) /* EMPTY */ = /* EMPTY */; 
}

SimplifyNegativeBlocks {
    (e.NewConds)(e.Processed) /* EMPTY */ = (<NormalizeToCNF (e.NewConds)e.Processed>) ; 
    (e.NewConds)(e.Processed)((e.Expr) to (e.Pattern)) e.Other
    , <AnalyzePattern Pred 0 ( )( ) e.Pattern> : s.LocalMax e.VarSets
    , <AnalyzeOpenVarsSet ( ) e.VarSets> :
        { 'F'
            = <SimplifyNegativeBlocks (e.NewConds)(e.Processed ((e.Expr) to (e.Pattern))) e.Other>;
        s.Other
        , e.Pattern : e.1 ('*' e.2) e.3
            = <SimplifyNegativeBlocks (e.NewConds)(e.Processed ((e.Expr) to (e.Pattern))) e.Other>; /* Пока не упрощаются неравенства, содержащие структурные скобки. */
        s.Other
        , e.Pattern : e.1 (var t.type t.name) e.2
        , <FindTerm (var t.type t.name) e.NewConds e.Other e.Processed> : 'T'
            = <SimplifyNegativeBlocks (e.NewConds)(e.Processed ((e.Expr) to (e.Pattern))) e.Other>;
        s.Other
        , <ProcessLinearInequality ((e.Expr) to (e.Pattern))> :
            {False
                = <Prout ((e.Expr) to (e.Pattern))> 
                <SimplifyNegativeBlocks (e.NewConds)(e.Processed False) e.Other> /* EMPTY */; 
                /* Эта ветка должна быть недостижима, поскольку негативное условие уже проверено на противоречие ранее. */
            (OR ((t.ExpDF to t.PatDF)e.Data) e.MayBeMoreClashes) /* Если возникла сложная ДНФ, оставляем всё как было. */
                = <SimplifyNegativeBlocks 
                    (e.NewConds)(e.Processed (OR ((t.ExpDF to t.PatDF)e.Data) e.MayBeMoreClashes)) e.Other>;
    /*(e.NewConds <AddCanonicalNegForm <ExtractCommonPartFromDNF ((t.ExpDF to t.PatDF)e.Data)(OR e.MayBeMoreClashes)>>)(e.Processed) e.Other>;*/
            (OR t.SimpleClash e.Something)
                = <SimplifyNegativeBlocks (e.NewConds)(e.Processed t.SimpleClash e.Something) e.Other>;
            t.SimpleClash e.Something
                = <SimplifyNegativeBlocks (e.NewConds <AddCanonicalNegForm t.SimpleClash e.Something>)(e.Processed) e.Other>;
            /* EMPTY */
                = <SimplifyNegativeBlocks (e.NewConds)(e.Processed) e.Other>;
            };
        };
}

NormalizeToCNF {
    (e.NewConds) e.1 False e.2 = <NormalizeToCNF (e.NewConds) /* EMPTY */>;
    ( ) e.Disjuncts = <ExtractConjInDisj (OR e.Disjuncts)>;
    (End e.Other) e.Disjuncts = ;
    ((OR (s.Log)t.Ncond) e.NConds) e.Disjuncts
        = <ExtractConjInDisj (OR t.Ncond e.Disjuncts)><NormalizeToCNF (e.NConds End) e.Disjuncts>;
}

ExtractConjInDisj {
    (OR e.D1 (OR ((t.ExpDF to t.PatDF)e.Other) e.MayBeMoreClashes) e.D2) e.OtherDisj
    , <SimplifyCNFDNF (OR (e.Other) e.MayBeMoreClashes)> : e.NewCNFDNF
    , <SimplifyCNFDNF (OR e.MayBeMoreClashes)> : e.LocalCNFDNF
        = <ExtractConjInDisj (OR e.D1 (t.ExpDF to t.PatDF) e.LocalCNFDNF e.D2)(OR e.D1 e.NewCNFDNF e.D2)>;
    (OR e.Norm) e.Other = <AddCanonicalNegForm (OR e.Norm)> <ExtractConjInDisj e.Other>;
     = ;
}

SimplifyCNFDNF {
    (OR ) = ;
    (OR () ) = ;
    (OR e.Something) = (OR e.Something);
}

ExtractCommonPartFromDNF {
    ( /* EMPTY */)(OR e.Conjuncts) = /* EMPTY */;
    (e.Common)(OR (e.Clashes) e.Other)
        = <ExtractCommonPartFromDNF <SetIntersect (e.Common)(e.Clashes)>(OR e.Other)>;
    (e.Common)(OR ) = e.Common;
}

AddCanonicalNegForm {
    (OR (s.Log) e.Patterns) = (OR (s.Log) e.Patterns);
    (OR e.Patterns) = (OR ('N') e.Patterns);    
    ((e.Expr) to (e.Pattern)) e.Other
    , <AnalyzePattern Pred 0 ()()e.Pattern> : s.LocalMax e.VarSets
    , <AnalyzeOpenVarsSet ()e.VarSets> : s.Log
      = (OR (s.Log) ((e.Expr) to (e.Pattern))) <AddCanonicalNegForm e.Other>;
    /* EMPTY */ = /* EMPTY */; 
}

AddTrivRestrs {
    (e.Expression)e.Restrs
    , <GetParList ()e.Expression> : e.ActivePars
        = <AddTrivRestrs Started (e.ActivePars)e.Restrs> e.Restrs;
    Started(e.ActPars1 t.par e.ActPars2)(assign t.par (e.Expr))e.OtherRestrs
        = <AddTrivRestrs Started(e.ActPars1 e.ActPars2)e.OtherRestrs>;
    Started(e.ActPars)(assign t.par (e.Expr))e.OtherRestrs
        = <AddTrivRestrs Started(e.ActPars)e.OtherRestrs>;
    Started(e.ActivePars)
        = <AddTrivRestrs Continued e.ActivePars>;
    Continued t.par e.Other = (assign t.par (t.par))<AddTrivRestrs Continued e.Other>;
    Continued = ;
 }

$ENTRY TrivialPRTC {
    /* EMPTY */ = 'F';
     t.PRTC e.PRTCs
     , <GetPRTCRestrs t.PRTC> : /* EMPTY */ 
     , <GetPRTCNewEqs t.PRTC> : /* EMPTY */
         = 'T';
    t.PRTC e.PRTCs = <TrivialPRTC e.PRTCs>;
}

FreeNonRepeatedVariables {
    e.Pattern1 ('*' e.InBr) e.Pattern2 = <FreeNonRepeatedVariables e.Pattern1 e.InBr e.Pattern2>;
    e.1 (var t.type (t.Name)) e.2 = 'F';
    e.1 (var t.Type t.Name) e.2 (var t.Type t.Name) e.3 = 'F';
    e.1 (var e t.Name) e.2 (var e t.Name2) e.3 = 'T';
    e.Z = 'F';
}

SubstituteNewRestrictionWithNegativeData {
    (assign (par e e.pardata) (e.Val)) t.PRTC
    , <GenerateNewParameterAssignments (<GetPRTCAsgs t.PRTC>)() e.Val> 
    : {   
        (e.newasgmnts)(e.NewVal) 
        , <CurrentIndex 'DriveType'> 
        : {
            'C'
                = <SubstituteNewRestrictionAux (assign (par e e.pardata) (e.NewVal))
			<ReplacePRTCAsgs t.PRTC e.newasgmnts> 
                    >;
            'N'
                = <SubstituteNewRestrictionAux (assign (par e e.pardata) (e.NewVal))
			<ReplacePRTCAsgs t.PRTC e.newasgmnts> 
                    >;
        };    
    };
}

ExtractNegativeFromFree {
 /*   e.0 (par e t.Name) t.1 e.1 (par e t.Name2)
    , <IfConstant t.1> : 'T'
        = (((par e t.Name)) to ((var e (<Implode 'Exp'<Symb <FreshIndex 'vare_ind'>>>))t.1 e.1 (var e (<Implode 'Exp'<Symb <FreshIndex 'vare_ind'>>>))));*/
    e.Z = ;
}

/*
   Основная функция прогонки.
   s.PatternType s.Mode [PRTC]=>[PRTC]^*
   s.Mode ::= 0|1\2 - здесь 0 указывает на процесс сопоставления слева, 1 - справа, 2 - на сопоставление открытых е-переменных.
   e.equations ::= ((AreEqual ((s.Log1) e.Expr1)((s.Log2) e.Expr2))^* (Desired (AreEqual ((s.Log1) (call e.Call))((s.Log2) e.Expr4Call))))
   e.Expr4Call могут содержать переменные шаблона!
   
   e.restrictions ::= (assign (par e.pardata) (e.Val))^* //e.Val не содержит переменных шаблона
   e.assignments ::= (assign (var e.vardata) (e.Val))^* //e.Val не содержит переменных шаблона
   e.clashes ::= ((e.Expr) to (e.Pattern))^* (Delayed ((e.Expr) to (e.Pattern))^*) // e.Expr не содержит переменных шаблона, e.Pattern - параметров и вызовов
*/
$ENTRY ClashLeft {
/* 1. Удаление неудачного сопоставления. */
    s.PatternType s.Mode t.PRTC
    , <IsContradictory t.PRTC> : 'T'
        = ;

/* 2. Результат успешного сопоставления без отложенных сопоставлений и без уравнений - оставляем всё как есть. */
    s.PatternType s.Mode t.PRTC
    , <GetPRTCClash t.PRTC> : /* EMPTY */
    , <GetPRTCNewEqs t.PRTC> :
        {
        /* EMPTY */
        , <GetPRTCRestrs t.PRTC> : /* EMPTY */ 
                = t.PRTC;
        e.Other = <SubstituteAllNewData t.PRTC>;
        };

/* 4. Удаление пустого сопоставления. */
    s.PatternType s.Mode t.PRTC
    , <GetPRTCClash t.PRTC> : (() to ())
        =
        <ClashLeft s.PatternType <ResetMode s.Mode>
            <DeleteLastPRTCClash t.PRTC>
        >;
/* 5. Единственная е-переменная - сохраняем в назначениях. */
    s.PatternType s.Mode t.PRTC
    , <GetPRTCClash t.PRTC> : ((e.Expr) to ((t.class2 e e.vardata)))
    , <GetPRTCAsgs t.PRTC> : e.assignments 
        =
        <ClashLeft s.PatternType <ResetMode s.Mode>
                <AddNewAssignment 
                    <CheckNewAssignment (assign (t.class2 e e.vardata) (e.Expr))(e.assignments)>
                        <DeleteLastPRTCClash t.PRTC>>
        >;
/* 6. Единственный е-параметр - ЭКСПЕРИМЕНТАЛЬНАЯ ВЕРСИЯ! */
    s.PatternType s.Mode t.PRTC
    , <GetPRTCClash t.PRTC> : (((par e e.pardata)) to (e.Pattern))
    , s.PatternType : 'D'
    , <FreeNonRepeatedVariables e.Pattern> : 'T'
    , <GetPRTCAllClashes t.PRTC> : (((par e e.pardata)) to (e.Pattern))(Delayed )
        =       
        <ClashLeft s.PatternType <ResetMode s.Mode>
                <SubstituteNewRestrictionWithNegativeData 
                        (assign (par e e.pardata) (e.Pattern))
                        <DeleteLastPRTCClash t.PRTC>>
        >;

/* 6. Единственный е-параметр - порождаем новое сужение по образцу. */
    s.PatternType s.Mode t.PRTC
    , <GetPRTCClash t.PRTC> : (((par e e.pardata)) to (e.Pattern))
    , <GetPRTCAsgs t.PRTC> : e.assignments 
        =
        <ClashLeft s.PatternType <ResetMode s.Mode>
                <SubstituteNewRestriction 
                        (assign (par e e.pardata) (e.Pattern))
                        <DeleteLastPRTCClash t.PRTC>>
        >;
                
/* 7. 11.06.ИЗМЕНЕНО! Выражение равно пустому образцу - все термы выражения пусты. */
    s.PatternType s.Mode t.PRTC
    , <GetPRTCClash t.PRTC> : ((e.Expr) to ( )) 
        =
        <ClashLeft s.PatternType <ResetMode s.Mode>
            <PutPRTCNewEq 
                <DeleteLastPRTCClash t.PRTC> 
                (AreEqual ('T')(e.Expr)())
            >
        >;
/* 8. Пустое выражение сопоставляется образцу, начинающемуся с е-переменной - эта е-переменная пуста. */
    s.PatternType s.Mode t.PRTC
    , <GetPRTCClash t.PRTC> : (( ) to (t.Term e.Pattern))
    , <GetPRTCAsgs t.PRTC> : e.assignments
    , t.Term :
        {
        (t.class2 e e.vardata) 
            = <ClashLeft s.PatternType <ResetMode s.Mode> <PutPRTCClash <AddNewAssignment 
                            <CheckNewAssignment (assign (t.class2 e e.vardata) ())(e.assignments)>
                                <DeleteLastPRTCClash t.PRTC>>(() to (e.Pattern))
            >>;
        t.Other = <ClashLeft s.PatternType 0 <NullifyPRTC>>;
        };

/* 9. Если сопоставляются термы, вызываем функцию сопоставления термов. */
    s.PatternType s.Mode t.PRTC
    , 0 2 : e.XX1 s.Mode e.XX2
    , <GetPRTCClash t.PRTC> : ((t.1 e.Expr) to (t.2 e.Pattern))
    , <IsTerm t.1> : 'T'
    , <IsTerm t.2> : 'T' 
        =
        <ClashLeft s.PatternType 0 
            <ClashSymb 
                ((t.1) to (t.2)) 
                <PutPRTCClash <DeleteLastPRTCClash t.PRTC> ((e.Expr) to (e.Pattern))>>>;
    s.PatternType 1 t.PRTC
    , <GetPRTCClash t.PRTC> : ((e.Expr t.1) to (e.Pattern t.2))
    , <IsTerm t.1> : 'T'
    , <IsTerm t.2> : 'T'
        =
        <ClashLeft s.PatternType 1
            <ClashSymb 
                ((t.1) to (t.2)) 
                <PutPRTCClash <DeleteLastPRTCClash t.PRTC> ((e.Expr) to (e.Pattern))>>>;

/* 10. Если сопоставляется е-переменная и идет сопоставление слева, вызываем сопоставление справа. */
    s.PatternType 0 t.PRTC
    , <GetPRTCClash t.PRTC> : ((e.Expr) to ((t.class2 e e.vardata) e.Pattern)) 
        = <ClashLeft s.PatternType 1 t.PRTC>;
        
/* 11. Если сопоставляется е-переменная и идет сопоставление справа, переходим в разбор по е-переменной слева. */
    s.PatternType 1 t.PRTC
    , <GetPRTCClash t.PRTC> : ((e.Expr) to (e.Pattern (t.class2 e e.vardata)))
        = <ClashLeft s.PatternType 2 t.PRTC>;

/* 12. Если пошло сопоставление по е-переменной - вызываем функцию сопоставления е-переменных. */
    s.PatternType 2 t.PRTC
    , <GetPRTCClash t.PRTC> : ((t.1 e.Expr) to ((t.class2 e e.vardata) t.Next e.Pattern))
    , <GetAnchorBlock Left ()()(t.class2 e e.vardata) t.Next e.Pattern> : (e.evars)(e.Anchor)(e.RestPattern)
        = 
        <ClashLeftAll s.PatternType 0
            <Put 1 <ClashEvarNew s.PatternType Left ((t.1) to (e.evars))(e.Anchor)((e.Expr) to (e.RestPattern)) <DeleteLastPRTCClash t.PRTC>>>
        >;
    s.PatternType 2 t.PRTC
    , <GetPRTCClash t.PRTC> : ((t.1 e.Expr) to (t.2 e.Pattern))
        = 
        <ClashLeftGeneric s.PatternType 0 ((t.1) to (t.2))((e.Expr) to (e.Pattern)) <DeleteLastPRTCClash t.PRTC>>;
/*    s.PatternType 3 t.PRTC
    , <GetPRTCClash t.PRTC> : ((e.Expr t.1) to (e.Pattern t.Next (t.class2 e e.vardata)))
    , <GetAnchorBlock Right ()() e.Pattern t.Next (t.class2 e e.vardata)> : (e.evars)(e.Anchor)(e.RestPattern)
        = 
        <ClashEvarNew s.PatternType 3 ((t.1) to (e.evars))(e.Anchor)((e.Expr) to (e.RestPattern)) <DeleteLastPRTCClash t.PRTC>>;*/

/* 12. В противном случае вызываем общую функцию сопоставления (слева или справа). */
    s.PatternType 0 t.PRTC
    , <GetPRTCClash t.PRTC> : ((t.1 e.Expr) to (t.2 e.Pattern))
        =
        <ClashLeftGeneric s.PatternType 0 ((t.1) to (t.2))((e.Expr) to (e.Pattern)) <DeleteLastPRTCClash t.PRTC>>;
    s.PatternType 1 t.PRTC
    , <GetPRTCClash t.PRTC> : ((e.Expr t.1) to (e.Pattern t.2))
        =
        <ClashLeftGeneric s.PatternType 1 ((t.1) to (t.2))((e.Expr) to (e.Pattern)) <DeleteLastPRTCClash t.PRTC>>;
}

GetAnchorBlock {
	Left (e.Evars)(/* EMPTY ANCHOR */) (t.class e e.var) e.Rest = <GetAnchorBlock Left (e.Evars (t.class e e.var))(/* EMPTY */) e.Rest>;
	Right (e.Evars)(/* EMPTY ANCHOR */) e.Rest (t.class e e.var) = <GetAnchorBlock Right ((t.class e e.var) e.Evars)(/* EMPTY */) e.Rest>;
	Left (e.Evars)(e.Anchor) s.Sym e.Rest = <GetAnchorBlock Left (e.Evars)(e.Anchor s.Sym) e.Rest>;
	Right (e.Evars)(e.Anchor) e.Rest s.Sym = <GetAnchorBlock Right (e.Evars)(s.Sym e.Anchor) e.Rest>;
	Left (e.Evars)(e.Anchor) (t.class s e.Name) e.Rest = <GetAnchorBlock Left (e.Evars)(e.Anchor (t.class s e.Name)) e.Rest>;
	Right (e.Evars)(e.Anchor) e.Rest (t.class s e.Name) = <GetAnchorBlock Right (e.Evars)((t.class s e.Name) e.Anchor) e.Rest>;
	Left (e.Evars)(e.Anchor) (t.class t e.Name) e.Rest = <GetAnchorBlock Left (e.Evars)(e.Anchor (t.class t e.Name)) e.Rest>;
	Right (e.Evars)(e.Anchor) e.Rest (t.class t e.Name) = <GetAnchorBlock Right (e.Evars)((t.class t e.Name) e.Anchor) e.Rest>;
	s.Side (e.Evars)(e.Anchor) e.Other = (e.Evars)(e.Anchor)(e.Other);
}

TrivialMatching {
	s.Side (e.Expr)(e.EvarBlock)(e.Anchor)(e.RestPattern)
	, <NonRepeatedE (e.EvarBlock) <Flatten e.RestPattern>> : True
	, <NonRepeatedST (<Flatten e.Anchor>)<Flatten e.RestPattern>> : True
		= <TrivialMatching Started s.Side (e.Expr)(e.EvarBlock)(e.Anchor)(/* EMPTY */)>;
	Started Left (e.Expr)(e.EvarBlock)(e.Anchor)()
	, <ClashLeft 'T' 0 <GenerateFreshPRTC (e.Anchor (var e RestExprValue))(e.Expr)>> : t.NewPRTC
	, <GetPRTCAsgs t.NewPRTC> : e.Asgs
	, <TrivialPRTC t.NewPRTC> : 'T'
	, e.Asgs : e.Asg1 (assign (var e RestExprValue) (e.Val)) e.Asg2
		= (e.Val)(e.Asg1 e.Asg2);
	Started Right (e.Expr)(e.EvarBlock)(e.Anchor)()
	, <ClashLeft 'T' 0 <GenerateFreshPRTC ((var e RestExprValue) e.Anchor)(e.Expr)>> : t.NewPRTC
	, <GetPRTCAsgs t.NewPRTC> : e.Asgs
	, <TrivialPRTC t.NewPRTC> : 'T'
	, e.Asgs : e.Asg1 (assign (var e RestExprValue) (e.Val)) e.Asg2
		= (e.Val)(e.Asg1 e.Asg2);
	s.Side (e.Expr)(e.EvarBlock)(e.Anchor)(e.RestPattern) = False;
	Started s.Side (e.Expr)(e.EvarBlock)(e.Anchor)(e.RestPattern) = False;	
}
	

NonRepeatedE {
	(e.Rest0 (t.class e t.name) e.Rest1 (t.class e t.name) e.Rest2) e.Other = False;
	(e.Rest0 (t.class e t.name) e.Rest1) e.Other (t.class e t.name) e.Rest2 = False;
	(e.Otherwise1) e.Otherwise2 = True;
}

Flatten {
	e.1 (assign t.1 (e.t1)) e.2 = <Flatten e.1 t.1 e.t1 e.2>;
	e.1 ('*' e.2) e.3 = e.1 <Flatten e.2 e.3>;
	e.Z = e.Z;
}

NonRepeatedST {
	(e.Rest0 (t.class s.sort t.name) e.Rest1) e.Rest2 (t.class s.sort t.name) e.Rest3
		= False;
	e.Othewise = True;
}

GenerateNullAsgs {
	(t.var e.Other)(e.Asgs) = <GenerateNullAsgs (e.Other)(e.Asgs (assign t.var (/* EMPTY */)))>;
	(/* EMPTY */)(e.Asgs) = e.Asgs;
}

GenerateMarkovRules {
	t.epar (e.Anchor)(e.Pattern)
	, <NonRepeatedST (e.Anchor)e.Pattern> : True
	, <ParametrizeExpression var (()()())() e.Anchor> : ((var e t.name1) e.VarAnchor (var e t.name2))
	, e.Anchor : e.AnchPrefix t.Last 
		= (OR ('D') ((t.epar e.AnchPrefix) to ((var e t.name1) e.VarAnchor (var e t.name2))));
	t.epar(e.CrossingAnchor)(e.Pattern) = /* No negative condition */;
}

GenerateEndMarkRules {
	(assign t.Epar (t.Epar1))(t.class2 e t.name)e.NullAsgs (e.AllAnchor)(e.Expr)(e.Pattern)t.PRTC = /*STOP HERE */;
	(assign t.Epar (t.Epar1 e.AnchorPrefix t.Last))(t.class2 e t.name)  e.NullAsgs (e.AnchorSuffix)(e.Expr)(e.Pattern)t.PRTC
		= <AddAssignments 
                    <SubstituteNewRestriction 
                        (assign t.Epar (t.Epar1 e.AnchorPrefix)) 
                        <PutPRTCClash t.PRTC ((e.Expr) to (t.Last e.AnchorSuffix e.Pattern))>
                    >
		    e.NullAsgs (assign (t.class2 e t.name) (t.Epar1))
                >
		<GenerateEndMarkRules (assign t.Epar (t.Epar1 e.AnchorPrefix))(t.class2 e t.name)e.NullAsgs (t.Last e.AnchorSuffix)(e.Expr)(e.Pattern)t.PRTC>;
}

NonNullFVs {
	(e.Evarlist)e.Terms ((t.class e t.name) e.Pattern)
	, e.Terms : e.1 (t.class e t.name) e.2 (t.class e t.name) e.3 = False;
	(t.var e.EvarList)()e.1 t.var e.2 = False;
	(t.var e.E2 t.var e.E3)() e.Other = False;
	(e.EvarList t.var e.EvarListEnd)e.1 t.var e.2 = False;
	(e.E1 t.var e.E2 t.var e.E3) e.Other = False;
	(t.First e.EvarList) e.OtherList = (<GenerateNullAsgs (e.EvarList)()>)(t.First);
}

ClashEvarNew {
    s.PatternType s.Side ((t.Term) to (e.EvarBlock))(e.Anchor)((e.Expr) to (e.Pattern)) t.PRTC
    , <NonNullFVs (e.EvarBlock)(/*EMPTY*/)<Flatten <GetPRTCAsgs t.PRTC> e.Pattern>(e.Pattern)>
    : { (e.NullAsgs)((t.class2 e t.name)) /* Cлучай, когда якорь предваряется открытыми переменными только без повторных вхождений. */
	, t.Term 
	: { s.Symbol /* Если первый терм в сопоставляемом выражении - символ, есть возможность безусловного сопоставления. */
          , <TrivialMatching s.Side (t.Term e.Expr)(e.EvarBlock)(e.Anchor)(e.Pattern)>
	    : { (e.RestExpr)(e.AnchorAssignments) /* Безусловное сопоставление возможно. */
	           = <AddAssignments 
		   <PutPRTCClash t.PRTC ((e.RestExpr) to (e.Pattern))>
                    e.NullAsgs e.AnchorAssignments (assign (t.class2 e t.name) (/* EMPTY */))
                  >;
		False
		, <FreshIndex <ClassIdentifier t.class2 e>> : t.venew
                  = <AddAssignments
			<PutPRTCClash t.PRTC ((s.Symbol e.Expr) to (e.Anchor e.Pattern))>
                        e.NullAsgs (assign (t.class2 e t.name) (/* EMPTY */))
                    >
                <AddAssignments 
		  <PutPRTCClash t.PRTC ((e.Expr) to ((t.class2 e t.venew) e.Anchor e.Pattern))>
		  e.NullAsgs (assign (t.class2 e t.name) (s.Symbol (t.class2 e t.venew)))
                >;

};
	  (call e.call) /* Первый терм выражения - вызов. Возникает вопрос о его непустоте. */
		= <ProcessNewSimpleCallCondition 
                ('T')
                (AreEqual ('F')((call e.call))(/* EMPTY */))
                t.PRTC
                >;
	(t.class e t.parname) /* Первый терм выражения - е-параметр. Последовательно порождаются варианты сопоставлений, в которых он вбирает всё меньшую часть якоря. 
				Первое из этих сопоставлений - выделенное, добавляет Марковские неравенства. Остальные неравенств не добавляют. */
	, <FreshIndex <ClassIdentifier t.class e>> : t.penew1
	, <FreshIndex <ClassIdentifier t.class e>> : t.penew2
	, <FreshIndex <ClassIdentifier t.class2 e>> : t.venew
	, <FreshIndex <ClassIdentifier t.class2 e>> : t.venewNeg1
	, <FreshIndex <ClassIdentifier t.class2 e>> : t.venewNeg2
	, <SubstituteNewRestriction (assign (t.class e t.parname) ((t.class e t.penew1) e.Anchor (t.class e t.penew2))) 
                        <PutPRTCClash t.PRTC (((t.class e t.penew2) e.Expr) to (e.Pattern))>
                    > : t.NewPRTC
	, <GetPRTCRestrs t.NewPRTC> : e.1 (assign (t.class e t.parname) ((t.class e t.penew1) e.ParametrAnchor (t.class e t.penew2)))
                = 
		<AddPRTCNegativeInfo
		<GenerateMarkovRules (t.class e t.penew1)((t.class e t.penew1) e.ParametrAnchor (t.class e t.penew2))(e.Pattern)>
		<AddAssignments 
                    t.NewPRTC
		    e.NullAsgs (assign (t.class2 e t.name) ((t.class e t.penew1)))
                >>
		<GenerateEndMarkRules 
			(assign (t.class e t.parname)((t.class e t.penew1) e.ParametrAnchor))
			(t.class2 e t.name)e.NullAsgs( )(e.Expr)(e.Pattern) t.PRTC
		>
                <AddAssignments 
			<PutPRTCClash t.PRTC ((e.Expr) to ((t.class2 e t.venew) e.Anchor e.Pattern))>
			e.NullAsgs (assign (t.class2 e t.name) ((t.class e t.parname)(t.class2 e t.venew)))
                >;
	(t.class s.objtype t.parname)
	, par var weval : e.xx1 t.class e.xx2
	, <TrivialMatching s.Side (t.Term e.Expr)(e.EvarBlock)(e.Anchor)(e.Pattern)>
	: { (e.RestExpr)(e.AnchorAssignments) /* Безусловное сопоставление возможно. */
	           = <AddAssignments 
		   <PutPRTCClash t.PRTC ((e.RestExpr) to (e.Pattern))>
                    e.NullAsgs e.AnchorAssignments (assign (t.class2 e t.name) (/* EMPTY */))
                  >;
		False
		, <FreshIndex <ClassIdentifier t.class2 e>> : t.venew
                  = <AddAssignments
			<PutPRTCClash t.PRTC ((t.Term e.Expr) to (e.Anchor e.Pattern))>
                        e.NullAsgs (assign (t.class2 e t.name) (/* EMPTY */))
                    >
                <AddAssignments 
		  <PutPRTCClash t.PRTC ((e.Expr) to ((t.class2 e t.venew) e.Anchor e.Pattern))>
		  e.NullAsgs (assign (t.class2 e t.name) (t.Term (t.class2 e t.venew)))
                >;
		};
	('*' e.InBr)
            , e.Anchor
		: { ('*' e.AnchBr)e.AnchOut
		   , <FreshIndex <ClassIdentifier t.class2 e>> : t.venew
			=
			<AddAssignments 
				<PutPRTCClash <PutPRTCClash t.PRTC ((e.Expr) to (e.AnchOut e.Pattern))>((e.InBr) to (e.AnchBr))>
				e.NullAsgs (assign (t.class2 e t.name)(/* EMPTY */))
			>
			<AddAssignments 
				<PutPRTCClash t.PRTC ((e.Expr) to ((t.class2 e t.venew) e.Anchor e.Pattern))>
				e.NullAsgs (assign (t.class2 e t.name) (t.Term (t.class2 e t.venew)))
			>;
		(t.class2 t t.brname) e.AnchRest
		, <FreshIndex <ClassIdentifier t.class2 e>> : t.venew
			=	
			<AddAssignments 
				<PutPRTCClash t.PRTC ((e.Expr) to (e.AnchRest e.Pattern))>
				e.NullAsgs (assign (t.class2 e t.name)(/* EMPTY */))(assign (t.class2 t t.brname)(t.Term))
			>
			<AddAssignments 
				<PutPRTCClash t.PRTC ((e.Expr) to ((t.class2 e t.venew) e.Anchor e.Pattern))>
				e.NullAsgs (assign (t.class2 e t.name) (t.Term (t.class2 e t.venew)))
			>;
		e.OtherAnchor
		, <FreshIndex <ClassIdentifier t.class2 e>> : t.venew
                = <AddAssignments 
		  <PutPRTCClash t.PRTC ((e.Expr) to ((t.class2 e t.venew) e.Anchor e.Pattern))>
		  e.NullAsgs (assign (t.class2 e t.name) (t.Term (t.class2 e t.venew)))
                >;
		};
        };
	False
	, t.Term 
	: {(call e.call) 
		= <ProcessNewSimpleCallCondition 
                  ('T')
                  (AreEqual ('F')((call e.call))(/* EMPTY */))
                  t.PRTC
                >; 
	  (t.class e t.parname)
	  , e.EvarBlock : (t.class2 e t.name) e.OtherEvars
	  , <FreshIndex <ClassIdentifier t.class2 e>> : t.venew
	  , <FreshIndex <ClassIdentifier t.class e>> : t.penew1
	  , <FreshIndex <ClassIdentifier t.class e>> : t.penew2
		= <AddAssignments 
			<SubstituteNewRestriction 
				(assign (t.class e t.parname) ((t.class e t.penew1) (t.class e t.penew2))) 
				 <PutPRTCClash t.PRTC (((t.class e t.penew2) e.Expr) to (e.OtherEvars e.Anchor e.Pattern))>
			>
			(assign (t.class2 e t.name)((t.class e t.penew1)))
		>
		<AddAssignments 
			<PutPRTCClash t.PRTC ((e.Expr) to ((t.class2 e t.venew) e.OtherEvars e.Anchor e.Pattern))>
			(assign (t.class2 e t.name) (t.Term (t.class2 e t.venew)))
		>;
	  t.NotCallNotEPar
	  , e.EvarBlock : (t.class2 e t.name) e.OtherEvars
	  , <FreshIndex <ClassIdentifier t.class2 e>> : t.venew
		= <AddAssignments 
			<PutPRTCClash t.PRTC ((t.Term e.Expr) to (e.OtherEvars e.Anchor e.Pattern))>
			(assign (t.class2 e t.name)(/* EMPTY */))
		>
		<AddAssignments 
			<PutPRTCClash t.PRTC ((e.Expr) to ((t.class2 e t.venew) e.OtherEvars e.Anchor e.Pattern))>
			(assign (t.class2 e t.name) (t.Term (t.class2 e t.venew)))
		>;
	  };
	};
}



ClashLeftAll {
    s.PType s.Mode = ;
    s.PType s.Mode t.PRTC e.Other
        = <ClashLeft s.PType s.Mode t.PRTC><ClashLeftAll s.PType s.Mode e.Other>;
}

ResetMode {
    0 = 0;
    1 = 0;
    2 = 0;
    3 = 0;
    5 = 5;
    6 = 5;
     7 = 5;
    8 = 5;
}

$ENTRY ClassIdentifier {
    var e = 'vare_ind';
    var t = 'vart_ind';
    var s = 'vars_ind';
    par e = 'pare_ind';
    par t = 'part_ind';
    par s = 'pars_ind';
    weval e = 'wevale_ind';
    weval t = 'wevalt_ind';
    weval s = 'wevals_ind';
}

/*
    Функция, сопоставляющая термы. Обрабатывает только случаи, когда 
   слева и справа символы, термы, термовые и символьные переменные и параметры.
   Эта часть не порождает новых вариантов конфигурации. 
*/

ClashSymb {
/* 1. символ - символ. */
    ((s.Sym) to (s.Sym)) t.PRTC = t.PRTC;

/* 2. выражение в скобках - выражение в скобках. */
    ((('*'e.Expr1)) to (('*'e.Pat1))) t.PRTC = <PutPRTCClash t.PRTC ((e.Expr1) to (e.Pat1))>;

/* 3. Переменная (s- или t-) с термом, не порождающим сужение. */
    ((t.1) to ((t.class e.vardata)))t.PRTC
    , <LessGenericPattern t.1 (t.class e.vardata)> : 'F'
    , <GetPRTCAsgs t.PRTC> : e.assignments 
        =
        <AddNewAssignment 
            <CheckNewAssignment (assign (t.class e.vardata) (t.1))(e.assignments)>
            t.PRTC 
        >;
/* 4. символ - t-параметр. */
    (((t.class t e.pardata)) to (s.Sym)) t.PRTC
        = 
        <SubstituteNewRestriction 
            (assign (t.class t e.pardata) (s.Sym))
            t.PRTC 
        >;
/* 5. символ - s-параметр. */
    (((t.class s e.pardata)) to (s.Sym)) t.PRTC
        =
        <SubstituteNewRestriction 
            (assign (t.class s e.pardata) (s.Sym))
            t.PRTC 
        >;
/* 6. s-переменная - t-параметр. Сужение t-параметра до (свежего) s-параметра. */
    (((t.class t e.pardata)) to ((t.class2 s e.vardata))) t.PRTC
    , <GetPRTCAsgs t.PRTC> : e.assignments
    , <FreshIndex <ClassIdentifier t.class s>> : t.snew
        =
        <AddNewAssignment 
            <CheckNewAssignment 
                (assign (t.class2 s e.vardata) ((t.class s t.snew)))
                (e.assignments)
            >
            <SubstituteNewRestriction 
                (assign (t.class t e.pardata) ((t.class s t.snew))) 
                t.PRTC
            >
        >;
/* 7. выражение в скобках - t-параметр. */
    (((t.class t e.pardata)) to (('*'e.InBracks))) t.PRTC
    , <GetPRTCAsgs t.PRTC> : e.assignments
        = 
        <SubstituteNewRestriction 
            (assign (t.class t e.pardata) (('*'<Substitute (e.assignments)e.InBracks>))) t.PRTC
        >;
/* 8. В остальных случаях конфигурация противоречива. */
    t.Clash t.PRTC = <NullifyPRTC>;
}

/* Функция сопоставления е-переменных. */
ClashEvar {
/*
    1. терм - е-переменная.
   Внимание!! Случаи не обрабатываются совместно. Они не содержат существенных сужений! Поэтому
   каждый из них может оказаться тождественно выполним, и тогда другие обрабатывать не надо! 
*/
    s.PatternType s.Mode ((t.Obj) to ((t.class2 e e.vardata)))((e.Expr) to (e.Pattern)) t.PRTC
    , <IsTerm t.Obj> : 'T'
    , <GetPRTCAsgs t.PRTC> : e.assignments
    , <FreshIndex <ClassIdentifier t.class2 e>> : t.venew
        =
        <ClashLeft s.PatternType <Sub s.Mode 2>
            <AddNewAssignment 
                <CheckNewAssignment (assign (t.class2 e e.vardata) ())(e.assignments)> 
                <PutPRTCClash t.PRTC ((<ShuffleMode s.Mode t.Obj e.Expr>) to (e.Pattern))>
            >
        >	
        <ClashLeft s.PatternType <Sub s.Mode 2> 
            <AddNewAssignment 
                <CheckNewAssignment (assign (t.class2 e e.vardata) (<ShuffleMode s.Mode t.Obj (t.class2 e (t.venew))>))(e.assignments)> 
                <PutPRTCClash t.PRTC ((e.Expr) to (<ShuffleMode s.Mode (t.class2 e (t.venew)) e.Pattern>))>
            >
        >;
/*
    2. е-параметр - е-переменная. Три случая по приоритетам:
   1) e-переменная пуста;
   2) е-параметр содержит всю е-переменную и еще что-то непустое;
   3) е-переменная содержит весь е-параметр и еще что-то непустое.
   Внимание!! Случаи не обрабатываются совместно. Они не содержат существенных сужений! Поэтому
   каждый из них может оказаться тождественно выполним, и тогда другие обрабатывать не надо!
*/
    s.PatternType s.Mode (((t.class e e.pardata)) to ((t.class2 e e.vardata)))((e.Expr) to (e.Pattern)) t.PRTC
 /*   , <CurrentIndex 'DriveType'> : 'N'*/
    , <GetPRTCAsgs t.PRTC> : e.assignments
    , <FreshIndex <ClassIdentifier t.class2 e>> : t.venew
    , <FreshIndex <ClassIdentifier t.class e>> : t.penew1
    , <FreshIndex <ClassIdentifier t.class e>> : t.penew2
        = <ClashLeft s.PatternType <Sub s.Mode 2>
            <AddNewAssignment 
                <CheckNewAssignment 
                    (assign (t.class2 e e.vardata) 
                    ((t.class e t.penew1)))(e.assignments)
                > 
                <SubstituteNewRestriction 
                    (assign (t.class e e.pardata) 
                    (<ShuffleMode s.Mode (t.class e t.penew1) (t.class e t.penew2)>))
                    <PutPRTCClash t.PRTC ((<ShuffleMode s.Mode (t.class e t.penew2) e.Expr>) to (e.Pattern))>
                >
            >
        >
/*        <ClashLeft s.PatternType <Sub s.Mode 2>
            <AddNewAssignment 
                <CheckNewAssignment (assign (t.class2 e e.vardata) ((t.class e e.pardata)))(e.assignments)>
                <PutPRTCClash t.PRTC ((e.Expr) to (e.Pattern))>
            >
        >*/
        <ClashLeft s.PatternType <Sub s.Mode 2>
            <AddNewAssignment 
                <CheckNewAssignment (assign (t.class2 e e.vardata) 
                    (<ShuffleMode s.Mode (t.class e e.pardata)(t.class2 e (t.venew))>))(e.assignments)> 
                <PutPRTCClash t.PRTC ((e.Expr) to (<ShuffleMode s.Mode (t.class2 e (t.venew)) e.Pattern>))>
            >
        >;
        
    s.PatternType s.Mode (((t.class e e.pardata)) to ((t.class2 e e.vardata)))((e.Expr) to (e.Pattern)) t.PRTC
    , <GetPRTCAsgs t.PRTC> : e.assignments
    , <FreshIndex <ClassIdentifier t.class2 e>> : t.venew
    , <FreshIndex <ClassIdentifier t.class e>> : t.penew1
    , <FreshIndex <ClassIdentifier t.class e>> : t.penew2
    , <FreshIndex <ClassIdentifier t.class t>> : t.ptnew
    , <FreshIndex <ClassIdentifier t.class t>> : t.ptnew2
    , <FreshIndex <ClassIdentifier t.class2 t>> : t.vtnew        
        = <ClashLeft s.PatternType <Sub s.Mode 2>
            <AddNewAssignment 
                <CheckNewAssignment (assign (t.class2 e e.vardata) ())(e.assignments)> 
                <PutPRTCClash t.PRTC ((<ShuffleMode s.Mode (t.class e e.pardata) e.Expr>) to (e.Pattern))>
            >	
        >
        <ClashLeft s.PatternType <Sub s.Mode 2>
            <AddNewAssignment 
                <CheckNewAssignment 
                    (assign (t.class2 e e.vardata) 
                    (<ShuffleMode s.Mode (t.class e t.penew1)(t.class t t.ptnew)>))(e.assignments)
                > 
                <SubstituteNewRestriction 
                    (assign (t.class e e.pardata) 
                    (<ShuffleMode s.Mode (t.class e t.penew1) <ShuffleMode s.Mode (t.class t t.ptnew)<ShuffleMode s.Mode (t.class t t.ptnew2)(t.class e t.penew2)>>>))
                    <PutPRTCClash t.PRTC ((<ShuffleMode s.Mode (t.class t t.ptnew2) <ShuffleMode s.Mode (t.class e t.penew2) e.Expr>>) to (e.Pattern))>
                >
            >
        >
        <ClashLeft s.PatternType <Sub s.Mode 2>
            <AddNewAssignment 
                <CheckNewAssignment (assign (t.class2 e e.vardata) ((t.class e e.pardata)))(e.assignments)>
                <PutPRTCClash t.PRTC ((e.Expr) to (e.Pattern))>
            >
        >
        <ClashLeft s.PatternType <Sub s.Mode 2>
            <AddNewAssignment 
                <CheckNewAssignment (assign (t.class2 e e.vardata) 
                    (<ShuffleMode s.Mode (t.class e e.pardata)<ShuffleMode s.Mode (t.class2 t (t.vtnew))(t.class2 e (t.venew))>>))(e.assignments)> 
                <PutPRTCClash t.PRTC ((e.Expr) to (<ShuffleMode s.Mode (t.class2 t (t.vtnew))<ShuffleMode s.Mode (t.class2 e (t.venew)) e.Pattern>>))>
            >
        >;
/*
    2. вызов - е-переменная. Три случая по приоритетам:
   1) e-переменная пуста;
   2) вызов содержит всю е-переменную и еще что-то непустое;
   3) е-переменная содержит весь вызов.
   Внимание!! Случаи не обрабатываются совместно. Они не содержат существенных сужений! Поэтому
   каждый из них может оказаться тождественно выполним, и тогда другие обрабатывать не надо!
*/
    s.PatternType s.Mode (((call e.call)) to ((var e e.vardata)))((e.Expr) to (e.Pattern)) t.PRTC
    , <GetPRTCAsgs t.PRTC> : e.assignments
        = 
        <ClashLeft s.PatternType <Sub s.Mode 2>
            <AddNewAssignment 
                <CheckNewAssignment (assign (var e e.vardata) ())(e.assignments)> 
                <PutPRTCClash t.PRTC ((<ShuffleMode s.Mode (call e.call) e.Expr>) to (e.Pattern))>
            >	
        >
        <ProcessDelayedCallsInClash s.PatternType
            t.PRTC
            (AreEqual ('T')(<ShuffleMode s.Mode (call e.call)e.Expr>)(<ShuffleMode s.Mode (var e e.vardata) e.Pattern>))
        >;
/* 8. В остальных случаях конфигурация противоречива. */
    s.PatternType s.Mode t.CurrClash t.Clash t.PRTC = <ClashLeft s.PatternType 0 <NullifyPRTC>>;
}

$ENTRY ShuffleMode {
    0 t.1 e.1 = t.1 e.1;
    1 t.1 e.1 = e.1 t.1;
    2 t.1 e.1 = t.1 e.1;
    3 t.1 e.1 = e.1 t.1;
}

FindCommutingEquation {
	t.var s.Sym (e.1 (AreEqual (s.Log)(t.var s.Sym)(s.Sym t.var)) e.2) = True;
	t.var s.Sym (e.1 (AreEqual (s.Log)(s.Sym t.var)(t.var s.Sym)) e.2) = True;
	t.var s.Sym (e.OtherEqs) = False;
}

CommutesWithSymbol {
	s.Sym (t.class e t.name) e.Seq (e.Eqs)
	, <FindCommutingEquation (t.class e t.name) s.Sym (e.Eqs)> : True
	 = <CommutesWithSymbol s.Sym e.Seq (e.Eqs)>;
	s.Sym /* EMPTY */ (e.Eqs) = True;
	s.Sym e.OtherSeq (e.Eqs) = False;
}

ExtractSuccessors {
	s.Mode (e.Prefix (t.class e t.name) s.Sym e.Suffix)(e.Eqs)
	, 0 2 : e.x s.Mode e.xx
	, <FindCommutingEquation (t.class e t.name) s.Sym (e.Eqs)> : True
	, <CommutesWithSymbol s.Sym e.Prefix (e.Eqs)> : True
		= s.Sym e.Prefix (t.class e t.name) e.Suffix;
	1 (e.Prefix s.Sym (t.class e t.name) e.Suffix)(e.Eqs)
	, <FindCommutingEquation (t.class e t.name) s.Sym (e.Eqs)> : True
	, <CommutesWithSymbol s.Sym e.Suffix (e.Eqs)> : True
		=  e.Prefix (t.class e t.name) e.Suffix s.Sym;
	s.Mode (e.OtherExpr)(e.Eqs) = False;
}

/*
    Функция, продолжающая работу ClashLeft на непустых e.Pattern и e.Expr, содержащих хотя бы с одной
   стороны неизвестную произвольной длины (параметр, переменную е-типа) либо вызов функции. 
*/

ClashLeftGeneric {
/*
    1. символ - e-параметр.
   Два случая - сужение е-параметра до символа + е-параметра 
   и сужение е-параметра до пустой строки.
*/
    s.PatternType s.Mode (((t.class e e.pardata)) to (s.Sym))((e.Expr) to (e.Pattern)) t.PRTC
    , <ExtractSuccessors s.Mode ((t.class e e.pardata) e.Expr)(<GetPRTCGenEqs t.PRTC>)> 
    : {
	    s.Sym e.NewExpr
		, 0 2 : e.x s.Mode e.xx
		= <ClashLeft s.PatternType s.Mode <PutPRTCClash t.PRTC ((e.NewExpr) to (e.Pattern))>>;
	    e.NewExpr s.Sym 
		, 1 3 : e.x s.Mode e.xx
		= <ClashLeft s.PatternType s.Mode <PutPRTCClash t.PRTC ((e.NewExpr) to (e.Pattern))>>;
	    False
		, <FreshIndex <ClassIdentifier t.class e>> : t.enew
		= <ClashLeft s.PatternType s.Mode
		    <SubstituteNewRestriction 
			(assign (t.class e e.pardata) (<ShuffleMode s.Mode s.Sym (t.class e t.enew)>))				
			<PutPRTCClash t.PRTC
			    ((<ShuffleMode s.Mode (t.class e t.enew)e.Expr>) to (e.Pattern))>
		    >
		>
		<ClashLeft s.PatternType s.Mode
		    <SubstituteNewRestriction 
			(assign (t.class e e.pardata) ())
			<PutPRTCClash t.PRTC ((e.Expr) to (<ShuffleMode s.Mode s.Sym e.Pattern>))>
		    >	
		>;
		s.OtherSym e.NewExpr = <ClashLeft s.PatternType 0 <NullifyPRTC>>;
	    
	};
/*
    2. s-переменная - e-параметр.
   Два случая - сужение е-параметра до s-параметра + е-параметра (а s-переменной - до s-параметра)
   и сужение е-параметра до пустой строки.
*/
    s.PatternType s.Mode (((t.class e e.pardata)) to ((t.class2 s e.vardata)))((e.Expr) to (e.Pattern)) t.PRTC
    , <GetPRTCAsgs t.PRTC> : e.assignments
    , <FreshIndex <ClassIdentifier t.class e>> : t.enew
    , <FreshIndex <ClassIdentifier t.class s>> : t.snew
        = <ClashLeft s.PatternType s.Mode 
            <AddNewAssignment 
                <CheckNewAssignment (assign (t.class2 s e.vardata) ((t.class s t.snew)))(e.assignments)> 
                <SubstituteNewRestriction 
                    (assign (t.class e e.pardata) (<ShuffleMode s.Mode (t.class s t.snew)(t.class e t.enew)>))
                    <PutPRTCClash t.PRTC ((<ShuffleMode s.Mode (t.class e t.enew)e.Expr>) to (e.Pattern))>
                >
            >
        >
        <ClashLeft s.PatternType s.Mode
            <SubstituteNewRestriction 
                (assign (t.class e e.pardata)()) 
                <PutPRTCClash t.PRTC ((e.Expr) to (<ShuffleMode s.Mode (t.class2 s e.vardata) e.Pattern>))>
            >	
        >;
/*
    3. t-переменная - e-параметр. 
   Два случая - сужение е-параметра до t-параметра + е-параметра (а t-переменной - до t-параметра)
   и сужение е-параметра до пустой строки.
*/
    s.PatternType s.Mode (((t.class e e.pardata)) to ((t.class2 t e.vardata)))((e.Expr) to (e.Pattern)) t.PRTC
    , <GetPRTCAsgs t.PRTC> : e.assignments
    , <FreshIndex <ClassIdentifier t.class e>> : t.enew
    , <FreshIndex <ClassIdentifier t.class t>> : t.tnew
        = <ClashLeft s.PatternType s.Mode
            <AddNewAssignment 
                <CheckNewAssignment (assign (t.class2 t e.vardata) ((t.class t t.tnew)))(e.assignments)> 
                <SubstituteNewRestriction 
                    (assign (t.class e e.pardata) (<ShuffleMode s.Mode (t.class t t.tnew)(t.class e t.enew)>))
                    <PutPRTCClash t.PRTC ((<ShuffleMode s.Mode (t.class e t.enew)e.Expr>) to (e.Pattern))>
                >
            >
        >
        <ClashLeft s.PatternType s.Mode
            <SubstituteNewRestriction 
                (assign (t.class e e.pardata) ())
                <PutPRTCClash t.PRTC ((e.Expr) to (<ShuffleMode s.Mode (t.class2 t e.vardata) e.Pattern>))>
            >	
        >;
/* 4. Выражение в скобках - е-параметр. */
    s.PatternType s.Mode (((t.class e e.pardata)) to (('*'e.Pat1)))((e.Expr) to (e.Pat2))t.PRTC
    , <FreshIndex <ClassIdentifier t.class e>> : t.enew1
    , <FreshIndex <ClassIdentifier t.class e>> : t.enew2
        = <ClashLeft s.PatternType s.Mode
            <SubstituteNewRestriction 
                (assign (t.class e e.pardata) 
                    (<ShuffleMode s.Mode ('*'(t.class e t.enew1))(t.class e t.enew2)>)
                )
                <PutPRTCClash
                    <PutPRTCClash t.PRTC (((t.class e t.enew1)) to (e.Pat1))>
                    ((<ShuffleMode s.Mode (t.class e t.enew2)e.Expr>) to (e.Pat2))>
            >
        >
        <ClashLeft s.PatternType s.Mode
            <SubstituteNewRestriction 
                (assign (t.class e e.pardata) ())
                <PutPRTCClash t.PRTC ((e.Expr) to (<ShuffleMode s.Mode ('*'e.Pat1) e.Pat2>))>			
            >	
        >;
/* 5. Образец сопоставляется с единственным вызовом. */
    s.PatternType s.Mode (((call e.call)) to (t.PatternPart))(() to (e.Pat2)) t.PRTC
    , <GetPRTCAsgs t.PRTC> : e.assignments
    , <Substitute (e.assignments) <ShuffleMode s.Mode t.PatternPart e.Pat2>> : e.NewExpr
        =
        <ClashLeft s.PatternType s.Mode
            <ProcessNewSimpleCallCondition 
                (<IfGround (e.NewExpr)>)
                (AreEqual ('F')((call e.call))(e.NewExpr))
                t.PRTC
            >
        >;
/* 6а-1. Выражение в скобках - вызов, сопоставление слева, справа - е-переменная. Делим на два случая. */
    s.PatternType 0 (((call e.call)) to (('*'e.Pat1)))((e.Expr) to (e.Pat2)) t.PRTC
    , e.Pat2 : e.FreePattern (t.class2 e t.name)
    , <FreshIndex <ClassIdentifier weval e>> : t.wevalnew
        = <ClashLeft s.PatternType 0
            <ProcessNewSimpleCallCondition 
                ('T')
                (AreEqual ('F')((call e.call))()) 
                <PutPRTCClash t.PRTC ((e.Expr) to (('*'e.Pat1) e.Pat2))>>
        >
        <ProcessDelayedCallsInClash s.PatternType
            <ProcessNewSimpleCallCondition
                ('F')
                (AreEqual ('F')((call e.call))(('*'e.Pat1)(weval e t.wevalnew)))
                t.PRTC
            >
            (AreEqual ('T')((weval e t.wevalnew) e.Expr)(e.Pat2))
        >;
/*
/* 6а. Выражение в скобках - вызов. Если шло сопоставление слева, вызываем сопоставление справа. */
    s.PatternType 0 (((call e.call)) to (('*'e.Pat1)))((e.Expr) to (e.Pat2)) t.PRTC
        =
        <ClashLeft s.PatternType 1
            <PutPRTCClash t.PRTC (((call e.call)e.Expr) to (('*'e.Pat1) e.Pat2))>
        >;
/*
    6б. Выражение в скобках - вызов. Если шло сопоставление справа - делим на два случая, в одном вызов вычисляется
   в пустое выражение, в другом - в выражение, оканчивающееся выражением в скобках. 
*/
    s.PatternType 1 (((call e.call)) to (('*'e.Pat1)))((e.Expr) to (e.Pat2)) t.PRTC
    , <FreshIndex <ClassIdentifier weval e>> : t.wevalnew
        = <ClashLeft s.PatternType 1 
            <ProcessNewSimpleCallCondition 
                ('T')
                (AreEqual ('F')((call e.call))()) 
                <PutPRTCClash t.PRTC ((e.Expr) to (e.Pat2 ('*'e.Pat1)))>>
        >
        <ProcessDelayedCallsInClash s.PatternType
            <ProcessNewSimpleCallCondition
                ('F')
                (AreEqual ('F')((call e.call))((weval e t.wevalnew)('*'e.Pat1)))
                t.PRTC
            >
            (AreEqual ('T')(e.Expr(weval e t.wevalnew))(e.Pat2))
        >;
/* 7а-1. терм (термовый параметр либо символ) - вызов, сопоставление слева, справа е-переменная: два варианта - пустой либо терм+е-неизвестная. */
    s.PatternType 0 (((call e.call)) to (t.PattPart))((e.Expr) to (e.Pattern)) t.PRTC
    , e.Pattern : e.FreePattern (t.class2 e t.name)
    , <IsTerm t.PattPart> : 'T'
    , <FreshIndex <ClassIdentifier weval e>> : t.wevalnew 
        = <ClashLeft s.PatternType 0 
            <ProcessNewSimpleCallCondition 
                ('T')
                (AreEqual ('F')((call e.call))()) 
                <PutPRTCClash t.PRTC ((e.Expr) to (t.PattPart e.Pattern))>
            >
        >
        <ProcessDelayedCallsInClash s.PatternType
            <ProcessNewSimpleCallCondition
                ('F')
                (AreEqual ('F')((call e.call))(t.PattPart(weval e t.wevalnew)))
                t.PRTC
            >
            (AreEqual ('T')((weval e t.wevalnew) e.Expr)(e.Pattern))
        >;
/*
    7а. терм (термовый параметр либо символ) - вызов: два варианта - пустой либо терм+е-неизвестная. Если шло
   сопоставление слева - переходим на сопоставление справа. 
*/
    s.PatternType 0 (((call e.call)) to (t.PattPart))((e.Expr) to (e.Pattern)) t.PRTC
    , <IsTerm t.PattPart> : 'T'
        = <ClashLeft s.PatternType 1
            <PutPRTCClash t.PRTC (((call e.call)e.Expr) to (t.PattPart e.Pattern))>
        >;
/* 7б. терм (термовый параметр либо символ) - вызов, сопоставление справа: два варианта - пустой либо терм+е-неизвестная. */
    s.PatternType 1 (((call e.call)) to (t.PattPart))((e.Expr) to (e.Pattern)) t.PRTC
    , <IsTerm t.PattPart> : 'T'
    , <FreshIndex <ClassIdentifier weval e>> : t.wevalnew 
        = <ClashLeft s.PatternType 1 
            <ProcessNewSimpleCallCondition 
                ('T')
                (AreEqual ('F')((call e.call))()) 
                <PutPRTCClash t.PRTC ((e.Expr) to (e.Pattern t.PattPart))>
            >
        >
        <ProcessDelayedCallsInClash s.PatternType
            <ProcessNewSimpleCallCondition
                ('F')
                (AreEqual ('F')((call e.call))((weval e t.wevalnew)t.PattPart))
                t.PRTC
            >
            (AreEqual ('T')(e.Expr(weval e t.wevalnew))(e.Pattern))
        >;
/* 8. все прочие варианты - сопоставление невыполнимо и коллапсирует. */
    s.PatternType s.Mode t.Clash t.PRTC = <ClashLeft s.PatternType 0 <NullifyPRTC>>;
}

/*
    Функция введена для того чтобы неопределенные вызовы слева и справа в выражении,
   сопоставляемом образцу, обрабатывались одинаково. Вызывается только при сопоставлении
   вызова справа выражения объектному терму, в случае, если вызов отождествляется не с пустым выражением. 
   Если слева тоже стоит вызов и объектный терм, порождает два варианта сопоставления:
   вызов есть пустое выражение и вызов непуст. 
*/

ProcessDelayedCallsInClash {
    s.PatternType t.PRTC (AreEqual (s.Log)((call e.call)e.Expr)(t.Term e.Pattern))
    , <IsTerm t.Term> : 'T'
    , <FreshIndex <ClassIdentifier weval e>> : t.wevalnew
        = <ClashLeft s.PatternType 0 
            <ProcessNewSimpleCallCondition
                ('T')
                (AreEqual ('F')((call e.call))())
                <PutPRTCClash 
                    t.PRTC ((e.Expr) to (t.Term e.Pattern))
                >
            >
        >
        <ClashLeft s.PatternType 0 
            <PutPRTCNewEq 
                <ProcessNewSimpleCallCondition
                    ('F')
                    (AreEqual ('F')((call e.call))(t.Term (weval e t.wevalnew)))
                    t.PRTC
                >
            (AreEqual ('T')((weval e t.wevalnew) e.Expr)(e.Pattern))
            >
        >;
    s.PatternType t.PRTC t.OtherEquation
        = <ClashLeft s.PatternType 0 <PutPRTCNewEq t.PRTC t.OtherEquation>>;
}


/*
   Выделение тех отложенных сопоставлений, в которые были внесены упрощающие изменения.
   [PRTC]=>[PRTC]
*/
FindProcessibleClashes {
/*
    1. Данное отложенное сопоставление содержит существенные изменения по сравнению с исходным отложенным вариантом -
   новая попытка разрешения. 
*/
    s.PatternType t.PRTC
    , <GetPRTCDelayedCl t.PRTC> : e.Del1 (('T')e.Clash) e.Del2 
        = <ClashLeft s.PatternType 0 <PutPRTCClash <ReplacePRTCDelayedCl t.PRTC e.Del1 e.Del2> (e.Clash)>>;
/* 2. Отложенных сопоставлений не осталось. */
    s.PatternType t.PRTC = t.PRTC;
}

/*
    Обработка равенства вызова и куска образца:
    если кусок образца - константное выражение, подстановка его вместо вызова и сохранение равенства в Desired.
    Иначе просто сохранение равенства в Desired.
*/
ProcessNewSimpleCallCondition {
    ('T')(AreEqual e.CallEq) t.PRTC
    , e.CallEq : ('F')((call e.call))(e.Pattern)
        =
        <SubstituteCallFormat (assign (call e.call) (e.Pattern))
            <PutPRTCCallRestr t.PRTC (AreEqual e.CallEq)>
        >;
    ('F')(AreEqual e.CallEq) t.PRTC = <PutPRTCCallRestr t.PRTC (AreEqual e.CallEq)>;
}

/* Добавление нескольких подстановок новой переменной образца. */
AddAssignments {
    t.PRTC (assign e.asg) e.otherasgs
    , <GetPRTCAsgs t.PRTC> : e.assignments 
        =  <AddAssignments <AddNewAssignment 
                <CheckNewAssignment (assign e.asg)(e.assignments)>
                t.PRTC
            > e.otherasgs>;
    t.PRTC = t.PRTC;
} 

/*
    Добавление подстановки новой переменной образца
   (assign (var e.vardata)(e.Expr){or (e.Expr)}^*)[PRTC] =>
   [PRTC]
   
   Если она уникальна - просто подстановка в равенства.
   Иначе помещаем соответствующее уравнение в блок уравнений. 
*/

AddNewAssignment {
/* 1. Подстановка единственна - добавляем в блок. */
    (assign (t.class e e.vardata)(e.Expr)) t.PRTC
    , <GetPRTCAsgs t.PRTC> : e.assignments
    , <ReplacePRTCAsgs 
        t.PRTC 
        (assign (t.class e e.vardata)(e.Expr))
        <Substitute ((assign (t.class e e.vardata)(e.Expr)))e.assignments>
    > : t.PRTC0 
        = <SubstInAllEqs ((assign (t.class e e.vardata)(e.Expr))) t.PRTC0>;
    (assign (t.class e.vardata)(e.Expr)) t.PRTC
    , <PutPRTCAsg 
        t.PRTC 
        (assign (t.class e.vardata)(e.Expr))
        > : t.PRTC0 
        = t.PRTC0;
    (assign (t.class e.vardata)t.Expr or t.Expr) t.PRTC
        = t.PRTC;
/*
   2. Подстановка повторна, но новая подстановка определяет равенство между параметрами - выбираем вновь
   порожденный параметр и поставляем вместо него более старый. В двух вариантах. 
*/
    (assign (var e.vardata)((par s.type t.Name1)) or ((par s.type t.Name2))) t.PRTC
    , <MyIfNotLess t.Name2 <Add <CurrentIndex 'dpar'<Explode s.type>'_ind'> 1>> : 'T'
        = <SubstituteNewRestriction 
            (assign (par s.type t.Name2)((par s.type t.Name1)))
            t.PRTC
        >;
    (assign (var e.vardata)((par s.type t.Name1)) or ((par s.type t.Name2))) t.PRTC
    , <MyIfNotLess t.Name1 <Add <CurrentIndex 'dpar'<Explode s.type>'_ind'> 1>> : 'T'
        = <SubstituteNewRestriction 
            (assign (par s.type t.Name1)((par s.type t.Name2)))
            t.PRTC
        >;
    (assign (var e.vardata)((par s.type t.Name1)) or ((par s.type t.Name2))) t.PRTC
    , <FreshIndex 'par'<Explode s.type>'_ind'> : t.NewName
        = <SubstituteNewRestriction (assign (par s.type t.Name1)((par s.type t.NewName))) 
            <SubstituteNewRestriction 
                (assign (par s.type t.Name2)((par s.type t.NewName)))
                t.PRTC
        >>;
/*
    3. Подстановка повторна, но новая определяет равенство е-параметра базовому (без вызовов)
   выражению, не содержащему этого параметра - порождаем из подстановки новое сужение. 
*/
    (assign (var e.vardata)((par e e.par)) or (e.Expr)) t.PRTC
    , <IfGround e.Expr> : 'T'
    , <FindTerm (par e e.par) e.Expr> : 'F'
        = <SubstituteNewRestriction 
            (assign (par e e.par)(e.Expr))
            t.PRTC
        >;
/* 5. Общий случай - порождаем из повторной подстановки равенство. */
    (assign (t.class e.vardata)(e.Expr1) or (e.Expr2)) t.PRTC 
        =   <AAA><PutPRTCNewEq t.PRTC (AreEqual ('F')(e.Expr1) (e.Expr2))>;
}

/*
    (assign (var e.vardata)(e.Expr))(e.assignments) => (assign (var e.vardata)(e.Expr) or (e.Expr2)) |(assign (var e.vardata)(e.Expr))
   Проверяем, уникальна ли вновь найденная подстановка переменной образца.
*/
CheckNewAssignment {
    (assign (t.class e.vardata)(e.Expr))(e.asgs1 (assign (t.class e.vardata)(e.Expr2)) e.asgs2) 
        =   (assign (t.class e.vardata)(e.Expr2) or (e.Expr));
    (assign (t.class e.vardata)(e.Expr))(e.asgs) 
        = (assign (t.class e.vardata)(e.Expr));
}

/*
    Заменяем все вхождения переменных в определение для параметра свежими параметрами.
   Если при этом не появилось новых подстановок переменных - просто подставляем полученное сужение,
   иначе дополнительно подставляем еще и новые подстановки переменных. 
*/

SubstituteNewRestriction {
    (assign t.par ((s.sort s.type t.name))) t.PRTC
    , weval var : e.1 s.sort e.2
    , <LessGenericPattern t.par (s.sort s.type t.name)> : 
        {'F' = <AddAssignments t.PRTC (assign (s.sort s.type t.name)(t.par))>;
         'T',
        <FreshIndex 'par'<Explode s.type>'_ind'> : t.newparname 
            = 
                <SubstituteNewRestrictionAux (assign t.par ((par s.type t.newparname)))
			<AddAssignments t.PRTC (assign (s.sort s.type t.name)((par s.type t.newparname)))> 
                >;
        };
    (assign t.par (e.Val)) t.PRTC
    , <GetPRTCAsgs t.PRTC> : e.Asgs
    , <GenerateNewParameterAssignments (e.Asgs)()<IterateSubstitute (e.Asgs) e.Val>> : 
        { (e.Asgs)(e.Val)
            = <SubstituteNewRestrictionAux (assign t.par (e.Val)) t.PRTC>;
        (e.newasgmnts)(e.NewVal)
            = <SubstituteNewRestrictionAux (assign t.par (e.NewVal))
                <ReplacePRTCAsgs t.PRTC e.newasgmnts> 
            >;    
        };
}

GenerateNewParameterAssignments {
    (e.AsgList)(e.Processed) = (e.AsgList)(e.Processed); 
    (e.AsgList)(e.Processed) t.Var e.Rest
    , e.AsgList : e.1 (assign t.Var (e.Val)) e.2
        = <GenerateNewParameterAssignments (e.AsgList)(e.Processed e.Val) e.Rest>;
    (e.AsgList)(e.Processed) ('*' e.InBr) e.OutBr
    , <GenerateNewParameterAssignments (e.AsgList)()e.InBr> : (e.NewAsgList)(e.InBrResult) 
        = <GenerateNewParameterAssignments (e.NewAsgList)(e.Processed ('*'e.InBrResult))e.OutBr>;
    (e.AsgList)(e.Processed) (call e.call) e.Rest
        = <MSCPError ('A call in parameter assignment: ')((call e.call))>;
    (e.AsgList)(e.Processed) (s.sort s.type t.name) e.Rest
    , weval var : e.1 s.sort e.2
    , (par s.type <FreshIndex 'par'<Explode s.type>'_ind'>) : t.NewPar
    , (assign (s.sort s.type t.name)(t.NewPar)) : t.NewAsg
            = <GenerateNewParameterAssignments (e.AsgList t.NewAsg)(e.Processed t.NewPar) e.Rest>;
    
    (e.AsgList)(e.Processed) t.1 e.1 
        = <GenerateNewParameterAssignments (e.AsgList)(e.Processed t.1) e.1>;
}

/*
    Вспомогательная функция, подставляющая новое сужение во все имеющиеся данные шага прогонки.
   (assign (s.class s.type t.name) (e.Val))[PRTC] => [PRTC] 
*/

SubstituteNewRestrictionAux {
    t.Restrict t.PRTC
    , t.Restrict : (assign t.par (e.Val))
    , <TermContradiction t.par e.Val> :
        {'T' = <NullifyPRTC>;
        'F'
        , <GetPRTCAsgs t.PRTC> : e.Assignments
        , <GetPRTCAllClashes t.PRTC> : e.Clashes 
            =
            <PutPRTCRestr
                <ReplacePRTCClashes
                    <ReplacePRTCAsgs 
                        <SubstInAllEqs (t.Restrict) t.PRTC>
                        <Substitute (t.Restrict) e.Assignments>
                    >
                    <SubstituteInClashes 0 (t.Restrict) e.Clashes>
                >
                t.Restrict
            >;
        };
}

$ENTRY SubstituteInClashes {
/* 1. В обычные сопоставления подстановка сделана, переходим к отложенным. */
    0 (e.Subst)(Delayed e.DelCl) 
        = (Delayed <SubstituteInClashes 1 (e.Subst) e.DelCl>);
/* 2. Подстановка в обычные сопоставления. */
    0 (e.Subst)((e.Expr) to (e.Pattern)) e.Clashes
        = ((<Substitute (e.Subst) e.Expr>) to (e.Pattern))
        <SubstituteInClashes 0 (e.Subst) e.Clashes>;
/* 3. Подстановка в отложенные сопоставления (дополнительно вносится информация об изменениях) - УДАЛЕНО!. */
    1 (e.Subst) = ;
    1 (e.Subst)((e.Expr) to (e.Pattern)) e.Clashes
    , <Substitute (e.Subst) e.Expr> : e.Expr1
        = ((e.Expr1) to (e.Pattern))
        <SubstituteInClashes 1 (e.Subst) e.Clashes>;
}

/* Вспомогательная функция, подставляющая выход вызова во все имеющиеся данные шага прогонки. */
SubstituteCallFormat { 
    (assign (call t.fname t.fargs)(e.Val)) t.PRTC
    , <GetPRTCCallRestrs t.PRTC> : e.calls
    , <CheckNewEq4Multiplicity e.calls (AreEqual ('F')((call t.fname t.fargs))(e.Val))> : 
        {(AreEqual e.NewEq) e.CallRestrs   
            = <SubstituteCallFormatAux 
		(assign (call t.fname t.fargs)(e.Val))
		<PutPRTCNewEq <ReplacePRTCCallRestrs t.PRTC e.CallRestrs> (AreEqual e.NewEq)>
            >;
        ( )e.CallRestrs 
            = <SubstituteCallFormatAux 
		(assign (call t.fname t.fargs)(e.Val))
		<ReplacePRTCCallRestrs t.PRTC e.CallRestrs>
            >;
        };
}

SubstituteCallFormatAux { 
    (assign (call t.fname t.fargs)(e.Val))t.PRTC
    , <GetPRTCAllClashes t.PRTC> : e.Clashes
        = <SubstInNewEqs ((assign (call t.fname t.fargs)(e.Val)))
            <ReplacePRTCClashes t.PRTC
                <SubstituteInClashes 0 ((assign (call t.fname t.fargs)(e.Val))) e.Clashes>
            >
        >;
}

/* Проверка совпадения двух выражений по модулю временных индексов. */
EquivUpToTI {
     = 'T';
    ((call (t.fname t.ti)(args (arg e.Arg)))e.Expr)(call (t.fname t.ti2)(args (arg e.Arg2))e.Expr2)
        = <LogAnd <EquivUpToTI (e.Arg)e.Arg2><EquivUpToTI (e.Expr)e.Expr2>>;
    (('*'e.InBr) e.OutBr)(('*'e.InBr2) e.OutBr2)
        = <LogAnd <EquivUpToTI (e.InBr)e.InBr2><EquivUpToTI (e.OutBr)e.OutBr2>>;
    (t.1 e.Expr)(t.1 e.Expr2)
        = <EquivUpToTI (e.Expr)e.Expr2>;
    (e.X)e.Y = 'F';
}


/*************************************************************************************
   
                           КОНЕЦ ПРОГОНКИ
   
*************************************************************************************/



*----------------------------------------------------------------------------------------------------------------------------------


/*******************************************************************************
   
                 ЗАГЛУШКИ
   
******************************************************************************/


AAA {=; }
