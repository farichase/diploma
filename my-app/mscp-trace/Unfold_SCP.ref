/****************************************************************************
   
            ÃËÀÂÍÛÉ ÌÎÄÓËÜ MSCP-A
            Ñîäåðæèò ôóíêöèþ, ðåàëèçóþùóþ îñíîâíîé øàã ñóïåðêîìïèëÿöèè:
            UnfoldMain
            Ôîðìàò åå:
            (e.Program)[NodeX]([PathOfX])[FullTree]> ==> [FullTree]
   
****************************************************************************/

$EXTERN prefal, c-prefal;
/* èç ìîäóëÿ basics.ref */
$EXTERN IfASubMultiSet, IfIncluded, CompareMultiSets, SubtractSetFromSet, FindMSIntersection, SubtractMS,
    SubtractEl,InsertInMultiSet,MergeSets,SetMinus,FindNode;
/* èç ìîäóëÿ basics.ref */
$EXTERN GenPath, DeleteNode, InsertNode, Collapse,SaveDriveMarker,Substitute, Map,
    DeleteMarkedEqs,GetParList, SubstInversion;
/* èç ìîäóëÿ basics.ref */
$EXTERN LogAnd, LogAndMerge, LogOrMerge, LogOr, RenewIndices, FreshIndex, CurrentIndex, 
    MyInc, MyOne, MyZero, MyMax, MyAdd, MySub, MyIfNotLess, MytoBool, MyMin, MyNewLevel;
/* èç ìîäóëÿ drive.ref */
$EXTERN ClashLeft,GenerateNextLevel,PostProcessPRTC,FormatStack,AssignTimeStamps, Drive, CheckNarrowingsScreening;
/* èç ìîäóëÿ AnalyzeFunDef.ref */
$EXTERN AssignFunctionFeatures;
/* èç ìîäóëÿ stack.ref */
$EXTERN YieldDecomposition;
/* èç ìîäóëÿ WordEquations.ref */
$EXTERN IfEqIsImplied, ImplyNEqsNew,NormalizeInequalityBlock;
/* èç ìîäóëÿ WordEqsCases.ref */
$EXTERN ProcessLinearInequality, ImplyNEqs;
/* èç ìîäóëÿ residual.ref */
$EXTERN YieldProgramGeneration, PopAllSubtrees;
/* èç ìîäóëÿ generalize.ref */
$EXTERN CheckNode4Generalization,CheckNode4Equivalence,NegativeCleaning, HomeomorphicEmb; /* ïîñëåäíÿÿ äëÿ òåñòà. */
/* èç ìîäóëÿ accessMSCP.ref */
$EXTERN AddNewLines, GetNodeStatus, PutNodeStatus, GetNodeName, PutNodeName, GetNodeRestrictions, PutNodeRestrictions, GetNodeConfig, PutNodeConfig,
    GetNodeStack, PutNodeStack, GetNodeEqs, PutNodeEqs, PutNodeNewEqs, GetNodeNewEqs, ReplaceNodeNewEqs,GetNodeLets, PutNodeLets, GetNodeChildren, PutNodeChildren,
    GenerateNewNode, GetNodeFullConfig, GetStackTop, DeleteNodeActiveData, GetNodeConfFromStack, PutNodeNewEqsToOld,
    GenerateFreshPRTC, ReplacePRTCAllEqs, NullifyNodeEqs, ReplaceNodeGenEqs, GetNodeGenericEqs, ReplaceNodeNegEqs,
    FormatPRTCToPrint, FormatTreeToPrint,RenameStackTop, PutNodeNegEqs, GetNodeNegEqs, SubstituteInNegative;

$ENTRY Go {
    , <Arg 1> : e.input0
    , <Arg 2> : e.output0
    , <GetInputFile ()e.input0> 
    : {(e.folder)e.input
    , <GetOutputFile (e.folder)(e.input)e.output0> : e.output
        =
        <Open 'w' 1 'mscplog'<SubdirSign>'trace_scp'>
        <Open 'w' 2 'mscplog'<SubdirSign>'generalizations'>
        <Open 'a' 3 'mscptest'<SubdirSign>'terms.txt'>
        <Collapse <TimeElapsed 0>>
        <RenewAllIndices>
        <c-prefal 
            (e.output)
            (
                (EXTERN )
                <TransformIntoRefal
                    <PredMainStep 
                        <TransformEncoding ()() <prefal e.input>>
                    >
                (Comment '/* This file was generated by MSCP at '<Time>'.*/')
               (Comment '/* Elapsed time of embeddings is '<FormatOut <Dg 'emb_time'>>'.*/') 
                (Comment '/* Elapsed time of generalizations is '<FormatOut <Dg 'mgu_time'>>'.*/') 
                >
            )
            ('/verbose')
        >
        <Close 1><Close 2><Close 3>;
	'ERR'e.Errmessage = <Prout e.Errmessage>;
	};
}

/* Ïðåîáðàçóåò íàòóðàëüíîå ÷èñëî â ôîðìàò <÷èñëî>.<÷èñëî>. */
FormatOut {
    s.x = <Symb <Div s.x 1000>>'.'<Symb <Mod s.x 1000>>;
}

$ENTRY Delcomm {
     = ;
    (Comment e.1) e.2 = <Delcomm e.2>;
    (t.other e.1) e.2 = (t.other <Delcomm e.1>)<Delcomm e.2>;
}

$ENTRY SubdirSign {
*  Windows
    = '\\';
* Linux
    = '/';
*  Macintosh (Apple)
*    = ':' ; 
}

/*
    Ôóíêöèÿ ïîëó÷åíèÿ èìåíè âõîäíîãî ôàéëà.
   [string] => [string].ref 
*/
GetInputFile {
/* 0. Âûäåëÿåì ïóòü äî ôàéëà. */
    (e.path)e.1 e.2 e.3
    , <SubdirSign> : e.2 
        = <GetInputFile (e.path e.1 e.2) e.3>;
/* 1. Åñëè ôàéë èìååò ðàñøèðåíèå ref, äàííîãî ôàéëà â ïàïêå çàïóñêà íåò, è ïóòü äî íåãî ïóñò, ïðîâåðÿåì åãî íàëè÷èå â ïîäïàïêå test. */
    (/* EMPTY */)e.1'.ref'
    , <ExistFile e.1'.ref'> : False
    , <ExistFile 'tests'<SubdirSign>e.1'.ref'> : True 
        = ('tests'<SubdirSign>)'tests'<SubdirSign> e.1'.ref';
/* 2. Åñëè èìÿ â ïàðàìåòðàõ çàïóñêà â êîìàíäíîé ñòðîêå îòñóòñòâóåò, ôàéëîì ïî óìîë÷àíèþ ñ÷èòàåì tests\test.ref */
    (e.path) /* EMPTY */
    , <ExistFile 'tests'<SubdirSign>'test.ref'> 
    : {True 
        = <Prout ' The input file is tests'<SubdirSign>'test.ref'> ('tests'<SubdirSign>)'tests'<SubdirSign>'test.ref';
	False 
	= 'ERR Please add the file test.ref to the subfolder '<SubdirSign>'tests.';
	};
/* 3. Åñëè èìÿ çàäàíî ñ ðàñøèðåíèåì ref -- îñòàâëÿåì åãî êàê åñòü. */
    (e.path)e.1'.ref'	
	, <ExistFile e.path e.1'.ref'>
	: {True = (e.path)e.path e.1'.ref';
	False = 'ERR The input file does not exist.';
	};
/* 4. Åñëè èìÿ çàäàíî ñ äðóãèì ðàñøèðåíèåì -- âûâîäèì ñîîáùåíèå îá îøèáêå. */
    (e.path)e.1'.'e.2 = 'ERR The input file does not have the proper extension. Please use the input files with .ref extension.';
/* 5. Åñëè èìÿ çàäàíî áåç ðàñøèðåíèÿ -- ïðèïèñûâàåì ðàñøèðåíèå ref. */
    (e.path)e.1 = <GetInputFile (e.path)e.1'.ref'>;
}

/* Ôóíêöèÿ ïîëó÷åíèÿ èìåíè âûõîäíîãî ôàéëà (ôàéëà îñòàòî÷íîé ïðîãðàììû). */
GetOutputFile {
/* 1. Åñëè èìÿ â ïàðàìåòðàõ çàïóñêà â êîìàíäíîé ñòðîêå îòñóòñòâóåò, îñòàòî÷íàÿ ïðîãðàììà ïîìåùàåòñÿ â ôàéë rsd_[èìÿ âõîäíîãî ôàéëà]. */
    (e.path)(e.path e.1)  = e.path'rsd_'e.1;
/* 2. Åñëè èìÿ çàäàíî ñ ðàñøèðåíèåì ref -- îñòàâëÿåì åãî êàê åñòü. */
    (e.path)(e.1) e.2'.ref'
	, <SubdirSign> : e.SubD
	, e.2 : e.x2 e.SubD e.xx2 = e.2'.ref';
/* 2a. Åñëè ïóòü äî âûõîäíîãî ôàéëà ÿâíî íå óêàçàí -- êîïèðóåì ïóòü äëÿ âõîäíîãî ôàéëà.*/
    (e.path)(e.1) e.2'.ref'= e.path e.2'.ref';
/* 3. Åñëè èìÿ çàäàíî ñ äðóãèì ðàñøèðåíèåì -- óäàëÿåì ýòî ðàñøèðåíèå è ïðèïèñûâàåì ðàñøèðåíèå ref. */
    (e.path)(e.1)e.2'.'e.3 = <GetOutputFile (e.path)(e.1)e.2'.ref'>;
/* 4. Åñëè èìÿ çàäàíî áåç ðàñøèðåíèÿ -- ïðèïèñûâàåì ðàñøèðåíèå ref. */
    (e.path)(e.1)e.2 = <GetOutputFile (e.path)(e.1)e.2'.ref'>;
}

/*
   $ENTRY Go {= <Open 'w' 1 'trace_scp'><Put 1 <HomeomorphicEmb ((par e 13 )'II'(par e 269 )'II'(par e 269 )(call (Mul1 14 )(args (arg ('*'(par e 269 ))'II'(par e 269 )))))
                (par e 13 )'III'(par e 542 )'III'(par e 542 )'III'(par e 542 )(call (Mul1 15 )(args (arg ('*'(par e 542 ))'III'(par e 542 ))))>><Close 1>;
            }
   
/*
   Ôóíêöèÿ, îáíóëÿþùàÿ âñå èíäåêñû.
   varl_ind - èíäåêñû ïåðåìåííûõ â ñòåêå;
   pari_ind - èíäåêñû ïàðàìåòðîâ òèïà i;
   wevali_ind - èíäåêñû ñòðîêîâûõ ïåðåìåííûõ òèïà i;
   time_stamp - âðåìåííûå ìåòêè âûçîâîâ ôóíêöèé (äëÿ îòíîøåíèÿ Òóð÷èíà); 
   emb_time - îáùåå âðåìÿ, çàòðà÷åííîå íà ïðîâåðêó âëîæåíèé;
   mgu_time - îáùåå âðåìÿ, çàòðà÷åííîå íà îáîáùåíèÿ;
   eqsolv_time - îáùåå âðåìÿ, çàòðà÷åííîå íà ðåøåíèå óðàâíåíèé â ñëîâàõ.
*/
$ENTRY RenewAllIndices {
    = <Map RenewIndices 
        varl_ind time_stamp pare_ind part_ind pars_ind
        wevalt_ind wevale_ind wevals_ind emb_time mgu_time eqsolv_time Subtree prtc_ind
    >
    <Br 'Changes=F'><Br 'DriveType=C'><Br 'Trace=F'>;
}

ProutByStrings {
    /* EMPTY */ = /* EMPTY */;
    t.1 e.1 = <Prout t.1><Prout><ProutByStrings e.1>;
}

/*******************************  Ôóíêöèè ïåðåêîäèðîâêè **************************************/

/* Ïåðåâîä ïðåäëîæåíèé îñòàòî÷íîé ôóíêöèè èç ïðîìåæóòî÷íîãî ïðåäñòàâëåíèÿ â ïðåäñòàâëåíèå prefal. */
TransformIntoRefal {
    /* EMPTY */ = /* EMPTY */;
    (Comment e.1) e.other = (Comment e.1)<TransformIntoRefal e.other>;
    ((ENTRY) t.FunctionName e.Definitions) e.other
        = ((ENTRY) (Go) <TransformDefinition e.Definitions>) <TransformIntoRefal e.other>;
    ((LOCAL) ((t.FunctionName (e.Set)) t.Number) e.Definitions) e.other
        = ((LOCAL) (<Implode <Explode t.FunctionName>'_'<SymbSet e.Set>'_'<Symb t.Number>>)
        <TransformDefinition e.Definitions>)<TransformIntoRefal e.other>;
    ((LOCAL) (t.FunctionName t.Number) e.Definitions) e.other
        = ((LOCAL) (<Implode <Explode t.FunctionName>'_'<Symb t.Number>>)
        <TransformDefinition e.Definitions>)<TransformIntoRefal e.other>;
}

Trim {
 ' 'e.x = <Trim e.x>;
 e.x' ' = <Trim e.x>;
 e.x = e.x; 
}

/* Ïåðåâîä ïðîìåæóòî÷íîãî ïðåäñòàâëåíèÿ îïðåäåëåíèÿ ôóíêöèè â ïðåäñòàâëåíèå prefal. */
TransformDefinition {
    /* EMPTY */ = /* EMPTY */;
    ((e.Pars)'='(e.RightSide)) e.Other
        = ((<TransformExpressionToPrefal e.Pars>)'='(Expression <TransformExpressionToPrefal e.RightSide>))
        <TransformDefinition e.Other>;
}

/* Ïåðåâîä âûðàæåíèÿ â ïðåäñòàâëåíèå prefal. */
TransformExpressionToPrefal {
    /* EMPTY */ = /* EMPTY */; 
    (Variable s.Sym t.name) e.other
    , <Type t.name>: 'N' 
        = (Variable <Explode s.Sym> <Implode <Symb t.name>>)<TransformExpressionToPrefal e.other>;
    (Variable s.Sym t.name) e.other
    , <Type t.name>: 'D' 
        = (Variable <Explode s.Sym> <Implode <Symb t.name>>)<TransformExpressionToPrefal e.other>;
    (Variable s.Sym t.name) e.other
        = (Variable <Explode s.Sym> t.name)<TransformExpressionToPrefal e.other>;
    s.Sym e.other
    , <Type s.Sym> : 
        {
        'W' e.1
            = (Word s.Sym)<TransformExpressionToPrefal e.other>;
        'N' e.1
            = (MacroDigit s.Sym)<TransformExpressionToPrefal e.other>;
        e.Z = s.Sym <TransformExpressionToPrefal e.other>;
        };
    (MacroDigit e.1) e.2 = (MacroDigit e.1)<TransformExpressionToPrefal e.2>;
    (Bracket' 'e.1) e.2 = (Bracket <TransformExpressionToPrefal e.1>)<TransformExpressionToPrefal e.2>;
    (Call ((t.fname (e.Set)) s.number) e.arg) e.other 
        = (Call <Implode <Explode t.fname>'_'<SymbSet e.Set>'_'<Symb s.number>> <TransformExpressionToPrefal e.arg>)<TransformExpressionToPrefal e.other>;
    (Call (t.fname s.number) e.arg) e.other = (Call <Implode <Explode t.fname>'_'<Symb s.number>> <TransformExpressionToPrefal e.arg>)<TransformExpressionToPrefal e.other>;
    (Condition (Expression e.1)(Pattern e.2)) e.Rest
        = (Condition (Expression <TransformExpressionToPrefal e.1>)(Pattern e.2))<TransformExpressionToPrefal e.Rest>;
}

SymbSet {
    /* EMPTY */ = /* EMPTY */;
    s.Num1 e.Other = <Symb s.Num1><SymbSet e.Other>;
}

/*
    Áàçîâàÿ ôóíêöèÿ ïåðåêîäèðîâêè èç ôîðìàòà prefal âî âíóòðåííèé ôîðìàò MSCP. 
   ((t.fname((e.LHS)e.RHS)^*)^*)((t.fname((e.LHS)e.RHS)^*)^*)e.ExpressionToTransform =>
   ((t.fname((e.LHS)e.RHS)^*)^*)[Stack]
*/
TransformEncoding {
/* 1. Ïåðåêîäèðîâêà çàâåðøåíà. Ñ÷èòàåì, ÷òî âõîäíàÿ òî÷êà ëèøü îäíà, è îíà ïîìåùàåòñÿ â âåðøèíó ñòåêà. */
    (e.functions)(e.entrypoints) = (e.functions)(((assign (var l (0)) (e.entrypoints)) ));
/* 2. Èãíîðèðóåì èíôîðìàöèþ î âíåøíèõ ôóíêöèÿõ. */
    (e.functions)(e.entrypoints)(EXTERN e.ext) e.rest  = <TransformEncoding (e.functions)(e.entrypoints) e.rest>;
/* 3. Èãíîðèðóåì êîììåíòàðèè âíå îïðåäåëåíèé ôóíêöèé. */
    (e.functions)(e.entrypoints)(Comment '*$TRACE'e.xx'='e.xxx'<'e.Conf'>'e.xxxx) e.rest
       = <Br 'Trace=T'><Br 'TracedConf=<'e.Conf'>'><TransformEncoding (e.functions)(e.entrypoints) e.rest>;
    (e.functions)(e.entrypoints)(Comment e.ext) e.rest = <TransformEncoding (e.functions)(e.entrypoints) e.rest>;
/* 4. Âõîäíóþ òî÷êó (åäèíñòâåííóþ) çàïîìèíàåì îòäåëüíî. */
    (e.functions)(e.entrypoints)((ENTRY) t.fname e.CommentBefore ((e.lhs)'=' (Expression e.rhs))e.CommentAfter) e.rest
    , <Br 'entrypoint='<ConvertExpr Entry e.lhs>> : e.1
        = <TransformEncoding (e.functions)(e.entrypoints <ConvertExpr Entry e.rhs>) e.rest>;
/* 5. Ïåðåêîäèðîâêà îïðåäåëåíèÿ ôóíêöèè. */
    (e.functions)(e.entrypoints)((LOCAL) (e.fname) e.definition) e.rest
        = <TransformEncoding (e.functions (e.fname (Sents <ConvertDef e.definition>)))(e.entrypoints) e.rest>;

}

/* Ôóíêöèÿ ïåðåâîäà êîäèðîâêè äëÿ ïðåäëîæåíèé â îïðåäåëåíèè ôóíêöèè èç ôîðìàòà prefal âî âíóòðåííèé ÿçûê MSCP. */
ConvertDef {
    /* EMPTY */ = /* EMPTY */;
/* Êîììåíòàðèè â îïðåäåëåíèÿõ ôóíêöèé óäàëÿþòñÿ. */
    (Comment e.x) e.rest = <ConvertDef e.rest>;
/* Ëåâûå è ïðàâûå ÷àñòè ïîìåùàþòñÿ çà îäíè ñêîáêè è êàæäàÿ ïåðåêîäèðóåòñÿ. */
    ((e.lhs) '=' (Expression e.rhs)) e.rest = ((<ConvertExpr Regular e.lhs>) <ConvertExpr Regular e.rhs>) <ConvertDef e.rest>;
}

/* Ôóíêöèÿ ïåðåâîäà êîäèðîâêè äëÿ âûðàæåíèÿ â îïðåäåëåíèè ôóíêöèè èç ôîðìàòà prefal âî âíóòðåííèé ÿçûê MSCP. */
ConvertExpr {
    s.Mode (Comment e.x) e.rest = <ConvertExpr s.Mode e.rest>;
    s.Mode = /* EMPTY */;
/* 1. ïåðåêîäèðîâêà êîíñòàíò â ñåáÿ. */
    s.Mode s.1 e.1 = s.1 <ConvertExpr s.Mode e.1>;
/* 2. ñëîâî ïåðåêîäèðóåòñÿ ïðîñòî â ñåáÿ. */
    s.Mode (Word e.1) e.2 = <ConvertExpr s.Mode e.1> <ConvertExpr s.Mode e.2>;
/* 3. ïåðåêîäèðîâêà ñòðóêòóðíûõ ñêîáîê. */
    s.Mode (Bracket e.1) e.2 = ('*'<ConvertExpr s.Mode e.1>) <ConvertExpr s.Mode e.2>;
/* 4. ïåðåêîäèðîâêà ïåðåìåííûõ ðàçíûõ òèïîâ. */
    s.Mode (Variable t.type t.name) e.2
    , s.Mode :
        {Regular = (var <Implode t.type> t.name) <ConvertExpr s.Mode e.2>; 
        Entry = (par <Implode t.type> t.name) <ConvertExpr s.Mode e.2>;
        };
/* 5. ÷èñëî ïåðåêîäèðóåòñÿ ïðîñòî â ñåáÿ. */
    s.Mode (MacroDigit s.digit)  e.2 = s.digit <ConvertExpr s.Mode e.2>; 
/* 6. ïåðåêîäèðîâêà âûçîâà ôóíêöèè. */
    s.Mode (Call s.fname e.arg) e.rest
        = (call s.fname (args (arg <ConvertExpr s.Mode e.arg>))) <ConvertExpr s.Mode e.rest>; 
/* 7. â îñòàëüíûõ ñëó÷àÿõ - ñîîáùåíèå îá îøèáêå. */
    e.z = <Prout 'The input language contains non-basic primitives.'> <Recogn_Impossible>;
}


/*
   Äåêîäèðîâàíèå ðåçóëüòàòà ðàáîòû UnfoldMain ïåðåä åãî âûäà÷åé;
   ñèìâîë * ïîñëå îòêðûâàþùåé ñêîáêè óäàëÿåòñÿ.
*/

/*
    Decode {
	= ;
	s.1 e.1 = s.1 <Decode e.1>;
	('*' e.1) e.2 = (<Decode e.1>) <Decode e.2>;
   } 
*/

/*******************************  Çàêîí÷èëèñü ôóíêöèè ïåðåêîäèðîâêè **************************************/


/*
	Ïðîèçâîäèì äåêîìïîçèöèþ âõîäíîãî âûçîâà è çàïóñêàåì ãëàâíóþ ôóíêöèþ.
	(e.Program)(((assign (var l t.n ) (e.expr)))) => (Node Finished (e.NodeData)(Children [Node]^*))
*/
PredMainStep {
    (e.Program)(((assign (var l t.n )(e.expr))))
    , <YieldDecomposition ((assign (var l t.n )(<AssignTimeStamps e.expr>)))> : e.Stack
    , <GetNodeConfFromStack <PutNodeStack <GenerateNewNode (0)> e.Stack>> : t.Root 
        = <YieldProgramGeneration 
            <UnfoldMain 
                (<AssignFunctionFeatures e.Program>) 
                t.Root
                ((0))
                t.Root
            >
        >;
}

/***********************************************************************************************************
     Îñíîâíîé øàã ðàçâåðòêè. 
     <UnfoldMain (e.Program)[NodeX]([PathOfX])[FullTree]> ==> [FullTree]
     [Node]::= (Node t.Status t.Name ((e.Restrictions)(e.ConfigEquations)(e.LetExpressions)(e.FullConfig)(e.Stack))
     (Children [Node]^*))
     t.Status::= Driven | Undriven | Ready | Finished | (Looped e.NodeName)|ReadyForGenCheck
     [PathOfX]:: = ((0) [NodeName]^*)
     [FullTree]::= (Node t.Status (0) (e.NodeData)(Children [Node]^*))
************************************************************************************************************/


UnfoldMain {
/* 0. Ïðèíóäèòåëüíîå çàâåðøåíèå èñïîëíåíèÿ ñóïåðêîìïèëÿöèè. */
    t.Program t.Tree t.Path t.Node, <Cp 'Trace'> : 'K' = t.Tree;
/* 1. Êîðíåâàÿ âåðøèíà íå èìååò ïîòîìêîâ ñ íåïðîãíàííûìè êîíôèãóðàöèÿìè. */
    t.Program (Node Finished t.RootName e.ConfNode)(t.RootName) (Node t.Status t.RootName e.Config) 
        = (Node Finished t.RootName e.ConfNode);
/* 2. ïðîòèâîðå÷èå â êîðíåâîé êîíôèãóðàöèè. */
    t.Program (Node Driven (e.RootName) (e.CurrConf) (Children )) (t.RootName) (Node t.Status t.RootName e.Config) 
        = Contradiction;
/* 3. ïðîòèâîðå÷èå â íåêîðíåâîé êîíôèãóðàöèè - ïåðåõîäèì ê åå ðîäèòåëþ. */
    t.Program t.Node (e.Path t.NodeName) t.Tree
    , <GetNodeStatus t.Node> : Driven
    , <GetNodeChildren t.Node> : 
        = 
        <UnfoldMain 
            t.Program <FindNode (e.Path) <DeleteNode (e.Path t.NodeName) t.Tree>>
            (e.Path)<DeleteNode (e.Path t.NodeName) t.Tree>
        >;
/* 4. çàâåðøåíèå âû÷èñëåíèé â íåêîðíåâîé êîíôèãóðàöèè - ïåðåõîäèì ê åå ðîäèòåëþ. */
    t.Program t.Node t.Path t.Tree
    , <GetNodeStatus t.Node> : Finished
    , <FindAncestorPath t.Path <GetNodeName t.Node>> : t.NewPath
        = <UnfoldMain 
            t.Program <FindNode t.NewPath t.Tree>
            t.NewPath t.Tree
        >;
/* 5. åñëè óçåë ïðîãíàí è èìååò åäèíñòâåííûé äî÷åðíèé óçåë ñ âûòîëêíóòûì âûçîâîì, çàìåíÿåì åãî äàííûìè äàííûå óçëà. */
    t.Program t.Node (e.Path) t.Tree
    , <GetNodeStatus t.Node> : Driven
    , <GetNodeChildren t.Node> : e.1 (e.PushChild ((Push)e.OtherConf)) e.2
    , <GetNodeRestrictions t.Node> : e.Restrictions
    , <GetNodeStack (e.PushChild ((Push)e.OtherConf))> : e.NewStack
    , <PutNodeStatus t.Node Ready> : t.Node1
    , <GetNodeConfFromStack <PutNodeStack t.Node1 e.NewStack>> : t.Node2
    , <PutNodeChildren t.Node2 > : t.ProcessedNode
        = 
        <UnfoldMain
            t.Program 
	    <Putout 1 'New stack is 'e.NewStack>
            <PrintIfTracing t.ProcessedNode>
            (e.Path) 
            <InsertNode t.ProcessedNode (e.Path)t.Tree>
        >;
/* 5à. åñëè óçåë ïðîãíàí è èìååò åäèíñòâåííûé äî÷åðíèé óçåë, ïðè÷åì òðàíçèòíûé, åãî íå îáîáùàåì	 
*/
/*
    	t.Program 
        (Node ReadyForGenCheck t.Nodename ((e.Restrictions) e.Conf) 
            (Children (Node Undriven t.ChildNode ((Always) e.NewConf)))
        )
        (e.Path) t.Tree 
		= 
		<UnfoldMain
			t.Program 
				<PrintIfTracing (Node Driven t.Nodename ((e.Restrictions) e.Conf)
                                                        (Children (Node Undriven t.ChildNode ((Always) e.NewConf))))>
				(e.Path) 
				<InsertNode (Node Driven t.Nodename ((e.Restrictions) e.Conf) 
                                    (Children (Node Undriven t.ChildNode ((Always) e.NewConf)))
                                    )(e.Path)t.Tree
                                >
		>; 
*/

/* 6. åñëè óçåë ïðîãíàí èëè îêàçàëîñü, ÷òî åãî êîíôèãóðàöèÿ ïîâòîðíà):
	a) âñòàâëÿåì ïðîãîíêó â äåðåâî ïóòåé,
	è
	á) èùåì áëèæàéøèé íåïðîãíàííûé óçåë.
*/
    t.Program t.Node (e.Path) t.Tree
    , <CheckAlter <GetNodeStatus t.Node> EITHER Driven (Looped)> : True
        = 
        <UnfoldMain
            t.Program 
            <ChooseUndrivenNode 
                    t.Node
                    (e.Path) 
                    <InsertNode t.Node(e.Path)t.Tree>
            >
        >;
/* 7. Ïðîâåðÿåì, èìåþòñÿ ëè êîíôèãóðàöèè, ïîâòîðÿþùèå äàííóþ. */
/*
    	t.Program (Node Undriven t.Name (e.Conf (e.FullConf)(e.Stack))
		)(e.Path t.Last) t.Tree 
		= <UnfoldMain t.Program 
                        (Node 
                            <CheckNode4Equivalence 
                                (e.FullConf)
                                (e.Path)
                                t.Tree
                            > 
                            t.Name (e.Conf (e.FullConf)  (e.Stack))
                        )
                    (e.Path t.Last) t.Tree
                    >; 
*/
    t.Program t.Node (e.Path t.Last) t.Tree
    , <GetNodeStatus t.Node> : Undriven
    , <DemandIfTraced t.Tree t.Node> : e.Val
    , <PutNodeStatus t.Node Ready> : t.ProcessedNode
        = <UnfoldMain 
            t.Program 
            t.ProcessedNode
            (e.Path t.Last) t.Tree
        >;
/* 8. Åñëè óçåë òðàíçèòíûé, ìû åãî íå îáîáùàåì. */
/*
    	t.Program (Node ReadyForGenCheck t.Name ((Always)e.Conf (e.FullConf)(e.Stack))
		)(e.Path t.Last) t.Tree 
		= <UnfoldMain t.Program 
                        (Node 
                            Ready 
                            t.Name ((Always)e.Conf (e.FullConf)  (e.Stack))
                        )
                    (e.Path t.Last) t.Tree
                    >;
*/
/* 9. Ïðîâåðÿåì, ÿâëÿåòñÿ ëè óçåë _ïîñëå_ ïðîãîíêè êàíäèäàòîì íà îáîáùåíèå. */
    t.Program t.Node (e.Path t.Last) t.Tree
    , <GetNodeStatus t.Node> : ReadyForGenCheck
    , <GetNodeName t.Node> : t.Name
    , <GetNodeConfig t.Node> : e.FullConf
    , <GetNodeEqs t.Node> : e.Eqs
    , <GetNodeStack t.Node> : e.Stack
    , e.Stack : ((assign t.var ((call t.funname e.Arg)))e.ThisLevel) e.OtherLevels
    , <GetFunRecursionType t.funname t.Program> : s.Flag
    , <PutNodeStatus t.Node <CheckNode4Generalization t.Name s.Flag (e.Eqs)(e.FullConf)(e.Stack)(e.Path)t.Tree>> : t.ProcessedNode
        = <UnfoldMain t.Program 
            t.ProcessedNode
            (e.Path t.Last) t.Tree
        >;
/* 10à. Óçåë îáîáùàåòñÿ --- âàðèàíò îáîáùåíèÿ ñíèçó (âåðõíÿÿ êîíôèãóðàöèÿ åñòü MGU äëÿ íèæíåé ñ òî÷íîñòüþ äî ïåðåèìåíîâêè).
   Çäåñü ìîæåò áûòü êàê ïðîñòî âëîæåíèå, òàê è îáîáùåíèå ïî ðåñòðèêöèÿì (óðàâíåíèÿ èëè íåðàâåíñòâà). 
*/
    t.Program t.Node (e.Path t.Last) t.Tree
    , <GetNodeStatus t.Node> : 
            (Generalized (e.NodeName) 
                (Looped To t.AncestorName With e.Subs and (Generic e.GenGenEqs)(Negative e.NegGenEqs))(e.GenFullConf)(e.GenStack)(e.Assignments)(e.Children))
    , <FindNode (<GenPath t.AncestorName>) t.Tree> : t.AncestorNode
    , <GetNodeGenericEqs t.AncestorNode> : e.OldGenEqs
    , <GetNodeNegEqs t.AncestorNode> : e.OldNegEqs
    , <DeleteMarkedEqs ('S')<GetNodeNewEqs t.AncestorNode>> : e.OldNewEqs
    , <Substitute (<Substitute (<CutLetData e.Assignments>)e.Subs>)e.OldGenEqs e.OldNewEqs> : e.EqsSubstituted
    , <SubstituteInNegative (<Substitute (<CutLetData e.Assignments>)e.Subs>)e.OldNegEqs> : e.NEqsSubstituted
    , <SubstituteInNegative (<CutLetData e.Assignments>) e.NegGenEqs> : e.ProcNegEqs
    , <GetPreservedEqs 
        (e.OldGenEqs e.OldNewEqs)(e.EqsSubstituted)
        (e.GenGenEqs <GetNodeGenericEqs t.Node><GetNodeNewEqs t.Node>)
    > : e.CommonEqs
    , <ImplyNEqsNew 
        (<GetNodeNegEqs t.Node> e.ProcNegEqs)
        (<Zip (e.NEqsSubstituted)(e.OldNegEqs)>)
    > : s.Log e.CommonNeqs0
    , <SubstituteInNegative (<SubstInversion e.Subs>) e.CommonNeqs0> : e.CommonNeqs
    , <Putout 2 '  Checking embedding:'>
    <Putout 2 <AddNewLines <GetNodeNegEqs t.Node> e.ProcNegEqs>>
    <Putout 2 <AddNewLines e.NEqsSubstituted>> : /* */
    , <LogAnd <EquivalentEqSet (e.OldGenEqs e.OldNewEqs) e.CommonEqs> s.Log> :
        {'T'
        , <NullifyNodeEqs <DeleteNodeActiveData t.Node>> : t.DrivenNode
        , <GetNodeConfFromStack <PutNodeStack
            <PutNodeStatus <GenerateNewNode (e.NodeName 0)> (Looped To t.AncestorName With e.Subs)>
            e.GenStack>> : t.NewNode
        , <PutNodeChildren <PutNodeStatus t.DrivenNode Driven> t.NewNode e.Children> : t.Node3
        , <PutNodeLets t.Node3 (Let e.Assignments In (e.GenFullConf))> : t.ProcessedNode
		= <Putout 1><Putout 1 '  Equations are preserved:' <AddNewLines e.CommonEqs>>
                  <Putout 2><Putout 2 '  Equations are preserved:' <AddNewLines e.CommonEqs>>
                  <Putout 1><Putout 1 '  Inequalities are preserved:' <AddNewLines e.CommonNeqs>>
                  <Putout 2><Putout 2 '  Inequalities are preserved:' <AddNewLines e.CommonNeqs>>
                    <UnfoldMain t.Program 
                    <PrintIfTracing t.ProcessedNode>
                    (e.Path t.Last) t.Tree
                >;
        'F'
        , <PutNodeChildren 
                <ReplaceNodeNewEqs
                <PutNodeStatus 
                    <ReplaceNodeNegEqs 
                        <ReplaceNodeGenEqs t.AncestorNode e.CommonEqs <Substitute (<SubstInversion e.Subs>)e.GenGenEqs>> 
                        <NegativeCleaning e.CommonNeqs e.NegGenEqs>
                    > 
                Undriven>
                <MarkAllEqs ('S')e.OldNewEqs>>
        > : t.ProcessedAncNode
            = <Putout 1><Putout 1 '  Equations are cut:'<AddNewLines e.OldGenEqs e.OldNewEqs>>
                <Putout 1 '   to' <AddNewLines e.CommonEqs e.GenGenEqs>>
            <Putout 1><Putout 1 '  Inequalities are cut:'<AddNewLines e.OldNegEqs>>
                <Putout 1 '  to'<AddNewLines e.CommonNeqs e.NegGenEqs>>
            <Putout 2><Putout 2 '  Equations are cut:'<AddNewLines e.OldGenEqs e.OldNewEqs>>
                <Putout 2 '  to'<AddNewLines e.CommonEqs e.GenGenEqs>>
            <Putout 2><Putout 2 '  Inequalities are cut:'<AddNewLines e.OldNegEqs>>
                <Putout 2 '  to'<AddNewLines e.CommonNeqs e.NegGenEqs>>
            <UnfoldMain t.Program
                <PrintIfTracing t.ProcessedAncNode>
                (<GenPath t.AncestorName>) t.Tree
            >;
        };
/* 10á. Óçåë îáîáùàåòñÿ --- îáîáùåíèå â êîíôèãóðàöèè ïðåäêà (âñå ïðåæíèå ïîòîìêè êîíôèãóðàöèè ïðåäêà óäàëÿþòñÿ). */
    t.Program t.Node (e.Path t.Last) t.Tree
    , <GetNodeStatus t.Node> : (Generalized t.AncestorName (UpperGeneralization With ((Generic e.NewEquations)(Negative e.Negs)))(e.GenFullConf)(e.GenStack)(e.Assignments)(e.Children))
    , t.AncestorName : (e.AncestorList)
    , <FindNode (<GenPath t.AncestorName>) t.Tree> : t.AncestorNode0
    , <FindGenerEqs 
        (<GetParList ()e.GenFullConf>)
        (e.Assignments)
        <GetNodeNewEqs t.AncestorNode0><GetNodeGenericEqs t.AncestorNode0>
    > : e.GenerEqs
    , <FindGenerNegative 
        (<GetParList ()e.GenFullConf>)
        (e.Assignments)
        <GetNodeNegEqs t.AncestorNode0>
    > : e.GenerNegative
    , <GetNegativeRestrictionsFromProgramRules t.Program e.GenFullConf> : e.RulesNegative
    , <NullifyNodeEqs t.AncestorNode0> : t.AncN1
    , <PutNodeLets t.AncN1 (Let e.Assignments In (e.GenFullConf))> : t.AncN2
    , <DeleteNodeActiveData t.AncN2> : t.AncN3
    , <PutNodeStatus t.AncN3 Driven> : t.AncN4
    , <GenerateNewNode (e.AncestorList 0)> : t.NewNode0
    , <PutNodeStatus t.NewNode0 Undriven> : t.NewNode1
    , <PutNodeStack t.NewNode1 e.GenStack> : t.NewNode2
    , <PutNodeConfig t.NewNode2 e.GenFullConf> : t.NewNode3
    , <PutNodeNegEqs 
        <PutNodeNewEqsToOld 
            <PutNodeNewEqs t.NewNode3 e.NewEquations e.GenerEqs>
        > 
        <NegativeCleaning e.Negs e.RulesNegative e.GenerNegative>
    > : t.ProcessedNewNode
    , <PutNodeChildren t.AncN4 t.ProcessedNewNode e.Children> : t.ProcessedAncNode
        =	
        <UnfoldMain t.Program
            <PrintIfTracing t.ProcessedAncNode>
            (<GenPath t.AncestorName>) t.Tree
        >;
/* 11. Åñëè óçåë íå ïðîãíàí, çàïóñêàåì ïðîãîíêó. */
/* Íà ñàìîì íèæíåì óðîâíå ñàìàÿ ëåâàÿ ïåðåìåííàÿ - âûçîâ: ïðîèçâîäèì ïðîãîíêó äëÿ ýòîãî âûçîâà. */
    t.Program t.Node (e.Path) t.Tree
    , <GetNodeStatus t.Node> : Ready
    , <GetNodeStack t.Node> : e.Stack
    , <GetNodeName t.Node> : t.Name
    , <GetStackTop e.Stack> : (call t.fdata (args (arg e.Arg)))
    , t.fdata : (t.fname t.timestamp)
    , <PutNodeStatus t.Node ReadyForGenCheck> : t.Node1
    , <YieldDriving 
        <FindFunctionDef t.Program (call t.fdata (args (arg e.Arg)))> 
        t.fdata 
        (e.Arg) 
        t.Name 
        t.Node
    > : e.NewChildren (e.RuleSet) t.NewStatus
    , <PutNodeStatus 
        <RenameStackTop 
            <PutNodeChildren 
                t.Node1 
                e.NewChildren
            > 
            t.fname (e.RuleSet)
        > 
        t.NewStatus
    > : t.ProcessedNode
        = <UnfoldMain 
            t.Program 
            <PrintIfTracing t.ProcessedNode>
            (e.Path) t.Tree
        >;

/* 12. âû÷èñëåíèÿ â óçëå çàâåðøåíû - âñòàâëÿåì äàííûé óçåë â äåðåâî ñ ïîìåòêîé Finished. */
    t.Program t.Node (e.Path) t.Tree
    , <PutNodeStatus t.Node Finished> : t.ProcessedNode
        = <UnfoldMain 
            t.Program 
            t.ProcessedNode
            (e.Path) 
            <PrintIfTracing <InsertNode t.ProcessedNode(e.Path)t.Tree>>
        >;
}

DemandIfTraced {
 t.Tree t.Node
 , <Dg 'Trace'> :
 { 'F' = <Br 'Trace=F'>;
   'T'
    , <GetNodeStack t.Node> : e.Stack
    , <GetStackTop e.Stack> : 
  { (call t.fdata (args (arg e.Arg)))
    , t.fdata : (t.fname e.timestamp)
    , <Cp 'TracedConf'> : e.Tracing
    , t.fname :
     { (t.name (e.RSet))
       , <Explode t.name> : 
       { e.name
       , e.Tracing : e.Tr1'<'e.name' 'e.Tr2'>'e.Tr3
         = <Open 'w' 4 'mscplog'<SubdirSign>'curr_trace'><PrintTraced t.Tree><Close 4>
           <System './trace_echo.sh'><WaitUntilInput>/*<Open 'w' 5 'key.txt'><ProcessTrace <Get 5>><Close 5>  */
/*           <Putout 0 'Input \'exit\' to stop, \'go\' to continue in trace mode, \'run\' to continue in default mode.'>
         <ProcessTrace <Get 0>>*/;
	 e.rest = <Br 'Trace=T'>;
	};
      t.name
       , <Explode t.name> : e.name
       , e.Tracing : e.Tr1'<'e.name' 'e.Tr2'>'e.Tr3
         =  <Open 'w' 4 'mscplog'<SubdirSign>'curr_trace'><PrintTraced t.Tree><Close 4>
           <System './trace_echo.sh'><WaitUntilInput>/*<Open 'w' 5 'key.txt'><ProcessTrace <Get 5>><Close 5>*/
         /*<Putout 0 'Input \'exit\' to stop, \'go\' to continue in trace mode, \'run\' to continue in default mode.'>
         <ProcessTrace <Get 0>>*/;
      t.rest = <Br 'Trace=T'>;
    };
    e.rest = <Br 'Trace=T'>;
   };
 };
}

WaitUntilInput {
  , <ExistFile 'key.txt'> : 
 {True
  , <Open 'r' 5 'key.txt'> : e.x
  , <Get 5> :
   {  'K'e.1 = <Br 'Trace=K'><Close 5>;
      'F'e.1 = <Br 'Trace=F'><Close 5>;
      'T'e.1 = <Br 'Trace=T'><Close 5>;
      e.Z = <Close 5><WaitUntilInput>;
  };
  False = <WaitUntilInput>; };
}

ProcessTrace {
 'K'e.1 = <Br 'Trace=K'>;
 'F'e.1 = <Br 'Trace=F'>;
 'T'e.1 = <Br 'Trace=T'>;
}

GetFunRecursionType {
    ((t.fname (e.RSet)) t.timestamp)(e.1 (t.fname (Recursion s.Flag) e.OtherDef) e.2) = s.Flag;
    (t.fname t.timestamp)(e.1 (t.fname (Recursion s.Flag) e.OtherDef) e.2) = s.Flag;    
}

MarkAllEqs {
    (s.Log) = /* EMPTY */;
    (s.Log) (AreEqual (s.Log2)e.EqData) e.Rest
        = (AreEqual (s.Log)e.EqData)<MarkAllEqs (s.Log)e.Rest>;
}

/*
    Ïîèñê îïðåäåëåíèÿ ôóíêöèè, êîòîðóþ ïëàíèðóåòñÿ âûïîëíèòü.
   ([Program])[FunctionName] => ([e.FirstPattern])([e.FirstRightHandSide])((([Pattern])[RightHandSide])^*)
*/
FindFunctionDef {
    (e.ProgramBefore (t.fname e.Features (Sents e.Defs)) e.ProgramAfter) (call ((t.fname (e.RSet)) t.timestamp) e.Args)
        = <ExtractRuleSubset t.fname(e.Defs)>;
    (e.ProgramBefore (t.fname e.Features (Sents e.Defs)) e.ProgramAfter) (call (t.fname t.timestamp) e.Args)
        = <ExtractRuleSubset t.fname(e.Defs)>;
}

GetNegativeRestrictionsFromProgramRules {
    t.Program e.Config
    , <GetConfigCallsWithGaps e.Config> : e.Calls
    , <GetFailedClashes t.Program e.Calls> : e.NegativeData
         = <Putout 2 'Getting negative conditions from rules set:'>
         <Putout 2 <AddNewLines e.Calls>>
         <Putout 2 'produce conditions:'>
         <Putout 2 <AddNewLines e.NegativeData>>
            e.NegativeData;
}

GetFailedClashes {
    t.Program (s.FunName (s.Number e.FailedRules)(e.Arg)) e.Calls
    , <FindFunctionDef t.Program (call (s.FunName 0)(args (arg )))> : (s.PatternType)(e.LHS)(e.RHS)(e.Defs)
    , <FilterLHS (s.Number e.FailedRules)(1)(((s.PatternType)(e.LHS)e.RHS)e.Defs)> : e.LHSSet
    , <GetNegativeConditions (e.Arg)e.LHSSet> : e.NegativeConditions
        = <NormalizeInequalityBlock ( )e.NegativeConditions><GetFailedClashes t.Program e.Calls>;
    t.Program /* EMPTY */ = /* EMPTY */;
}

FilterLHS {
    (e.Sequence)(s.Current)(((s.PatternType)(e.LHS)e.RHS)e.Other)
    , e.Sequence
    : {
        e.Before s.Current e.Rest
            = ((s.PatternType)e.LHS)<FilterLHS (e.Rest)(<Add s.Current 1>)(e.Other)>;
        e.NotContainingCurrent
            = <FilterLHS (e.Sequence)(<Add s.Current 1>)(e.Other)>;
        };
    (e.Sequence)(s.Current)(/* EMPTY */) = /* EMPTY */;
}

GetNegativeConditions {
    (e.Expr)((s.Pattern)e.LHS)e.Other
        = (OR (s.Pattern)((e.Expr) to (e.LHS))) <GetNegativeConditions (e.Expr)e.Other>;
    (e.Expr) /* EMPTY */ = /* EMPTY */;
}

GetConfigCallsWithGaps {
    e.1 ('*'e.2)e.3 = <GetConfigCallsWithGaps e.1 e.2 e.3>;
    e.1 (call t.funname (args (arg e.Arg))) e.2
    , t.funname : ((s.InitName t.Rules) t.TimeStamp)
    , <SetMinus <GenNaturalSeq t.Rules> t.Rules>
    : {
        (t.SomeRuleNumber e.Other)
            = (s.InitName (t.SomeRuleNumber e.Other) (e.Arg)) <GetConfigCallsWithGaps e.Arg e.2>;
        (/* EMPTY */)
            = <GetConfigCallsWithGaps e.Arg e.2>;
    };
    e.Z = /* EMPTY */;
}

GenNaturalSeq {
    (e.Z s.Last)
        = <GenNaturalSeq Started (1)(s.Last)>;
    Started (e.Z s.Last)(s.Last) = (e.Z s.Last);
    Started (e.Z s.NotLast)(s.Last)
        = <GenNaturalSeq Started (e.Z s.NotLast <Add s.NotLast 1>)(s.Last)>;
}

ExtractRuleSubset {
    s.funname (((s.PatternType)(e.LHS)e.RHS)e.Defs) = (s.PatternType)(e.LHS)(e.RHS)(e.Defs);
    (s.funname (e.Numbers))(e.Defs)
    , <ExtractRuleSubset Started (1)(e.Numbers)e.Defs> : ((s.PatternType)(e.LHS)e.RHS)e.OtherDefs
        = (s.PatternType)(e.LHS)(e.RHS)(e.OtherDefs);
    Started (s.Num)(s.Num e.Other)(e.Rule)e.RestRules 
        = (e.Rule)<ExtractRuleSubset Started (<Add s.Num 1>)(e.Other)e.RestRules>;
    Started (s.Num)(s.OtherNum e.Other)(e.Rule)e.RestRules 
        = <ExtractRuleSubset Started (<Add s.Num 1>)(s.OtherNum e.Other)e.RestRules>;
    Started (s.Num)()e.RestRules = ;
}

/*
    Çàïóñê ïðîöåññà ïðîãîíêè.
   ([Pattern])([RightHandSide])([FunctionDefinition]^*) [FunctionName] 
   ([FunctionArgument]) 
   [NodeName] ((e.Restrictions)(e.LetExpressions)(e.ConfigEquations)(e.FullConfig)(e.Stack)) =>
   [Tree]^+ (íàáîð âåðøèí - äî÷åê [NodeName])
*/
YieldDriving {
    (e.LHS)((Restart))(e.RestDefs) t.fname (e.Config) t.NodeName ((e.Restrictions)(e.ConfigEquations)(e.FullConfig)(e.Stack)) 
        = <PushNodesScreening 
            <GenerateNextLevel 
                (1)(/* EMPTY */)(Unmod) t.NodeName (0) 
                ((e.Restrictions)(e.ConfigEquations)()(e.FullConfig)(e.Stack))
                (t.fname (Try e.Config)(SubsTo (Restart))(e.RestDefs))
                <PostProcessPRTC (/* EMPTY */)(/* EMPTY */)
                    <Drive ( )
                        <ClashLeft 0
                            <SaveDriveMarker 'dwevale_ind'> 
                            <SaveDriveMarker 'dwevalt_ind'>
                            <SaveDriveMarker 'dwevals_ind'>
                            <Putout 1 'New Clash: No ' <FreshIndex 'prtc_ind'>>
                            <Put 1
                                ((e.ConfigEquations (Desired))()()(((e.Config) to (e.LHS))(Delayed ))('T'))
                            >
                            <Putout 1>
                    >>
                >
            >
        >;
    (s.PatternType)(e.LHS)(e.RHS)(e.RestDefs) t.fname (e.Config) t.NodeName t.WholeNode
    , <Br 'PatternType='s.PatternType> : e.Z
    , <GetNodeEqs <PutNodeNewEqsToOld t.WholeNode>> : e.ConfigEquations
    , <ReplacePRTCAllEqs <GenerateFreshPRTC (e.LHS)(e.Config)> e.ConfigEquations> : t.PRTC
        = <PushNodesScreening
            <GenerateNextLevel 
                (1)(/* EMPTY */)(Unmod)t.NodeName (0) 
                t.WholeNode
                (t.fname (Try e.Config)(SubsTo e.RHS)(e.RestDefs))
                <PostProcessPRTC (/* EMPTY */)(/* EMPTY */)
                    <RenewIndices 'vare_ind'>
                    <RenewIndices 'vars_ind'>
                    <RenewIndices 'vart_ind'>
                    <Drive s.PatternType ()
                        <ClashLeft s.PatternType 0
                            <SaveDriveMarker 'dpare_ind'> 
                            <SaveDriveMarker 'dpart_ind'>
                            <SaveDriveMarker 'dpars_ind'>
                            <Putout 1 'New Clash: No '<FreshIndex 'prtc_ind'>>
                            <Putout 1 <FormatPRTCToPrint t.PRTC>>
                            t.PRTC
                            <Putout 1>
                        >
                    >
                >
                ReadyForGenCheck
            >
        >;
}

PushNodesScreening {
    e.Children (e.Rules) t.Status
    , <GetReadyNodes e.Children> :
        {t.Ch1 t.Ch2 e.ChOther
            = <AnalyzePushNodes (t.Ch1 t.Ch2 e.ChOther) e.Children> (e.Rules) t.Status;
        e.Z /* Êîëè÷åñòâî push-ïîòîìêîâ ïîñëå ïðîãîíêè ìåíüøå 2. */
            = e.Children (e.Rules) t.Status;
        };
}

GetReadyNodes {
    t.Node e.Other
    , <GetNodeStatus t.Node> : 
        {Ready
            = t.Node <GetReadyNodes e.Other>;
        e.Z
            = <GetReadyNodes e.Other>;
        };
    /* EMPTY */ = /* EMPTY */;
}

AnalyzePushNodes {
    (t.Node) e.Children = e.Children;
    (t.Node e.Other) e.Children
    , <GetNodeRestrictions t.Node> : e.Restrs
    , <CheckNarrowingsScreening (e.Restrs)(e.Other)> :
        { t.OtherNode
        , e.Children : e.Ch1 t.Node e.Ch2
            =  <AnalyzePushNodes (e.Other) e.Ch1 e.Ch2>;
        /* EMPTY */
            = <AnalyzePushNodes (e.Other) e.Children>;
        };
}

EquivalentEqSet {
    (e.1)e.1 = 'T';
    (e.1 t.1 e.2) e.3 t.1 e.4 = <EquivalentEqSet (e.1 e.2) e.3 e.4>;
    (e.1 (AreEqual t.Log1 t.LHS t.RHS) e.2) e.3 (AreEqual t.Log2 t.RHS t.LHS) e.4 
        = <EquivalentEqSet (e.1 e.2) e.3 e.4>;
    e.Other = 'F';
}

EquivalentNEqSet {
    ( )e.1 = 'T';
    (e.1 t.1 e.2) e.3 t.1 e.4 = <EquivalentNEqSet (e.1 e.2) e.3 e.4>;
    e.Other = 'F';
}

FindEqsIntersection {
    (e.OldEqs)(e.SubbedEqs)e.NewEqs
        = <FindEqsIntersection Started (<Zip (e.OldEqs)(e.SubbedEqs)>)e.NewEqs>;
    Started ((t.0 t.1) e.1) e.20 t.1 e.21 = t.0 <FindEqsIntersection Started (e.1)e.20 t.1 e.21>;
    Started ((t.0 t.1) e.1) e.2
    , <IfEqIsImplied t.1(e.2)> :
        {'F'
            = <FindEqsIntersection Started (e.1)e.2>;
        'T'
            = t.0 <FindEqsIntersection Started (e.1)e.2>;
        };
    Started (/* EMPTY */) e.2 = /* EMPTY */;
}

$ENTRY Zip {
    (t.1 e.1)(t.2 e.2) = (t.1 t.2)<Zip (e.1)(e.2)>;
    ()() = ;
}

GetOldVariant {
    t.0 t.1 = t.0;
    t.0 = ;
}

/*
    Âûáîð äî÷åðíåãî óçëà ñ íåçàâåðøåííîé ðàçâåðòêîé.
   Âûáèðàåì èç ñïèñêà äî÷åðíèõ âåðøèí äàííîé âåðøèíû òå, êîòîðûå èìåþò ñòàòóñ Driven, Undriven èëè Ready.
   Åñëè òàêèõ âåðøèí íåò, âñòàâëÿåì äàííóþ âåðøèíó â äåðåâî ñ ïîìåòêîé Finished.
   Ôîðìàò ôóíêöèè:
   [ParentNode]([ChildNode]^*)[path][tree]=>[Node][path][tree]
*/
$ENTRY ChooseSuccessorNode {
/* 1. Ó äàííîé âåðøèíû íåò äî÷åðíèõ âåðøèí, â êîòîðûõ íå äîäåëàíà ðàçâåðòêà -> âåðøèíà ïîìå÷àåòñÿ êàê Finished */
    t.Node (/* EMPTY */)(e.Path)(e.Tree)
    , <PutNodeStatus t.Node Finished> : t.Node1
    , <PutNodeChildren t.Node1> : t.PreProcNode
    , t.Node :
        { (Node e.XXX)
        , <PutNodeLets t.PreProcNode (Subtree <FreshIndex 'Subtree'>)> : t.Node3
        , <DeleteNodeActiveData t.Node3> : t.ProcessedNode 
            = <Collapse <Br 'Subtree'<Symb <CurrentIndex 'Subtree'>>'='t.Node1>>
                t.ProcessedNode(e.Path)<InsertNode t.ProcessedNode(e.Path)(e.Tree)>;
        (t.OtherType e.XXX)
            = t.PreProcNode(e.Path)<InsertNode t.PreProcNode(e.Path)(e.Tree)>;
        };
/* 2. Î÷åðåäíîé äî÷åðíèé óçåë èìååò ñòàòóñ çàâåðøåííîãî (èëè çàöèêëåííîãî). Ðàññìàòðèâàåì äðóãèå. */
    t.Node (t.ChildNode e.OtherChildren)(e.Path)(e.Tree)
    , <CheckAlter <GetNodeStatus t.ChildNode> EITHER Finished (Looped)> : True
        = <ChooseSuccessorNode t.Node (e.OtherChildren)(e.Path)(e.Tree)>;
/* 3. Íàøåëñÿ èñêîìûé äî÷åðíèé óçåë - âîçâðàùàåì åãî è ïóòü äî íåãî. */
    t.Node (t.ChildNode e.OtherChildren)(e.Path)(e.Tree)
    , <GetNodeName t.ChildNode> : t.ChildName
        = t.ChildNode <ProlongPath (e.Path) t.ChildName>(e.Tree);
}

CheckAlter {
    (t.x e.x) EITHER e.1 (t.x) e.2 = True;
    t.x EITHER e.1 t.x e.2 = True;
    t.x EITHER e.1 = False;
}

IsRoot {
    t.Node
    , <GetNodeName t.Node> : (t.Single)
        = True;
    t.Node = False;
}


/*
    Âûáîð áëèæàéøåãî ñîñåäà ñî ñòàòóñîì íåçàâåðøåííîé ïðîãîíêè (åñëè òàêîé ñîñåä åñòü)
   Ôîðìàò ôóíêöèè
   (Node e.Node)(e.Path)(e.Tree)=>[nodeData][path][tree]
*/
$ENTRY ChooseUndrivenNode {
/* 1. Íàøëàñü âåðøèíà, íà êîòîðîé íå çàïóñêàëàñü ïðîãîíêà è ïðîâåðêà íà ïîâòîðíîñòü ñîñòîÿíèÿ - âîçâðàùàåì åå. */
    t.Node t.Path t.Tree
    , <CheckAlter <GetNodeStatus t.Node> EITHER Undriven Ready> : True 
        = t.Node t.Path t.Tree;
/* 2. Àëãîðèòì äîøžë äî êîðíÿ äåðåâà è ïîìåòèë åãî êàê Finished. Âîçâðàùàåì êîðåíü. */
    t.Node t.Path t.Tree
    , <IsRoot t.Node> : True
    , <GetNodeStatus t.Node> : Finished
        = t.Node t.Path t.Tree;
/* 3. Åñëè âåðøèíà èìååò ñòàòóñ Finished, è ýòî íå êîðåíü, ïðîäîëæàåì ïîèñê îò åå ðîäèòåëÿ. */
    t.Node t.Path t.Tree
    , <CheckAlter <GetNodeStatus t.Node> EITHER Finished (Looped)> : True
    , <ShortenPath t.Path> : t.NewPath
        = <ChooseUndrivenNode <FindNode t.NewPath t.Tree>t.NewPath t.Tree>;
/*
   4. Åñëè âåðøèíà èìååò ñòàòóñ Driven, âûáèðàåì åå äî÷êó ñî ñòàòóñîì Driven, Undriven èëè Ready è ïðîäîëæàåì ïîèñê îò íåå
   åñëè æå òàêèõ äî÷åê íåò, òî ýòà âåðøèíà ïîëó÷àåò ñòàòóñ Finished. 
*/
    t.Node t.Path t.Tree
    , <GetNodeStatus t.Node> : Driven
    , <GetNodeChildren t.Node> : e.Children
        = <ChooseUndrivenNode <ChooseSuccessorNode t.Node (e.Children)t.Path t.Tree>>;
}

/*
    Èçâåñòíî èìÿ âåðøèíû-ïðåäêà è ïóòü îò êîðíÿ äî åå ïîòîìêà. Ïîñòðîèòü ïóòü äî âåðøèíû ïðåäêà.
   ([path])t.NodeName => ([path])
*/
FindAncestorPath {
    (e.PathBefore t.NodeName e.PathAfter)t.NodeName = (e.PathBefore);
}

FindNodePath {
    (e.PathBefore t.NodeName e.PathAfter)t.NodeName = (e.PathBefore t.NodeName);
}

ProlongPath {
    (e.PathBefore) t.NodeName = (e.PathBefore t.NodeName);
}

ShortenPath {
    (e.PathBefore t.NodeName) = (e.PathBefore);
}

/* Äëÿ âûõîäà ïî íåâîçìîæíîìó îòîæäåñòâëåíèþ. */
Recogn_Impossible {
    aaa = ;
}

/* Äëÿ òðàññèðîâùèêà. */
PrintIfTracing {
*   e.1 = e.1;
    e.1 = e.1 <Putout 1 <FormatTreeToPrint e.1>>;
}

PrintTraced {
*   e.1 = e.1;
    e.1 = <Putout 4 <PopAllSubtrees e.1>>;
}

CutLetData {
    /* EMPTY */ = /* EMPTY */;
    (t.NodeName t.Assignment) e.Rest 
        = t.Assignment <CutLetData e.Rest>;
}

FindGenerNegative {
    (e.Parameters)((t.NodeNum (assign t.newpar((par e.oldpar))))e.OtherAssignments) e.Neg
        = <FindGenerNegative (e.Parameters)(e.OtherAssignments)
            <SubstituteInNegative ((assign (par e.oldpar)(t.newpar)))e.Neg>>;
    (e.Parameters)((t.NodeNum (assign e.OtherExpr))e.OtherAssignments) e.Equations
        = <FindGenerNegative (e.Parameters)(e.OtherAssignments)e.Equations>;
    (e.Parameters)()(OR (s.Log)e.Clashes)e.OtherOR
    , <CheckParSet(e.Parameters)(e.Clashes)> : 
        {'T'
            = (OR (s.Log)e.Clashes)<FindGenerNegative (e.Parameters)()e.OtherOR>;
        'F'
            = <FindGenerNegative (e.Parameters)()e.OtherOR>;
        };
    (e.Parameters)() = ;
}

FindGenerEqs {
    (e.Parameters)((t.NodeNum (assign t.newpar((par e.oldpar))))e.OtherAssignments) e.Equations
        = <FindGenerEqs (e.Parameters)(e.OtherAssignments) <Substitute ((assign (par e.oldpar)(t.newpar)))e.Equations>>;
    (e.Parameters)((t.NodeNum (assign e.OtherExpr))e.OtherAssignments) e.Equations
        = <FindGenerEqs (e.Parameters)(e.OtherAssignments)e.Equations>;
    (e.Parameters)()(AreEqual (s.Log)(e.LHS)(e.RHS))e.OtherEqs
    , <CheckParSet(e.Parameters) e.LHS e.RHS>: 
        {'T'
            = (AreEqual ('F')(e.LHS)(e.RHS))<FindGenerEqs (e.Parameters)()e.OtherEqs>;
        'F'
            = <FindGenerEqs (e.Parameters)(/* EMPTY */)e.OtherEqs>;
        };
    (e.Parameters)(/* EMPTY */) = /* EMPTY */;
}

CheckParSet {
    (e.Parameters) = 'T';
    (e.Parameters) ('*' e.1) e.2 = <LogAnd <CheckParSet (e.Parameters)e.1><CheckParSet (e.Parameters)e.2>>;
    (e.Parameters) (call t.fname (args (arg e.1))) e.2 = <LogAnd <CheckParSet (e.Parameters)e.1><CheckParSet (e.Parameters)e.2>>;
    (e.Parameters) (par e.par) e.2
    , <InSet (par e.par)e.Parameters> :
        {'T'
            = <CheckParSet (e.Parameters)e.2>;
        'F' = 'F';
        };
    (e.Parameters) ((e.1) to (e.2)) e.Other = <CheckParSet (e.Parameters) e.1 e.Other>;    
    (e.Parameters) t.1 e.1 = <CheckParSet (e.Parameters)e.1>;
}

InSet {
    t.1 e.1 t.1 e.2 = 'T';
    t.1 e.Other = 'F';
}

FindNEqsIntersection {
    (e.1 t.1 e.2) e.11 t.1 e.12 = <FindNEqsIntersection (e.1 e.2) e.11 t.1 e.12>;
    (t.1 e.1) e.2 = <PreserveNeqIfImplied t.1 (e.2)><FindNEqsIntersection (e.1)e.2>;
    () e.2 = /* EMPTY */;
}

PreserveNeqIfImplied {
    (OR ('T')((e.RHS) to (e.LHS))) e.Neqs
    , <ProcessLinearInequality ((e.RHS) to (e.LHS))> : (OR t.SingleIneq)
        = <PreserveNeqIfImplied (OR ('T') t.SingleIneq)e.Neqs>;
    t.1 e.N1 t.1 e.N2 = t.1;
    e.Z = /* EMPTY */;
}

GetPreservedEqs {
    (e.OldEqs)(e.SubEqs)(e.NewEqs)
     = <FindEqsIntersection 
        (e.OldEqs)(e.SubEqs) e.NewEqs 
        >;
}