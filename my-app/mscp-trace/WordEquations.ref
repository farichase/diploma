/*
    Главный модуль обработки уравнений.
   Здесь проводится расщепление уравнений на простейшие и вызов специальных алгоритмов для работы с уравнениями ограниченных классов.
   
   [PRTCEquation] ::= (AreEqual (s.Log)(e.PRTCExpr)(e.PRTCExpr))
   [WordEquation] ::= (AreEqual (s.Log)([MultiSet])(e.WevalExpr)([MultiSet])(e.WevalExpr))
   
   PRTCExpr содержит параметры, вызовы функций, переменные образца.
   WevalExpr содержит только переменные weval.
   
   Экспортируемые функции:
   ParametrizeExpression --- функции превращения уравнения из PRTCEquation в WordEquation.
   
   IterateProcessQWEs --- функция вызова обработки квадратичных уравнений.
   ([WordEquation]^*)^* => ({[WordEquation]^*|Zero})^*
   
   IterateWESimpleTransforms --- простейшая обработка уравнений (расщеплением).
   ([WordEquation]^*)^* => ({[WordEquation]^*|Zero})^*
*/

/* Тестовые */
$EXTERN RenewAllIndices,SubdirSign,Collapse;

/* из модуля basics.ref */
$EXTERN TermContradiction, MaxElementPowerMS, IfIncluded,Substitute,LessGenericPattern,IsTerm,MSCPError,Map,IterateSubstitute,FindTerm;
$EXTERN SubSetRel, IfASubMultiSet, CompareMultiSets, SubtractSetFromSet, FindMSIntersection, SubtractMS,SubtractEl,InsertInMultiSet,MergeSets,SymSubstMS;
$EXTERN LogAnd, LogAndMerge, LogOrMerge, LogOr, RenewIndices, FreshIndex, CurrentIndex,MyInc, MyOne, MyZero, MyMax, MyAdd, MySub, MyIfNotLess, MytoBool, MyMin, MyNewLevel;
/* из модуля Generalize.ref */
$EXTERN HomeomorphicEmb,MGUAssoc,IfEquivalentConf;
/* из модуля Drive.ref */
$EXTERN SolveEquations,ShuffleMode,ExtractNegativeInfo,TrivialPRTC,ClashLeft,Drive;
/* из модуля DiofEqs.ref */
$EXTERN SolveLinearDE,NormalizeNumericEquation,GenerateLengthRestriction;
/* из модуля WordEqsCases.ref */
$EXTERN DecideQWESolvability;
/* из модуля accessMSCP.ref */
$EXTERN SubstituteInClashes, SubstituteInNumeric, AddEBVariants, ReplaceEBNumericEqs, ReplaceEBNewEqs, ReplaceEBGrammars, GetEBNewEqs, GetEBNumericEqs,
DeleteEBEquation, SubstituteEBAsgs, NormalizeEB, IsContradictory, AddEBNewEqs, MakeEBContr,GenerateNewEB, GetFirstVariants,
ReplaceEBGenEqs, GetEBGenEqs, AddEBGenEqs, GetEBState, DeleteDoubleEqs, AddEBNumEqs, PutEBState, AddNewLines;
/* из модуля accessMSCP.ref */
$EXTERN GenerateFreshPRTC,ReplacePRTCNewEqs,AddPRTCGenericEqs,AddPRTCNegativeInfo,GetPRTCNewEqs, GetPRTCRestrs,
    GetPRTCCallRestrs, GetPRTCAllEqs;
/* из модуля AnalyzeFunDef.ref */
$EXTERN GetClashesPatternType;

$EXTERN GenerateNewNode, UnfoldMain, RestartIndices, AssignTimeStamps, YieldDecomposition, FormatStack;
/*
*********************************************************************************************************************
   
   Функции перевода уравнения в терминах конфигурации в уравнение в словах.
   
*********************************************************************************************************************
*/


/*
    Параметризация выражения переменными рода weval вместо данных языка.
   [Expression] может содержать вызовы, параметры, переменные образца.
   [ParamExpression] ничего из этого не содержит.
   (([ParAssignments])([VarAssignments])([CallAssignments]))([ParamExpression])[Expression] => 
   (([ParAssignments])([VarAssignments])([CallAssignments]))([ParamExpression])
*/

 $ENTRY Go2 { = <ScreenNegatives Init
    <NormalizeInequalityBlock ( )
     (OR ('D')(((par e 410 )(par e 620 )'[Hm')to ((var e Neg12 )'[Ht'(var e Neg13 ))))
    >>;}

 $ENTRY Go1 {
        =
        <Open 'w' 1 'mscplog'<SubdirSign>'trace_scp'>
        <Open 'w' 2 'mscplog'<SubdirSign>'generalizations'>
        <Open 'a' 3 'mscptest'<SubdirSign>'terms.txt'>
        <Collapse <TimeElapsed 0>>
        <RenewAllIndices>
        <RenewIndices 'vare_ind'>
                    <RenewIndices 'vars_ind'>
                    <RenewIndices 'vart_ind'>
        <Prout <Go2>>
        <Close 1><Close 2><Close 3>;
}


$ENTRY ParametrizeExpression {
	s.Mode (e.ParameterList)(e.Parametrized)
		 = (e.ParameterList)(e.Parametrized);
	s.Mode (e.OldParameterList)(e.Parametrized)s.x e.NP
		 = <ParametrizeExpression s.Mode (e.OldParameterList)(e.Parametrized s.x) e.NP>;
/* 2. Сначала параметризуем выражение в скобках, затем - за ними, используя обновленный список строковых переменных. */
        s.Mode (e.OldParameterList)(e.Parametrized)('*'e.NP1) e.NP2,
            <ParametrizeExpression s.Mode (e.OldParameterList)()e.NP1> :(e.NewParameterList)(e.InBrackets)
                = <ParametrizeExpression s.Mode
                    (e.NewParameterList)
                    (e.Parametrized ('*'e.InBrackets))
                    e.NP2
                >;
	s.Mode (e.OldParameterList)(e.Parametrized)(weval e.wvdata) e.NP
		 = <ParametrizeExpression s.Mode
			(e.OldParameterList)(e.Parametrized (weval e.wvdata)) e.NP>;		
	s.Mode (e.OldParList)(e.Parametrized)t.ToParameter e.NP,
        e.OldParList : e.1 (e.OldParList1 (assign t.ToParameter (t.weval)) e.OldParList2) e.2 
		 = <ParametrizeExpression s.Mode
                        (e.OldParList)(e.Parametrized t.weval) e.NP
		>;		
	s.Mode (e.OldParList)(e.Parametrized)(t.sort s.type t.name) e.NP
	, <IndivIndex s.Mode <FreshIndex <Explode s.Mode><Explode s.type>'_ind'>> : t.index
	, (assign (t.sort s.type t.name)((s.Mode s.type t.index))) : t.newasg
	, e.OldParList : (e.ParAsgs)(e.VarAsgs)(e.CallAsgs)
        , t.sort :
            {   par = <ParametrizeExpression s.Mode
                        ((e.ParAsgs t.newasg)(e.VarAsgs)(e.CallAsgs))
                        (e.Parametrized (s.Mode s.type t.index)) 
                        e.NP
                    >;
                var = <ParametrizeExpression s.Mode
                        ((e.ParAsgs)(e.VarAsgs t.newasg)(e.CallAsgs))
                        (e.Parametrized (s.Mode s.type t.index)) 
                        e.NP
                    >;
            };		
	s.Mode (e.OldParList)(e.Parametrized)(call e.call) e.NP,
        <IndivIndex s.Mode <FreshIndex <Explode s.Mode>'e_ind'>> : t.index,
        (assign (call e.call)((s.Mode e t.index))) : t.newasg,
        e.OldParList : (e.ParAsgs)(e.VarAsgs)(e.CallAsgs)        
            = <ParametrizeExpression s.Mode
                        ((e.ParAsgs)(e.VarAsgs)(e.CallAsgs t.newasg))
                        (e.Parametrized (s.Mode e t.index)) 
                        e.NP
                    >;
}

IndivIndex {
    var t.index = <Implode 'Neg'<Symb t.index>>;
    weval t.index = t.index;
}

/*******************************************************************************************
   ФУНКЦИИ УПРАВЛЕНИЯ РАЗРЕШЕНИЕМ НЕРАВЕНСТВ В СЛОВАХ
   1. Неравенства приводим в нормальную форму.
   2. Проверяем результат.
********************************************************************************************/

$ENTRY NormalizeInequalityBlock {
    (e.Restrictions) e.ClashesToCheck
    , <CurrentIndex 'DriveType'> : 'N'
        = /* EMPTY */;
    (e.Restrictions) e.Inequalities
        = <ScreenNegatives Init <NormalizeInequalityBlock Started (e.Restrictions) e.Inequalities>>;
    Started (e.Restrictions)(OR (s.PatternType) e.Clashes) e.Inequalities
    , <SubstituteInClashes 0 (e.Restrictions) e.Clashes (Delayed)> : e.NewClashes (Delayed)
    , <GenerateFreshPRTC e.NewClashes> : t.NegativePRTC
    , <AddPRTCNegativeInfo t.NegativePRTC e.Inequalities> : t.PRTCtoProcess
    , <Br 'PatternType='s.PatternType> : 
    , <Br 'DriveType=N'> : 
    , <Putout 1 'Normalizing negative clash No. '<FreshIndex 'prtc_ind'>><Putout 1 e.Clashes> : 
    , <Drive s.PatternType ( ) <ClashLeft s.PatternType 0 t.PRTCtoProcess>>
        : { 
            /* EMPTY */
            , <Dg 'PatternType'> : e.P
            , <Dg 'DriveType'> : e.Q 
                = <NormalizeInequalityBlock Started (e.Restrictions)e.Inequalities>;
            e.PRTCs
            , <TrivialPRTC e.PRTCs> : 'T'
            , <Dg 'PatternType'> : e.P
            , <Dg 'DriveType'> : e.Q 
                = False;
            e.PRTCsWithCalls
            , e.PRTCsWithCalls : e.1 t.PushPRTC e.2
            , <GetPRTCCallRestrs t.PushPRTC> : t.SomeCall e.OtherCalls
            , <Dg 'PatternType'> : e.P
            , <Dg 'DriveType'> : e.Q 
                = <NormalizeInequalityBlock Started (e.Restrictions)e.Inequalities>;
            e.PRTCsWithRestrictions
            , <Dg 'PatternType'> : e.P
            , <Dg 'DriveType'> : e.Q 
                = <ExtractNormalNegative (<GetIneqPars ( )e.NewClashes>) e.PRTCsWithRestrictions>
                <NormalizeInequalityBlock Started (e.Restrictions)e.Inequalities>;
        };
    Started (e.Restrictions) /* NO MORE NEGATIVE BLOCKS */ = /* EMPTY */;
}

DeleteExcessiveSubs {
    (e.1 t.par e.2)(assign t.par e.Data) e.Other
        = (assign t.par e.Data) <DeleteExcessiveSubs (e.1 t.par e.2)e.Other>;
    (e.TruePars)t.Excessive e.Other
        = <DeleteExcessiveSubs (e.TruePars)e.Other>;
    (e.TruePars) = ;
}

ExtractNormalNegative {
    (e.Pars) t.PRTC e.Other
    , <GetPRTCRestrs t.PRTC> : e.R
    , <GetPRTCAllEqs t.PRTC> : e.Q
    , <ExtractNegativeInfo (((e.Q)(<DeleteExcessiveSubs (e.Pars)<IterateSubstitute (e.R)e.R>>)( )))> : e.NewNegative
        = <Putout 1 'New negative: 'e.NewNegative> e.NewNegative <ExtractNormalNegative (e.Pars) e.Other>;
    (e.Pars) /* EMPTY */ = /* EMPTY */;
}
$ENTRY ImplyNEqsNew {
    (e.Base)(e.ToImply)
    , <ScreenNegatives Init e.Base> : e.BestBase
        = <ImplyNEqsNew Started 'T' ()(e.BestBase)(e.ToImply)>;
    Started s.Log (e.NEqs)(e.Base)( ) = s.Log e.NEqs;
    Started s.Log (e.NEqs)(e.Base)((t.Proc t.Old) e.Other)
    , <ScreenNegatives Init <NormalizeInequalityBlock ()t.Proc>> : e.NewIneqs
    , <FullScreen (e.NewIneqs) e.Base> : 'T'
        = <ImplyNEqsNew Started s.Log (e.NEqs t.Old)(e.Base)(e.Other)>;
    Started s.Log (e.NEqs)(e.Base)(t.1 e.Other)
        = <ImplyNEqsNew Started 'F' (e.NEqs)(e.Base)(e.Other)>;
}

FullScreen {
	(False) e.Z = 'T';
    (t.1 e.x) e.Z
    , <ScreenNegatives Base (e.Z) t.1> : 
        {e.Z 
            = <FullScreen (e.x)e.Z>;
        e.Other
            = 'F';
        };
    () e.Z = 'T';
}

/* Подразумевается, что все отрицательные условия уже в нормальной форме! */
$ENTRY ScreenNegatives {
    Init e.1 False e.2 = False; 
    Init e.1 (OR (s.Log)((t.par) to ((var e e.Data)))) e.2
        = <Putout 1 'Normalized negatives are false!'>;
    Init e.1 (OR (s.Log)(((par t.type e.data)) to ((var t.type e.data2)))) e.2
    , <FindTerm (var t.type e.data2) e.1 e.2> : 'F'
        = False;
    Init e.1 (OR (s.Log)(((par e e.data)) to ((var t e.data2)(var e e.data3)))) e.2
    , <FindTerm (var t e.data2) e.1 e.2> : 'F'
    , e.1 e.2 : e.01 (OR (s.Log)(((par e e.data)) to ( ))) e.02
        = False;
    Init e.1 (OR (s.Log)(((par e e.data)) to ((var e e.data3)(var t e.data2)))) e.2
    , <FindTerm (var t e.data2) e.1 e.2> : 'F'
    , e.1 e.2 : e.01 (OR (s.Log)(((par e e.data)) to ( ))) e.02
        = False;
    Init e.1 (OR (s.Log)e.01((t.par) to ((var e e.Data)))e.02) e.2
        = <ScreenNegatives Init e.1 (OR (s.Log) e.01 e.02) e.2 >;
    Init e.N1 t.Rep e.N2 t.Rep e.N3
        = <ScreenNegatives Init e.N1 e.N2 t.Rep e.N3>; 
    Init e.N1 (OR (s.Log) e.1 t.Clash e.2) e.N2
    , e.N1 e.N2 : e.01 (OR (s.Log2) t.Clash) e.02
        = <ScreenNegatives Init e.N1 e.N2>;
    Init = ;
    Init t.1 = t.1;
    Init t.1 t.2 e.Z = <Putout 1 'ToScreen inequalities:'><Putout 1 <AddNewLines t.1 t.2 e.Z>> 
        <ScreenNegatives Base (/* EMPTY */) t.1 t.2 e.Z>;
    Base (e.Checked)(OR (s.Log) e.Clashes) e.Other
    , <EmbeddingPatterns (e.Clashes) e.Checked e.Other>
    : { True
            = <ScreenNegatives Base (e.Checked) e.Other>;
        False
            = <ScreenNegatives Base (e.Checked (OR (s.Log) e.Clashes)) e.Other>;
   }; 
   Base (e.Checked) = <Putout 1 'Screened inequalities:'><Putout 1 <AddNewLines e.Checked>> e.Checked;
}

GetIneqPars {
    (e.set)((e.c1 ('*' e.cb) e.c2) to (e.Pattern)) e.Other
        = <GetIneqPars (e.set)((e.c1 e.cb e.c2) to (e.Pattern))e.Other>;
    (e.set)((e.c1 (par e.data) e.c2) to (e.Pattern)) e.Other
    , e.set
    : {
        e.1 (par e.data) e.2
            = <GetIneqPars (e.set)((e.c2) to (e.Pattern))e.Other>;
        e.Z
            = <GetIneqPars (e.set (par e.data))((e.c2) to (e.Pattern)) e.Other>;
    };
    (e.set)t.NoPars e.Other = <GetIneqPars (e.set) e.Other>;
    (e.set) = e.set;
}

EmbeddingPatterns {
    (e.Clashes) (OR (s.Log) e.ClashesToCheck) e.Other
    , <SubSetRel (<GetIneqPars ()e.Clashes>)(<GetIneqPars ()e.ClashesToCheck>)>
    : {
        'T'
        , <AllAreInstances (e.ClashesToCheck)(e.Clashes)>
        : {
            'T'
                = True;
            'F'
                = <EmbeddingPatterns (e.Clashes) e.Other>;
        };
        'F' = <EmbeddingPatterns (e.Clashes) e.Other>;
    };
    (e.Clashes) /*NO MORE */ = False;
}

AllAreInstances {
    (((t.par) to (e.Pattern)) e.OtherToCheck) (e.1 ((t.par) to (e.Pattern2)) e.2)
/*    , <HomeomorphicEmb (e.Pattern)e.Pattern2> : 'T'
    , <MGUAssoc ((var e Init))((assign (var e Init)(ToUnify (e.Pattern)(e.Pattern2))))()> : (e.Gener)(e.MGUs)
    , <IfEquivalentConf ()(e.Gener)(e.Pattern)> : (e.Subs)*/
    , <IfInstance ()(e.Pattern2)e.Pattern> : (e.Subs)
        = <AllAreInstances (e.OtherToCheck)(e.1 ((t.par) to (e.Pattern2)) e.2)>;
    (t.Clash e.OtherToCheck)(e.NoImbedding) = 'F';
    (/* EMPTY */)(e.All) = 'T';
}

IfInstance {
    (e.Subs)( ) = (e.Subs);
    (e.Subs)(t.x e.1)t.x e.2 = <IfInstance (e.Subs)(e.1)e.2>;
    (e.Subs)(('*'e.1)e.2)('*'e.3)e.4
    , <IfInstance (e.Subs)(e.2)e.4> : (e.Subs2)
        = <IfInstance (e.Subs2)(e.1)e.2>;
    (e.Subs)(s.x e.1)(t.sort t t.name) e.2
        = <IfInstance (e.Subs (assign (t.sort t t.name)(s.x)))(e.1)e.2>;
    (e.Subs)((t.sort t t.name) e.1)(t.sort t t.name2) e.2
        = <IfInstance (e.Subs (assign (t.sort t t.name2)((t.sort t t.name))))(e.1)e.2>;
    (e.Subs)((t.sort s t.name) e.1)(t.sort s t.name2) e.2
        = <IfInstance (e.Subs (assign (t.sort s t.name2)((t.sort s t.name))))(e.1)e.2>;
    (e.Subs)(s.x e.1)(t.sort s t.name) e.2
        = <IfInstance (e.Subs (assign (t.sort s t.name)(s.x)))(e.1)e.2>;
    (e.Subs)((t.sort e t.name) e.1)(t.sort e t.name2) e.2
        = <LogOrX <IfInstance (e.Subs)(e.1)e.2><IfInstance (e.Subs)(e.1)(t.sort e t.name2)e.2>>;
    (e.Subs)(t.1 e.1)(t.sort e t.name) e.2
        = <LogOrX <IfInstance (e.Subs)(e.1)e.2> 
            <LogOrX <IfInstance (e.Subs)(t.1 e.1)e.2><IfInstance (e.Subs)(e.1)(t.sort e t.name)e.2>>>;
    (e.Subs)( )(t.sort e t.name) = (e.Subs);
    (e.Subs)(e.1)e.2 = 'F';
}

LogOrX {
    e.1 (e.2) e.3 = (e.2);
    e.Z = 'F';
}

CorrectSubs {
    e.1 t.1 e.2 t.1 e.3 = <CorrectSubs e.1 t.1 e.2 e.3>;
    e.1 (assign t.par (e.Val1)) e.2 (assign t.par (e.Val2)) e.3 = 'F';
    e.Z = 'T';
}

/*******************************************************************************************
   ФУНКЦИИ УПРАВЛЕНИЯ РАЗРЕШЕНИЕМ УРАВНЕНИЙ В СЛОВАХ
   1. Приводим уравнения в словах к общему виду, считаем максимальную кратность переменных в каждом уравнении
   2. 
********************************************************************************************/

/*
    Функции, подготовительные для суперкомпиляции как алгоритма преобразования уравнений.
   Сейчас в MSCP не используются. 
*/

ExtractPseudoFunction {
    ((par e t.name) e.LHS)(e.RHS)(e.FPart1)(e.FPart2)(e.FPart3)(e.FPart4) =
        (e.FPart1 (par e t.name))<ExtractPseudoFunction ((par e t.name) e.LHS)(e.RHS)(e.FPart2)(e.FPart3)(e.FPart4)>;
    (e.LHS (par e t.name))(e.RHS)(e.FPart2)(e.FPart3)(e.FPart4) =
        ((par e t.name) e.FPart2)<ExtractPseudoFunction (e.RHS)(e.FPart3)(e.FPart4)>;
    ((par e t.name) e.RHS)(e.FPart3)(e.FPart4) =
        (e.FPart3 (par e t.name))<ExtractPseudoFunction ((weval e t.name) e.RHS)(e.FPart4)>;
    (e.RHS (weval e t.name))(e.FPart4) =
        ((weval e t.name) e.FPart4);
    (t.1 e.LHS)(e.RHS)(e.FPart1)(e.FPart2)(e.FPart3)(e.FPart4) =
        <ExtractPseudoFunction (e.LHS)(e.RHS)(e.FPart1 t.1)(e.FPart2)(e.FPart3)(e.FPart4)>;
    (t.1 e.RHS)(e.FPart3)(e.FPart4) =
        <ExtractPseudoFunction (e.RHS)(e.FPart3 t.1)(e.FPart4)>;
    (e.LHS t.1)(e.RHS)(e.FPart2)(e.FPart3)(e.FPart4) =
        <ExtractPseudoFunction (e.LHS)(e.RHS)(t.1 e.FPart2)(e.FPart3)(e.FPart4)>;
    (e.RHS t.1)(e.FPart4) =
        <ExtractPseudoFunction (e.RHS)(t.1 e.FPart4)>;
}

GeneratePattern {
    ((e.sort e t.par) e.LHS)(s.Sym e.RHS)
        = ((('*'s.Sym(var e x))('*'(var e y))(var t z)(var t z))(Restart))
        ((('*')('*'(var e y))(var t z)(var t z))(Restart));
    (s.Sym e.LHS)((e.sort e t.par) e.RHS) 
        = ((('*'(var e x))('*'s.Sym(var e y))(var t z)(var t z))(Restart))
        ((('*'(var e x))('*')(var t z)(var t z))(Restart));
    ((e.sort e t.par1) e.LHS)((e.sort e t.par2) e.RHS) 
        = ((('*'(var e x))('*'(var e x))(var t z)(var t z))(Restart))
        ((('*'(var e x))('*'(var e x)(var t w)(var e y))(var t z)(var t z))(Restart))
        ((('*'(var e y)(var t w)(var e x))('*'(var e y))(var t z)(var t z))(Restart));
}

GenerateNewParameters {
    (e.Pars) e.Expr1('*'e.Expr2) e.Expr3 = <GenerateNewParameters (e.Pars)e.Expr1 e.Expr2 e.Expr3>;
    (e.Pars1 (assign (weval e.data) e.asg)e.Pars2) e.Expr1 (weval e.data) e.Expr2 = 
        <GenerateNewParameters (e.Pars1 (assign (weval e.data) e.asg)e.Pars2) e.Expr1 e.Expr2>;
    (e.Pars) e.Expr1 (weval e t.name) e.Expr2 =
        <GenerateNewParameters (e.Pars (assign (weval e t.name)((par e <FreshIndex 'pare_ind'>)))) e.Expr1 e.Expr2>;
    (e.Pars) e.Expr1 (weval t t.name) e.Expr2 =
        <GenerateNewParameters (e.Pars (assign (weval t t.name)((par t <FreshIndex 'part_ind'>)))) e.Expr1 e.Expr2>;
    (e.Pars) e.Expr1 (weval s t.name) e.Expr2 =
        <GenerateNewParameters (e.Pars (assign (weval s t.name)((par s <FreshIndex 'pars_ind'>)))) e.Expr1 e.Expr2>;
    (e.Pars) e.Expr = e.Pars;
}

/*
   $ENTRY SolveWEforEB {
    t.EquationBlock, 
    <GetMarkedEquation ('D') t.EquationBlock> : (AreEqual ('D')(e.MS1)(e.OldLHS)(e.MS2)(e.OldRHS)),
    <GenerateNewParameters ()e.OldLHS e.OldRHS> : e.Subst,
    <Substitute (e.Subst)e.OldLHS> : e.LHS,
    <Substitute (e.Subst)e.OldRHS> : e.RHS,
    (call SAT (args (arg 
        (call 
            <ExtractPseudoFunction 
                (e.LHS)(e.RHS)()()()()
            > 
        (args (arg ('*' e.LHS)('*' e.RHS))))))) : t.EquationCall,
    <Substitute (e.Subst)<ExtractRelevantNumeric t.EquationBlock (e.MS1 e.MS2)>> : e.Numeric,
    <SubstituteInGrammar (e.Subst)<ExtractRelevantGrammars t.EquationBlock (e.MS1 e.MS2)>> : e.Grammar,
    <FormatStack 
        <YieldDecomposition 
            (((assign (var l (0)) 
                (<AssignTimeStamps t.EquationCall>))))
        >
    > : (e.Config)(e.Stack)
    = <RestartIndices 'pare_ind'><RestartIndices 'part_ind'><RestartIndices 'pars_ind'>
    <UnfoldMain (EqualitySolving) 
        <PutEBtoNode 
            <GenerateNewNode (0)>
                    <ReplaceEBGrammars
                    <ReplaceEBNumericEqs <GenerateNewEB> e.Numeric>
                    e.Grammar
                    >
            >
        ((0))
        (Node Undriven (0) ())
    >;
   } 
*/


PutEBtoNode {
    t.EquationBlock t.Node = t.EquationBlock t.Node;        
}

/* конец подготовительных функций */

ExtractInfoQWE {
	t.Numeric (AreEqual (s.Log1)(e.ParMS1)(e.LHS)(e.ParMS2)(e.RHS)),
        <MyIfNotLess 
            <MyInc <MyOne>>
            <MaxElementPowerMS (<SubtractEl (Inf Const)(<MergeSets (e.ParMS1)(e.ParMS2)>)>)>
        > : 
        {'T',
        <DecideQWESolvability t.Numeric(AreEqual (s.Log1)(e.ParMS1)(e.LHS)(e.ParMS2)(e.RHS))> :
            {'T' 
                = 
                (Grammar )
                (Numeric )
                (Common ()(<PlaceInCommEqs (AreEqual ('F')(e.ParMS1)(e.LHS)(e.ParMS2)(e.RHS))(New)(Generic)>)('T'))
                (Variants );
            'F' 
                = <Putout 1 'No solutions of equation'><Putout 1 (AreEqual (e.LHS)(e.RHS))>
                (Grammar )
                (Numeric )
                (Common ()((New)(Generic))('F'))
                (Variants );
            };
        'F' 
            =   
            (Grammar )
            (Numeric )
            (Common ()(<PlaceInCommEqs (AreEqual ('F')(e.ParMS1)(e.LHS)(e.ParMS2)(e.RHS))(New)(Generic)>)('T'))
            (Variants );
        };
}

$ENTRY IterateSWEforEB {
/*
    t.EquationBlock, 
    <GetMarkedEquation ('D') t.EquationBlock> : t.Equation,
        <DeleteEBEquation t.EquationBlock t.Equation> : t.EqBlock1,
        <GetEBNumericForSingleEq t.EqBlock1 t.Equation> : e.Numeric,
        <GetEBGrammarForSingleEq t.EqBlock1 t.Equation> : e.Grammar        =
            <IterateSWEforEB 
                <PostProcessSWE 
                    t.EqBlock1 
                    <>
                    t.Equation
                >>; 
*/
    t.EquationBlock = t.EquationBlock;
} 

Normalize4Split {
    (AreEqual (s.Log)t.MS1(e.LHS)t.MS2 (e.RHS)) = (AreEqual (e.LHS)(e.RHS));
    (AreEqual (s.Log)(e.LHS)(e.RHS)) = (AreEqual (e.LHS)(e.RHS)); 
}

PostProcessSWE {
    t.EquationBlock 'F' t.Equation = <MakeEBContr>;
    t.EquationBlock 'T' (AreEqual (s.Log)e.OtherData)
        = <AddEBNewEqs t.EquationBlock (AreEqual ('F')e.OtherData)>;
}

/* Последовательная обработка текущего блока уравнений без попыток решения их. */
$ENTRY IterateWEforPRTCs {
	t.EquationBlock e.Other, <IsContradictory t.EquationBlock> : 'T',
        e.Other :
        {       = <MakeEBContr>;
            e.NonEmpty  = <IterateWEforPRTCs e.NonEmpty>;
        };
        t.EquationBlock e.Other, <GetEBState t.EquationBlock> : 'T'
            = <IterateWEforPRTCs <DeleteDoubleEqs t.EquationBlock>>;
/* 2. Пока имеются уравнения, не расщепленные - осуществляем расщепление. */
	t.EquationBlock e.Other,
        <GetMarkedEquation ('T') t.EquationBlock> : t.Equation,
        <GetEBNumericEqs t.EquationBlock> : e.Numeric,
        <Br 'EquationType=1'> : e.x  
            = <Putout 1 'Splitting...'><Putout 1 t.Equation><IterateWEforPRTCs
            <NormalizeEB            
                <IntegrateEqSolResults (Grammar )(Numeric ) 
                    <SplitEquation (e.Numeric)
                        <Normalize4Split t.Equation>
                    > 
                    <DeleteEBEquation t.EquationBlock t.Equation>
                > 
                >
                e.Other
            >;
/*
   3. Нерасщепленных уравнений не осталось, но есть не оцененные числовыми равенствами -
   оцениваем их. 
*/

	t.EquationBlock e.Other,
        <GetMarkedEquation ('N') t.EquationBlock> : t.Equation,
        <Br 'EquationType=1'> : e.x        
            = <IterateWEforPRTCs 
                <NormalizeEB
                <IntegrateEqSolResults (Grammar )
                    <NumericEsteem t.Equation> 
                    <DeleteEBEquation t.EquationBlock t.Equation>
                >
                >
                e.Other 
            >;
/* 4. Пока имеются общие уравнения, не расщепленные - осуществляем расщепление. */
	t.EquationBlock e.Other,
        <GetMarkedGenericEquation ('T') t.EquationBlock> : t.Equation,
        <GetEBNumericEqs t.EquationBlock> : e.Numeric,
        <Br 'EquationType=0'> : e.x 
        =
            <Putout 1 'Splitting...'><Putout 1 t.Equation><IterateWEforPRTCs
            <NormalizeEB            
                <IntegrateEqSolResults (Grammar )(Numeric ) 
                    <SplitEquation (e.Numeric)
                        <Normalize4Split t.Equation>
                    > 
                    <DeleteEBEquation t.EquationBlock t.Equation>
                > 
                >
                e.Other
            >;
/*
   5. Нерасщепленных общих уравнений не осталось, но есть не оцененные числовыми равенствами -
   оцениваем их. 
*/

	t.EquationBlock e.Other,
        <GetMarkedGenericEquation ('N') t.EquationBlock> : t.Equation,
        <Br 'EquationType=0'> : e.x
            = <IterateWEforPRTCs 
                <NormalizeEB
                <IntegrateEqSolResults (Grammar )
                    <NumericEsteem t.Equation> 
                    <DeleteEBEquation t.EquationBlock t.Equation>
                >
                >
                e.Other 
            >;
/* 6. Остались не проверенные на разрешимость уравнения - проверяем их. */
	t.EquationBlock e.Other,
        <CurrentIndex 'SolveEqMode'> : '0',
        <GetMarkedEquation ('D') t.EquationBlock> : t.Equation,
        <Br 'EquationType=1'> : e.x 
            = <IterateWEforPRTCs 
                <NormalizeEB
                <IntegrateEqSolResults <ExtractInfoQWE (<GetEBNumericEqs t.EquationBlock>) t.Equation> 
                    <DeleteEBEquation t.EquationBlock t.Equation>
                >
                >
                e.Other 
            >;
/* 7. Остались не проверенные на разрешимость общие уравнения - проверяем их. */
    t.EquationBlock e.Other,
    <CurrentIndex 'SolveEqMode'> : '0',
    <GetMarkedGenericEquation ('D') t.EquationBlock> : t.Equation,
    <Br 'EquationType=0'> : e.x 
        =
        <IterateWEforPRTCs 
                <NormalizeEB
                <IntegrateEqSolResults <ExtractInfoQWE (<GetEBNumericEqs t.EquationBlock>) t.Equation> 
                    <DeleteEBEquation t.EquationBlock t.Equation>
                >
                >
                e.Other 
        >;
/*
   8. Все общие уравнения для данной конфигурации разобраны, но остались варианты - расщепляем блок
   уравнений по вариантам. 
*/

    t.EquationBlock e.Other,
    <GetFirstVariants t.EquationBlock> : t.EqBlock1 (e.Cases)e.Rest,
    e.Cases : t.1 e.1
        =
        <IterateWEforPRTCs <GenerateEBlocks t.EqBlock1 e.Cases>>;
            
    t.EquationBlock = t.EquationBlock;
    
    t.EquationBlock e.Other = t.EquationBlock <IterateWEforPRTCs e.Other>;
}

GenerateEBlocks {
    t.EquationBlock = ;
    t.EquationBlock (Case (e.Asgs)(e.Eqs)(s.Log)) e.Other 
        =
        <NormalizeEB <SubstituteEBAsgs <AddEBNewEqs t.EquationBlock e.Eqs>(e.Asgs)>>
        <GenerateEBlocks t.EquationBlock e.Other>;
}

GetMarkedGenericEquation {
    (s.Log) t.EquationBlock, 
    <GetEBGenEqs t.EquationBlock> : e.1 (AreEqual (s.Log) e.Data) e.2
        = (AreEqual (s.Log)e.Data);
    (s.Log) t.EquationBlock = ;
}

GetMarkedEquation {
    (s.Log) t.EquationBlock, 
    <GetEBNewEqs t.EquationBlock> : e.1 (AreEqual (s.Log) e.Data) e.2
        = (AreEqual (s.Log)e.Data);
    (s.Log) t.EquationBlock = ;
}

$ENTRY IntegrateEqSolResults {
    (Grammar e.1)(Numeric e.2)
         (Common (e.Assignments)(e.Equations)('F'))(Variants e.Vars) t.EquationBlock 
             = <MakeEBContr t.EquationBlock>;
    (Grammar )(Numeric )(Common ()((New)(Generic))(s.Log))(Variants ) t.EquationBlock = t.EquationBlock;
    (Grammar e.Grammar)(Numeric e.Numeric)(Common ()((New)(Generic))('T'))(Variants ) t.EquationBlock,
        <Putout 1 'New numeric:'>
        <Putout 1 e.Numeric>
        <SubstituteInNumeric 
                (<GeneratePseudoSubs e.Numeric>)
                <AddEBNumEqs t.EquationBlock e.Numeric>> : t.ModEqBlock,
        <MarkEquationsChanges 
            ()
            (e.Numeric)
            <GetEBNewEqs t.ModEqBlock>
            <GetEBGenEqs t.ModEqBlock>
        > : e.AsgsNew,
        <Putout 1 'New assignments are generated:'><Putout 1 e.AsgsNew>
        <SubstituteEBAsgs t.ModEqBlock (e.AsgsNew)> :
        {(e.EqBlock1('F')) = <Putout 1 'Assignments led to contradiction.'>
                        <MakeEBContr t.EquationBlock>;
        t.NewEqBlock = t.NewEqBlock;
            
        };
    (Grammar e.Grammar)(Numeric e.Numeric)
         (Common (e.Assignments)((New e.NewEqs)(Generic e.GenEqs))(s.Log))(Variants ) t.EquationBlock,
        <SubstituteEBAsgs <ReplaceEBNumericEqs <GenerateNewEB> e.Numeric> (e.Assignments)> :
        { (e.EqBlock ('F')) = <MakeEBContr t.EquationBlock>;
           t.NumEqBlock = 
               <Putout 1 'New common data:'>
               <Putout 1 e.Assignments e.NewEqs e.GenEqs> 
               <IntegrateEqSolResults
                   (Grammar e.Grammar)
                   (Numeric <GetEBNumericEqs t.NumEqBlock>)
                   (Common ()((New)(Generic))('T'))(Variants )
                   <SubstituteEBAsgs 
                   <AddEBGenEqs 
                       <AddEBNewEqs 
                           <PutEBState t.EquationBlock 'T'> 
                            e.NewEqs>
                       e.GenEqs
                    > (e.Assignments)>
                >;
        };
    (Grammar e.Grammar)(Numeric e.Numeric)(Common e.Common)(Variants e.Vars) t.EquationBlock,
    e.Vars : t.1 e.1 
         = 
        <Putout 1 'New variants:'><Putout 1 e.Vars><IntegrateEqSolResults 
            (Grammar e.Grammar)
            (Numeric e.Numeric)
            (Common e.Common)
            (Variants )
            <AddEBVariants 
                t.EquationBlock e.Vars
            >
        >;
}

GeneratePseudoSubs {
    = ;
    (AreEqual ((1 t.Element))(e.MS)) e.Other = (assign t.Element (e.MS)(Pseudo))<GeneratePseudoSubs e.Other>;
    (AreEqual e.Z) e.Other = <GeneratePseudoSubs e.Other>;
}

MarkEquationsChanges {
    (e.CandidateEqs)(e.Num1 (AreEqual ((1 t.var1))(e.MSEq)) e.Num2)
        e.Eqs1 (AreEqual e.EqData1 (t.var1 e.SomeExpr) e.EqData2) e.Eqs2
            = <MarkEquationsChanges 
                (e.CandidateEqs (AreEqual e.EqData1 (t.var1 e.SomeExpr) e.EqData2))
                (e.Num1 (AreEqual ((1 t.var1))(e.MSEq)) e.Num2)
                e.Eqs1 e.Eqs2>;
        
    (e.CandidateEqs)(e.Num1 (AreEqual ((1 t.var1))(e.MSEq)) e.Num2)
        e.Eqs1 (AreEqual e.EqData1 (e.SomeExpr t.var1) e.EqData2) e.Eqs2
            = <MarkEquationsChanges 
                (e.CandidateEqs (AreEqual e.EqData1 (e.SomeExpr t.var1) e.EqData2))
                (e.Num1 (AreEqual ((1 t.var1))(e.MSEq)) e.Num2)
                e.Eqs1 e.Eqs2>;

     (e.CandidateEqs)(e.Numeric)e.OtherEqs 
         = <FindSplittableEqs 
             (e.Numeric) 
             <AssignAllEndVars e.CandidateEqs>
            > e.OtherEqs;
}

AssignAllEndVars {
    = ;
    t.Eq e.Other = <AssignEndVars t.Eq><AssignAllEndVars e.Other>;
}

FindSplittableEqs {
    ()e.EqsRest = ;
    (e.Num) = ;
    (t.Num1 e.Num) e.MarkedEqs,
    <GetProcessableEndMarkEqs ()()()t.Num1 e.MarkedEqs> : (e.Assignments)(e.EqsRest)
        = e.Assignments <FindSplittableEqs (e.Num)e.EqsRest>;
}

GetConstPow {
    e.1 (s.Num Const) e.2 = s.Num;
    e.Z = 0;
}

GetProcessableEndMarkEqs {
    (e.Assignments)(e.Changeable)(e.Unchangeable)t.Num 
        = (e.Assignments)(e.Changeable e.Unchangeable); 
    (e.Assignments)(e.Changeable)(e.Unchangeable)(AreEqual ((1 t.var1)(e.MSEq)))
        (t.Equation (Begins with ((0 Const) t.var1)((s.Num Const) t.var2))(Ends with (e.LHSE)(e.RHSE))) e.RestEqs,
            e.MSEq : e.1 (s.PowVar2 t.var2) e.2,
            <MyIfNotLess <GetConstPow e.MSEq> s.Num> : 'T',
            <ConstructNewAssignment 0 t.var1 ((s.Num Const) t.var2)> : t.newasgnt
                = <GetProcessableEndMarkEqs 
                    (e.Assignments t.newasgnt)
                    (e.Changeable t.Equation)
                    (e.Unchangeable)
                    (AreEqual ((1 t.var1)(e.MSEq)))
                    e.RestEqs
                >;

    (e.Assignments)(e.Changeable)(e.Unchangeable)(AreEqual ((1 t.var1)(e.MSEq)))
        (t.Equation (Begins with (e.LHSB)(e.RHSB)(Ends with ((0 Const) t.var1)((s.Num Const) t.var2)))) e.RestEqs,
            e.MSEq : e.1 (s.PowVar2 t.var2) e.2,
            <MyIfNotLess <GetConstPow e.MSEq> s.Num> : 'T',
            <ConstructNewAssignment 1 t.var1 ((s.Num Const) t.var2)> : t.newasgnt
                = <GetProcessableEndMarkEqs 
                    (e.Assignments t.newasgnt)
                    (e.Changeable t.Equation)
                    (e.Unchangeable)
                    (AreEqual ((1 t.var1)(e.MSEq)))
                    e.RestEqs
                >;
            
    (e.Assignments)(e.Changeable)(e.Unchangeable)(AreEqual ((1 t.var1)(e.MSEq)))
        (t.Equation (Begins with ((s.Num Const) t.var2)((0 Const) t.var1))(Ends with (e.LHSE)(e.RHSE))) e.RestEqs,
            e.MSEq : e.1 (s.PowVar2 t.var2) e.2,
            <MyIfNotLess <GetConstPow e.MSEq> s.Num> : 'T',
            <ConstructNewAssignment 0 t.var1 ((s.Num Const) t.var2)> : t.newasgnt
                = <GetProcessableEndMarkEqs 
                    (e.Assignments t.newasgnt)
                    (e.Changeable t.Equation)
                    (e.Unchangeable)
                    (AreEqual ((1 t.var1)(e.MSEq)))
                    e.RestEqs
                >;

    (e.Assignments)(e.Changeable)(e.Unchangeable)(AreEqual ((1 t.var1)(e.MSEq)))
        (t.Equation (Begins with (e.LHSB)(e.RHSB)(Ends with ((s.Num Const) t.var2)((0 Const) t.var1)))) e.RestEqs,
            e.MSEq : e.1 (s.PowVar2 t.var2) e.2,
            <MyIfNotLess <GetConstPow e.MSEq> s.Num> : 'T',
            <ConstructNewAssignment 0 t.var1 ((s.Num Const) t.var2)> : t.newasgnt
                = <GetProcessableEndMarkEqs 
                    (e.Assignments t.newasgnt)
                    (e.Changeable t.Equation)
                    (e.Unchangeable)
                    (AreEqual ((1 t.var1)(e.MSEq)))
                    e.RestEqs
                >;

    (e.Assignments)(e.Changeable)(e.Unchangeable)t.NumEq
    (t.Equation e.Data) e.RestEqs
        = <GetProcessableEndMarkEqs (e.Assignments)(e.Changeable)(e.Unchangeable t.Equation)t.NumEq e.RestEqs>;
}

ConstructNewAssignment {
    s.Mode (weval e t.name)((0 Const)(weval e t.name2)),
    <FreshIndex 'wevale_ind'> : t.newname 
        = (assign 
            (weval e t.name) 
            ((0 Const)(1 (weval e t.name2))(1 (weval e t.newname)))
            (<ShuffleMode s.Mode (weval e t.name2)(weval e t.newname)>)
            );
    s.Mode (weval e t.name)((s.Num Const)(weval e t.name2)),
    <FreshIndex 'wevale_ind'> : t.newname,
    <GenerateLengthRestriction (<MyZero>)()(weval e t.name)s.Num> : 
        (assign (weval e t.name)t.MS(e.Expr)) 
        = (assign 
            (weval e t.name) 
            ((s.Num Const)(1 (weval e t.name2))(1 (weval e t.newname)))
            (<ShuffleMode <Switch s.Mode>(weval e t.newname)<ShuffleMode <Switch s.Mode> (weval e t.name2) e.Expr>>)
            );
    s.Mode e.OtherData
        = <MSCPError ('Endmarked variables are not of expression type.')(e.OtherData)>;
}

Switch {
0 = 1;
1 = 0;
}

AssignEndVars {
    (AreEqual e.Eq) = ((AreEqual e.Eq)<AssignEndVars Started 0 (<MyZero>)(<MyZero>)(AreEqual e.Eq)>);
    Started 0 (s.NumL)(s.NumR)(AreEqual (s.Log) t.MS1(t.1 e.LHS)t.MS2(t.2 e.RHS)),
    <IsFreeVar t.1> :
    {'T',
    <IsFreeVar t.2> :
        {'T' 
            = (Begins with ((s.NumL Const) t.1) ((s.NumR Const)t.2))
            <AssignEndVars Started 1 (<MyZero>)(<MyZero>)(AreEqual (s.Log) t.MS1(t.1 e.LHS)t.MS2(t.2 e.RHS))>;
        'F' = <AssignEndVars Started 0 (s.NumL)(<MyInc s.NumR>)(AreEqual (s.Log) t.MS1(t.1 e.LHS)t.MS2(e.RHS))>;
        };
     'F',
     <IsFreeVar t.2>:
        {'T' = <AssignEndVars Started 0 (<MyInc s.NumL>)(s.NumR)(AreEqual (s.Log) t.MS1(e.LHS)t.MS2(t.2 e.RHS))>;
        'F' = <AssignEndVars Started 0 (<MyInc s.NumL>)(<MyInc s.NumR>)(AreEqual (s.Log) t.MS1(e.LHS)t.MS2(e.RHS))>;
        };
    };
    Started 1 (s.NumL)(s.NumR)(AreEqual (s.Log) t.MS1(e.LHS t.1)t.MS2(e.RHS t.2)),
    <IsFreeVar t.1> :
    {'T',
    <IsFreeVar t.2> :
        {'T' = (Ends with ((s.NumL Const) t.1) ((s.NumR Const)t.2));
        'F' = <AssignEndVars Started 1 (s.NumL)(<MyInc s.NumR>)(AreEqual (s.Log) t.MS1(e.LHS t.1)t.MS2(e.RHS))>;
        };
     'F',
     <IsFreeVar t.2>:
        {'T' = <AssignEndVars Started 1 (<MyInc s.NumL>)(s.NumR)(AreEqual (s.Log) t.MS1(e.LHS)t.MS2 (e.RHS t.2))>;
        'F' = <AssignEndVars Started 1 (<MyInc s.NumL>)(<MyInc s.NumR>)(AreEqual (s.Log) t.MS1(e.LHS)t.MS2(e.RHS))>;
        };
    };
    Started 0 (s.Num1)(s.Num2) e.Other 
        = (Begins with constants)(Ends with constants);
    Started 1 (s.Num1)(s.Num2) e.Other 
        = (Ends with constants);    
}

IsFreeVar {
    (weval e e.name) = 'T';
    t.other = 'F';
}

PostProcessSingleSplit {
    (Common (e.Asg1)(e.Eqs1)(s.Log1))(Variants (Case (e.Asg2)(e.Eqs2)(s.Log2)))
        = (Common (e.Asg1 e.Asg2)(e.Eqs1 e.Eqs2)(<LogAnd s.Log1 s.Log2>))(Variants );
    e.Z = e.Z;
}

PlaceInCommEqs {
    t.Equation (New e.NewEqs)(Generic e.GenEqs)
    , <CurrentIndex 'SolveEqMode'> :
        { '1' = (New e.NewEqs t.Equation)(Generic e.GenEqs);
         '0'
         , <CurrentIndex 'EquationType'> :
            { '0' = (New e.NewEqs)(Generic e.GenEqs t.Equation);
              '1' = (New e.NewEqs t.Equation)(Generic e.GenEqs);
            };
        };
}

PostProcessSplits {
    (Common e.1)(Variants e.2) = (Common e.1)(Variants e.2);
    
    e.1 (Common ()((New)(Generic))('T'))(Variants ) e.2 = e.1 e.2;
    
    (Common (e.Asg1)((New e.NewEqs1)(Generic e.GenEqs1))(s.Log1))(Variants e.Cases1)
    (Common (e.Asg2)((New e.NewEqs2)(Generic e.GenEqs2))(s.Log2))(Variants e.Cases2) e.Left 
        =
        <PostProcessSplits
            (Common (e.Asg1 e.Asg2)((New e.NewEqs1 e.NewEqs2)(Generic e.GenEqs1 e.GenEqs2))(<LogAnd s.Log1 s.Log2>))
            (Variants <MultiplyCases (e.Cases1) e.Cases2>)
            e.Left
        >;
}

MultiplyCases {
     = ;
    (e.Cases1) = e.Cases1;
    ()e.Cases2 = e.Cases2;
    ((Multiply e.Cases1)) e.Cases2 = (Multiply e.Cases1 (e.Cases2));
    (e.Cases1)(Multiply e.Cases2) = (Multiply (e.Cases1) e.Cases2);
    (e.Cases1)e.Cases2 = (Multiply (e.Cases1)(e.Cases2));
}

/*
    подготовительная функция для разделения уравнения на подуравнения
   Вход:
   (AreEqual ([WevalExpr]) ([WevalExpr]))
   результат:
   (Common (e.Assignments)([e.Equations])(s.Log))(Case (e.Assignments)([e.Equations])(s.Log))^*
   [e.Equations]::=(AreEqual ((s.Log1)(e.MS1)(e.LHS))((s.Log2)(e.MS2)(e.RHS)))^ 
*/

$ENTRY SplitEquation {
/* 1. C двух сторон одно и то же выражение - успешное завершение, уравнение пропадает (тождество). */
    (e.Numeric)(AreEqual t.1 t.1) = (Common ()((New)(Generic))('T'))(Variants ); 
/*
   2. C одной стороны ещё остались элементы уравнения, а с другой уже нет - переходим
   к подсчету мультимножеств элементов уравнения. 
*/
    (e.Numeric)(AreEqual ()(e.2)) = <SplitEquationLeft (e.Numeric) 0 (AreEqual ((<MyZero> Const))()()((<MyZero> Const))()(e.2))>; 
    (e.Numeric)(AreEqual (e.1)()) = <SplitEquationLeft (e.Numeric) 0 (AreEqual ((<MyZero> Const))()(e.1)((<MyZero> Const))()())>; 
/* 3. Отщепление равных термов слева и справа. */
    (e.Numeric)(AreEqual (e.1 t.1)(e.2 t.1)) = <SplitEquation (e.Numeric)(AreEqual (e.1)(e.2))>;
    (e.Numeric)(AreEqual (t.1 e.1)(t.1 e.2)) = <SplitEquation (e.Numeric)(AreEqual (e.1)(e.2))>;
/* 4. Отщепление скобок слева и справа. */
    (e.Numeric)(AreEqual (('*'e.01) e.1)(('*'e.02) e.2))
        = 
        <PostProcessSplits 
            (Common ()(<PlaceInCommEqs (AreEqual ('T')(e.01)(e.02))(New)(Generic)>)('T'))(Variants ) 
            <SplitEquation (e.Numeric)(AreEqual (e.1)(e.2))>
        >;
    (e.Numeric)(AreEqual (e.1('*'e.01))(e.2('*'e.02))) 
        = 
        <PostProcessSplits 
            (Common ()(<PlaceInCommEqs (AreEqual ('T')(e.01)(e.02))(New)(Generic)>)('T'))(Variants ) 
            <SplitEquation (e.Numeric)(AreEqual (e.1)(e.2))>
        >;
    (e.Numeric)(AreEqual ((weval e t.Name1) e.LHS)((weval e t.Name2) e.RHS))
    , <InvolvedInNumeric 1(weval e t.Name1)(weval e t.Name2)(e.Numeric)> : t.NewAssignment
    , <Substitute (t.NewAssignment)(weval e t.Name1) e.LHS> : e.NewLHS
    , <Substitute (t.NewAssignment)(weval e t.Name2) e.RHS> : e.NewRHS
        =
        (Common 
            (t.NewAssignment)
            (<PlaceInCommEqs (AreEqual ('T')(e.NewLHS)(e.NewRHS))(New)(Generic)>)
            ('T')
        )
        (Variants );
    (e.Numeric)(AreEqual (e.LHS (weval e t.Name1))(e.RHS (weval e t.Name2))),
    <InvolvedInNumeric 0(weval e t.Name1)(weval e t.Name2)(e.Numeric)> : t.NewAssignment,
    <Substitute (t.NewAssignment) e.LHS (weval e t.Name1)> : e.NewLHS,
    <Substitute (t.NewAssignment) e.RHS (weval e t.Name2)> : e.NewRHS
        =
        (Common 
            (t.NewAssignment)
            (<PlaceInCommEqs (AreEqual ('T')(e.NewLHS)(e.NewRHS))(New)(Generic)>)
            ('T')
        )
        (Variants );
/* 6. С двух сторон переменные равных типов (но не е-типа) - они равны между собой. */
    (e.Numeric)(AreEqual ((weval t.type e.name1) e.1)((weval t.type e.name2) e.2))
    , <MSType (weval t.type e.name1)> : Const
    , (assign (weval t.type e.name1)((<MyOne> Const))((weval t.type e.name2))) : t.NewAssignment
        = 
        <PostProcessSplits 
            (Common (t.NewAssignment)((New)(Generic))('T'))(Variants )
            <SplitEquation 
                (e.Numeric)
                (AreEqual (<Substitute (t.NewAssignment)e.1>)(<Substitute (t.NewAssignment)e.2>))
            >
        >;
    (e.Numeric)(AreEqual (e.1 (weval t.type e.name1))(e.2 (weval t.type e.name2)))
    , <MSType (weval t.type e.name1)> : Const
    , (assign (weval t.type e.name1)((<MyOne> Const))((weval t.type e.name2))) : t.NewAssignment
        = 
        <PostProcessSplits 
            (Common (t.NewAssignment)((New)(Generic))('T'))(Variants )
            <SplitEquation 
                (e.Numeric)
                (AreEqual (<Substitute (t.NewAssignment)e.1>)(<Substitute (t.NewAssignment)e.2>))
            >
        >;
/* 7. С одной стороны элемент уравнения более общего типа, чем с другой - формируем его уточнение. */
    (e.Numeric)(AreEqual (t.1 e.1)(t.2 e.2))
    , <LessGenericPattern t.1 t.2> : 'T'
    , <MSType t.1> : Const
    , <TermContradiction t.2 t.1> : 'F'
    , (assign t.1 ((<MyOne> Const))(t.2)) : t.NewAssignment 
        = 
        <PostProcessSplits 
            (Common (t.NewAssignment)((New)(Generic))('T'))(Variants )
            <SplitEquation (e.Numeric)
                (AreEqual (<Substitute (t.NewAssignment)e.1>)(<Substitute (t.NewAssignment)e.2>))
            >>;
    (e.Numeric)(AreEqual (t.1 e.1)(t.2 e.2))
    , <LessGenericPattern t.2 t.1> : 'T'
    , <MSType t.2> : Const
    , <TermContradiction t.1 t.2> : 'F'
    , (assign t.2 ((<MyOne> Const))(t.1)) : t.NewAssignment 
        = 
        <PostProcessSplits (Common (t.NewAssignment)((New)(Generic))('T'))(Variants )
            <SplitEquation 
                (e.Numeric)
                (AreEqual (<Substitute (t.NewAssignment)e.1>)(<Substitute (t.NewAssignment)e.2>))>
        >;
    (e.Numeric)(AreEqual (e.1 t.1)(e.2 t.2))
    , <LessGenericPattern t.1 t.2> : 'T'
    , <MSType t.1> : Const
    , <TermContradiction t.2 t.1> : 'F'
    , (assign t.1 ((<MyOne> Const))(t.2)) : t.NewAssignment 
        = 
        <PostProcessSplits (Common (t.NewAssignment)((New)(Generic))('T'))(Variants )
            <SplitEquation 
                (e.Numeric)
                (AreEqual (<Substitute (t.NewAssignment)e.1>)(<Substitute (t.NewAssignment)e.2>))>
        >;
    (e.Numeric)(AreEqual (e.1 t.1)(e.2 t.2))
    , <LessGenericPattern t.2 t.1> : 'T'
    , <MSType t.2> : Const
    , <TermContradiction t.1 t.2> : 'F'
    , (assign t.2 ((<MyOne> Const))(t.1)) : t.NewAssignment
        = 
        <PostProcessSplits (Common (t.NewAssignment)((New)(Generic))('T'))(Variants )
            <SplitEquation (e.Numeric)
                (AreEqual (<Substitute (t.NewAssignment)e.1>)(<Substitute (t.NewAssignment)e.2>))>
        >;
				
/* 5. Находим е-переменную (с одной или двух сторон), переходим к подсчету элементов уравнения. */
    (e.Numeric)(AreEqual ((weval e e.index1) e.1)((weval e e.index2) e.2))
        = 
        <SplitEquationLeft (e.Numeric)
            0 
            (AreEqual 
                ((<MyZero> Const)(<MyOne> (weval e e.index1)))
                ((weval e e.index1))
                (e.1)
                ((<MyZero> Const)(<MyOne> (weval e e.index2)))
                ((weval e e.index2))
                (e.2)
            )
        >;
    (e.Numeric)(AreEqual ((weval e e.index1) e.1)(t.2 e.2)) 
        = 
        <SplitEquationLeft (e.Numeric)
            0 
            (AreEqual 
                ((<MyZero> Const)(<MyOne> (weval e e.index1)))
                ((weval e e.index1))
                (e.1)
                ((<MyOne> Const))
                (t.2)
                (e.2)
            )
        >;
    (e.Numeric)(AreEqual (t.1 e.1)((weval e e.index2) e.2)) 
        = 
        <SplitEquationLeft (e.Numeric)
            0 
            (AreEqual 
                ((<MyOne> Const))
                (t.1)
                (e.1)
                ((<MyZero> Const)(<MyOne> (weval e e.index2)))
                ((weval e e.index2))
                (e.2)
            )
        >;
/* 8. Ни с одной стороны не переменная, не элемент более общего типа и не равные термы - противоречие. */
    (e.Numeric)(AreEqual (t.1 e.1)(e.2)) = (Common ()((New)(Generic))('F'))(Variants );
    (e.Numeric)(AreEqual (e.1)(t.2 e.2)) = (Common ()((New)(Generic))('F'))(Variants );
}/* SplitEquation */

/*
    Даны две переменные, обе стоят в начале (s.Mode=1) либо в конце (s.Mode=0) двух частей равенства.
   Если в численном блоке есть уравнение для длины одной переменной, включающее длину другой переменной,
   порождаем назначение, связывающее две эти переменные.
*/
InvolvedInNumeric {
    s.Mode t.Term1 t.Term2 (e.Num1 (AreEqual ((1 t.Term1))(e.MS1 (t.Pow t.Term2) e.MS2)) e.Num2)
    , <FreshIndex 'wevale_ind'> : t.NewName
        = (assign t.Term1 ((<MyOne> t.Term2)(<MyOne> (weval e t.NewName)))
                (<InverseShuffle s.Mode t.Term2 (weval e t.NewName)>));
    s.Mode t.Term1 t.Term2 (e.Num1 (AreEqual ((1 t.Term2))(e.MS1 (t.Pow t.Term1) e.MS2)) e.Num2)
    , <FreshIndex 'wevale_ind'> : t.NewName
        = (assign t.Term2 ((<MyOne> t.Term1)(<MyOne> (weval e t.NewName)))
            (<InverseShuffle s.Mode t.Term1 (weval e t.NewName)>));
    s.Mode t.Term1 t.Term2 (e.OtherNumeric) = ;
}

MSType {
    (weval e e.weval) = (weval e e.weval);
    (par e e.par) = (par e e.par);
    e.1 = Const;
}

ExtractTerm {
    0 t.1 e.1 = t.1;
    1 e.1 t.1 = t.1;
    s.Mode = ;
}

DeleteTerm {
    0 t.1 e.1 = e.1;
    1 e.1 t.1 = e.1;
    s.Mode = ;
}
InverseShuffle {
    0 t.1 e.1 = e.1 t.1;
    1 t.1 e.1 = t.1 e.1;
}

NonEmpty {
    ((0 Const)) = 'F';
    (e.Z) = 'T';
}

SplitEquationLeft {
/* 1. Оба выражения исчерпаны при разборе справа (т.е. окончательном). */
/* а) С одной стороны - лишь одна переменная, причем ее нет с другой стороны => возвращаем назначение. */
    (e.Numeric) 1 (AreEqual (e.ParMS1)((weval e e.var))()(e.ParMS2)(e.Proc2)())
    , <TermContradiction (weval e e.var) e.Proc2> : 'F'
        = (Common ((assign (weval e e.var)(e.ParMS2)(e.Proc2)))((New)(Generic))('T'))(Variants );
    (e.Numeric) 1 (AreEqual (e.ParMS1)(e.Proc1)()(e.ParMS2)((weval e e.var))())
    , <TermContradiction (weval e e.var) e.Proc1> : 'F'
        = (Common ((assign (weval e e.var)(e.ParMS1)(e.Proc1)))((New)(Generic))('T'))(Variants );
/*
   1б) Общий случай (включая случай, когда с одной стороны одна переменная, а с другой - выражение, включающее
   эту переменную). Уравнение считается расщепленным и готовым к оценке по длинам. 
*/
    (e.Numeric) 1 (AreEqual (e.ParMS1)(e.Proc1)()(e.ParMS2)(e.Proc2)()) 
        = (Common ()(<PlaceInCommEqs (AreEqual ('N')(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))(New)(Generic)>)('N'))(Variants );
        
/*
   2. Мультимножества уже обработанных параметров слева и справа одинаковы - 
   оба уравнения обрабатываются отдельно друг от друга. 
*/
    (e.Numeric) s.Mode (AreEqual (e.ParMS1)(e.Proc1)(e.1)(e.ParMS2)(e.Proc2)(e.2))
    , <CompareMultiSets (e.ParMS1)(e.ParMS2)> : 'T'
    , <NonEmpty (e.ParMS1)> : 'T' 
        =    
        <PostProcessSplits (Common ()(<PlaceInCommEqs (AreEqual ('N')(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))(New)(Generic)>)('T'))(Variants )
				<SplitEquation (e.Numeric) (AreEqual (e.1)(e.2))>
        >; 
/* 3. С одной стороны еще остались термы, с другой нет, проход справа. Включаем терм в мультимножество параметров. */
    (e.Numeric) 1 (AreEqual (e.ParMS1)(e.Proc1)(e.1 t.1)(e.ParMS2)(e.Proc2)()) 
        = 
        <SplitEquationLeft (e.Numeric) 
            1 
            (AreEqual 
                (<InsertInMultiSet 1(e.ParMS1)(<MyOne> <MSType t.1>)>)
                (t.1 e.Proc1)
                (e.1)
                (e.ParMS2)
                (e.Proc2)
                ()
            )
        >;
    (e.Numeric) 1 (AreEqual (e.ParMS1)(e.Proc1)()(e.ParMS2)(e.Proc2)(e.2 t.2)) 
        = 
        <SplitEquationLeft (e.Numeric)
            1 
            (AreEqual 
                (e.ParMS1)
                (e.Proc1)
                ()
                (<InsertInMultiSet 1(e.ParMS2)(<MyOne> <MSType t.2>)>)
                (t.2 e.Proc2)
                (e.2)
            )
        >;
/* 4. С двух сторон имеется по терму - помещаем их в мультимножества элементов уравнения. */
    (e.Numeric) s.Mode (AreEqual (e.OldParMS1)(e.Proc1)(e.1)(e.OldParMS2)(e.Proc2)(e.2))
    , <ExtractTerm s.Mode e.1> : t.1
    , <ExtractTerm s.Mode e.2> : t.2
    , <InsertInMultiSet s.Mode (e.OldParMS1)(<MyOne> <MSType t.1>)> : e.ParMS1
    , <InsertInMultiSet s.Mode (e.OldParMS2)(<MyOne> <MSType t.2>)> : e.ParMS2
        = 
        <SplitEquationLeft (e.Numeric) s.Mode 
            (AreEqual 
                (e.ParMS1)
                (<InverseShuffle s.Mode t.1 e.Proc1>)
                (<DeleteTerm s.Mode e.1>)
                (e.ParMS2)
                (<InverseShuffle s.Mode t.2 e.Proc2>)
                (<DeleteTerm s.Mode e.2>)
            )
        >;
/* 5. Разбор слева, хотя бы с одной стороны термов не осталось. Переход на разбор справа. */
    (e.Numeric) 0 (AreEqual (e.ParMS1)(e.Proc1)(e.1)(e.ParMS2)(e.Proc2)(e.2))
        =
        <SplitEquationLeft (e.Numeric) 1 (AreEqual ((<MyZero> Const))()(e.Proc1 e.1)((<MyZero> Const))()(e.Proc2 e.2))>;
}/* SplitEquationLeft */

$ENTRY NumericEsteem {
    (AreEqual e.Log(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))
        = <NumericEstimation Standart
                (<SubtractMS (e.ParMS1)(<FindMSIntersection (e.ParMS1)(e.ParMS2)>)>)
                (<SubtractMS (e.ParMS2)(<FindMSIntersection (e.ParMS1)(e.ParMS2)>)>)
                (AreEqual e.Log(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))
        >;
    (AreEqual e.Log(e.ParMS1)(e.ParMS2)) 
        = <NumericEstimation Length 
                (<SubtractMS (e.ParMS1)(<FindMSIntersection (e.ParMS1)(e.ParMS2)>)>)
                (<SubtractMS (e.ParMS2)(<FindMSIntersection (e.ParMS1)(e.ParMS2)>)>)
                (AreEqual e.Log(e.ParMS1)(e.ParMS2))
        >;
}

NumericEstimation {
/* 1. Константы сопоставляются пустому выражению => противоречие. */
    s.Mode ((s.Pow Const)e.LSE)() t.Equation
        = (Numeric )(Common ()((New)(Generic))('F'))(Variants );
    s.Mode ()((s.Pow Const)e.RSE) t.Equation
        = (Numeric )(Common ()((New)(Generic))('F'))(Variants );
/* 2. Переменные сопоставляются пустому выражению => все они пусты. */
    s.Mode ()()t.Equation
    , s.Mode :
        {Standart
        , t.Equation : (AreEqual e.Log t.MS1 t.LHS t.MS2 t.RHS)
            = (Numeric )
            (Common 
                ()
                (<PlaceInCommEqs (AreEqual ('D')t.MS1 t.LHS t.MS2 t.RHS)(New)(Generic)>)
                ('T'))
            (Variants );
        Length
            = (Numeric )
            (Common 
                ()((New)(Generic))
                ('T'))
            (Variants );
        };
    s.Mode (e.LSE)()t.Equation
    , s.Mode : 
        {Standart
        , t.Equation : (AreEqual e.Log t.MS1 t.LHS t.MS2 t.RHS)
            = <AssignNil ()(e.LSE)(AreEqual t.MS1 t.LHS t.MS2 t.RHS)>;
        Length
            = <AssignNil ()(e.LSE)(AreEqual ((0 Const))()((0 Const))())>;
        };
    s.Mode ()(e.RSE)t.Equation
    , s.Mode : 
        {Standart
        , t.Equation : (AreEqual e.Log t.MS1 t.LHS t.MS2 t.RHS)
            = <AssignNil ()(e.RSE)(AreEqual t.MS1 t.LHS t.MS2 t.RHS)>;
        Length
            = <AssignNil ()(e.RSE)(AreEqual ((0 Const))()((0 Const))())>;
        };
/* 3. Имеется линейное диофантово уравнение на длины переменных => разрешаем его и возвращаем список назначений */
    s.Mode (e.LSE)((s.Pow Const)) t.Equation
    , s.Mode :
        {Standart
            = <FormatAfterDE <SolveLinearDE ('T')(AreEqual (e.LSE)((s.Pow Const)))>
                (t.Equation)>;
        Length
            = <FormatAfterDE <SolveLinearDE ('T')(AreEqual (e.LSE)((s.Pow Const)))>
                ((AreEqual ((0 Const))()((0 Const))()))>;
        };
    s.Mode ((s.Pow Const))(e.RSE) t.Equation
    , s.Mode :
        {Standart
            = <FormatAfterDE <SolveLinearDE ('T')(AreEqual (e.RSE)((s.Pow Const)))>
                (t.Equation)>;
        Length
            = <FormatAfterDE <SolveLinearDE ('T')(AreEqual (e.RSE)((s.Pow Const)))>
                ((AreEqual ((0 Const))()((0 Const))()))>;
        };
/* 4. Общий делитель симметрической разности неконстантных элементов уравнения не делится на общий делитель разности констант - противоречие. */
    s.Mode (e.LSE)(e.RSE)
        (AreEqual e.Log
            (e.ParMS11 (s.Pow1 Const) e.ParMS12)e.LHS
            (e.ParMS21 (s.Pow2 Const) e.ParMS22)e.RHS)
    , <SolveLinearDE 
        ('F')
        (AreEqual 
            (<SymSubstMS (e.ParMS11 e.ParMS12)(e.ParMS21 e.ParMS22)>)
            (<SymSubstMS ((s.Pow1 Const))((s.Pow2 Const))>))
    > : ()('F')
        = (Numeric )(Common ()((New)(Generic))('F'))(Variants );

/*
    5. Слева или справа в мультимножествах разностей - только один элемент (его не может быть с другой стороны). 
   Извлекаем из данного соотношения уравнение на длину этого элемента. 
*/

    s.Mode ((t.Power (weval e t.Name)))(e.RSE)(AreEqual e.Log t.MS1 t.LHS t.MS2 t.RHS)
        = (Numeric <NormalizeNumericEquation (AreEqual (e.RSE)((t.Power (weval e t.Name))))>)
            (Common ()(<PlaceInCommEqs (AreEqual ('D')t.MS1 t.LHS t.MS2 t.RHS)(New)(Generic)>)('T'))
            (Variants );
    s.Mode (e.LSE)((t.Power (weval e t.Name)))(AreEqual e.Log t.MS1 t.LHS t.MS2 t.RHS)
        = (Numeric <NormalizeNumericEquation (AreEqual (e.LSE)((t.Power (weval e t.Name))))>)
            (Common ()(<PlaceInCommEqs (AreEqual ('D')t.MS1 t.LHS t.MS2 t.RHS)(New)(Generic)>)('T'))
            (Variants );
/* 6. Во всех прочих случаях возвращаем уравнение как есть. */
    s.Mode (e.LSE)(e.RSE) t.Equation
    , s.Mode :
        {Standart
        , t.Equation : (AreEqual e.Log(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))
            = (Numeric )(Common ()(<PlaceInCommEqs (AreEqual ('D')(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))(New)(Generic)>)('T'))(Variants );
        Length
            = (Numeric t.Equation)(Common ()((New)(Generic))('T'))(Variants );
        };
}

/*
    Заменяем все вхождения переменных, равных пустому слову, в две части уравнения, на пустое слово. 
   Удаляем эти переменные из мультимножеств-индикаторов, добавляем назначения вида "переменная равна пустому слову". 
*/

AssignNil {
    (e.Assignments)()(AreEqual (e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))
        = (Numeric )(Common (e.Assignments)(<PlaceInCommEqs (AreEqual ('T')(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))(New)(Generic)>)('T'))(Variants );
    (e.Assignments)((t.Power (weval e e.index)) e.other)(AreEqual (e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))
        = <AssignNil (e.Assignments (assign (weval e e.index) ((<MyZero> Const))()))(e.other)
            (AreEqual 
                (<SubtractEl (Inf (weval e e.index))(e.ParMS1)>)
                (<Substitute ((assign (weval e e.index)((<MyZero> Const))())) e.Proc1>)
                (<SubtractEl (Inf (weval e e.index))(e.ParMS2)>)
                (<Substitute ((assign (weval e e.index)((<MyZero> Const))())) e.Proc2>)
            )
        >;
}

/* После того как ЛДУ на длины уравнений решено, смотрим результат. */
FormatAfterDE {
/* У ЛДУ нет решений. */
    (e.WevalAsgmnts)('F')((AreEqual e.Log(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))) 
        = 
        (Numeric )(Common ()((New)(Generic))('F'))(Variants );
/* Нашлось единственное решение ЛДУ. */
    ((Case e.WevalAsgmnt))('T')((AreEqual e.Log(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2)))
        =
        (Numeric )(Common (e.WevalAsgmnt)(<PlaceInCommEqs (AreEqual ('T')(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))(New)(Generic)>)('T'))(Variants );
/* У ЛДУ более одного решения. */
    (e.WevalAsgmnts)('N')((AreEqual e.Log(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2)))
        =
        (Numeric )
        (Common ()(<PlaceInCommEqs (AreEqual ('D')(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))(New)(Generic)>)('T'))
        (Variants <GenerateCases (e.WevalAsgmnts)()>);
}

GenerateCases {
    ()(e.Eqs) = ;
    ((Case e.asg) e.OtherCases)(e.Eqs) = (Case (e.asg)(e.Eqs)('T'))<GenerateCases (e.OtherCases)(e.Eqs)>;
}

$ENTRY IfEqIsImplied {
    t.Equation (e.GivenEqs)
    , <AddPRTCGenericEqs <ReplacePRTCNewEqs <GenerateFreshPRTC ()()> t.Equation> e.GivenEqs> : t.NewPRTC
        = <CheckForNullNewEqs (t.Equation)
            <SolveEquations t.NewPRTC>
        >;
}

CheckForNullNewEqs {
    (t.Equation) t.PRTC
    , <GetPRTCNewEqs t.PRTC> : /* EMPTY */
    , <GetPRTCRestrs t.PRTC> : e.Restrictions
    , t.Equation : (AreEqual (s.Log)(e.LHS)(e.RHS))
    , (e.Restrictions)(e.LHS e.RHS) :
        {(e.1 (assign t.par (e.data)) e.2)(e.3 t.par e.4)
            = 'F';
        e.Z
            = 'T';
        };
    e.Z = 'F';
}

/* Для трассировщика. */
AAA { = ;}
