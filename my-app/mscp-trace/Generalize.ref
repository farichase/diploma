/*
   Модуль функций обобщения и вложения.
   
   Доступные из модуля функции:
   
   HomeomorphicEmb --- проверка двух выражений на наличие гомеоморфного вложения. Формат:
   ([ExprToBeEmbedded])[ExprToEmbed] => [Log]
   
   CheckNode4Equivalence - проверка на наличие узла, выражение в котором есть подстановка в данное. 
   Формат:
   (Expression)[Path][Tree] => Ready | (Looped [NodeName] (assign (par e.par)((par e.newpar)))^*)
   
   FoldStackIntoConf - извлечение выражения из стека. Формат:
   ((assign (var l t.varname)(e.Val))^+)^+ => [Expression]
   
   IfEquivalentConf - проверка двух выражений на совпадение по модулю переименования параметров. Формат:
   ([Assignments])([Expr])([Expr]) => ([Assignments]) | False
   
   CheckNode4Generalization - проверка на вложение (и построение обобщения, если оно существует). Формат:
   [CurrentNodeName]([CurrentConfiguration])([CurrentStack])([Path])[Tree]
   =>
   Driven | (Generalized [CurrentNodeName] (Looped [AncestorNodeName]) ([Configuration])([Stack])
   (Children ([NodeName] Undriven (([Eqs])([Restrs])([Config])([Stack])))^*))
*/

/* из basics.ref */
$EXTERN LogAnd, LogAndMerge, LogOrMerge, LogOr, SetIntersect, FindTerm, RenewIndices, FreshIndex, 
        CurrentIndex,MyInc, MyOne, MyZero, MyMax, MyAdd, MySub, MyIfNotLess, MytoBool, MyMin, MyNewLevel;
/* из basics.ref */
$EXTERN Substitute,FindNode,CompareCalls,ComplexCompareCalls, Collapse,AddTime, RandomNumber,IfBounded,IfConstant,CountLength;
/* из drive.ref */
$EXTERN FormatStack;
/* из stack.ref */
$EXTERN YieldDecomposition;
/* из formats.ref */
$EXTERN IsFreeExpression;
/* из Drive.ref */
$EXTERN ClashLeft, Drive, ClassIdentifier;
/* из residual.ref */
$EXTERN ConvertPrefal;
/* из access_MSCP.ref */
$EXTERN GetNodeConfig, GetNodeStack, GetNodeLets, PutNodeConfig, PutNodeStack, 
        GenerateNewNode, PutNodeLets, PutNodeNewEqs, PutNodeNewEqsToOld,PutNodeNegEqs,GetNodeEqs, 
        SubstituteInNegative, AddNewLines,
        GenerateFreshPRTC, AddPRTCNegativeInfo;
/* из WordEqsCases.ref */
$EXTERN UnfoldMainEq;
/* из WordEquations.ref */
$EXTERN ScreenNegatives;

/*
   $ENTRY Go {
     = <MGUAssoc ((par e <MyZero>))((assign (par e <MyZero>) (ToUnify ('ABC')('BBA'))))()>}; 
*/
/*$ENTRY Go {
     = <HomeomorphicEmb ((call ((M1 (2 ))2 )(args (arg ('*AA')('*'(par e x ))('*AA')('*'(par e x ))))))
(call ((M1 (2 ))4 )(args (arg ('*A')('*'(par e 1 ))('*AA')('*A'(par e 1 )))))>;
} */

     

/* Для трассировщика. */
A {e.1 = e.1;}

/*
    Проверка, повторяет ли конфигурация в узле конфигурацию какого-либо предка этого узла.
   Если повторяет, узел помечается как зацикленный.
   Не повторяет - как готовый к проверке на обобщение.
   Вход:
   (Expression)[Path][Tree]
   Выход:
   Ready | (Looped [NodeName] [Assignments]) 
*/

$ENTRY CheckNode4Equivalence {
/* 1. Проверили всех предков. */
        (e.Data)()t.Tree = Ready;
/* 2. Нашли эквивалентный по конфигурации узел предка. */
	(e.Data)(e.Path t.NodeName)t.Tree, 
            <IfEquivalentConf ()(e.Data)<GetFullConf <FindNode (e.Path t.NodeName) t.Tree>>> :(e.subs) 
                = <RandomizedSaveTest e.Data>(Looped t.NodeName e.subs);
/* 3. Очередной узел не является эквивалентным - проверяем следующего предка по пути к корню. */
        (e.Data)(e.Path t.NodeName)t.Tree = <CheckNode4Equivalence (e.Data)(e.Path)t.Tree>;
}

RandomizedSaveTest {
    e.Data
    , <RandomNumber 1 1000> : 
        { 3 =   <Putout 3 e.Data>;
        s.Other = ;
        };
}

/*
    Функция формата: Извлечение из узла конфигурации его терма. 
   Вход:
   (Node [NodeStatus] [NodeName] (([Restrictions])([Equations])([NegativeInfo])(Configuration)[Stack][Children]))
   Выход:
   (Configuration)
*/
GetFullConf {
/* 1. Извлекаем полную конфигурацию терма, если он не есть let-расщепление. */
    t.Node
    , <GetNodeLets t.Node> : (/* EMPTY */)
    , <GetNodeConfig t.Node> : e.FullConf = (e.FullConf);
/* 2. Если узел содержит let-расщепление, его не проверяем. */
    t.Node = False;
}

/*
    Свертка стека в единое выражение.
   ((assign (var l t.varname)(e.Val))^+)^+ => [ExpressionWithCalls]
*/
$ENTRY FoldStackIntoConf {
/* 1. Выражение построено. */
    ((assign (var l e.varname) (e.Val))) = <DeleteObjectives e.Val>;
/* 2. Исчерпали переменные уровня -> переходим к следующему. */
    (/* EMPTY */)(e.NextLevel)e.UpperLevels
        = <FoldStackIntoConf (e.NextLevel)e.UpperLevels>;
/* 3. Подставляем значение стековой переменной вместо ее самой в верхний уровень. */
    ((assign (var l e.varname) (e.Val))e.ThisLevel)(e.NextLevel)e.UpperLevels    
        = <FoldStackIntoConf (e.ThisLevel)(<Substitute ((assign (var l e.varname) (e.Val)))e.NextLevel>)e.UpperLevels>;
}

/*
    Удаление объектных термов с внешнего уровня.
   [Expression] => {(call e.call)|(par e t.parname)}^*
*/
DeleteObjectives {
    e.Val = e.Val;
/*
    (call e.call)e.Val = (call e.call) <DeleteObjectives e.Val>;
    ('*'e.Val1)e.Val2 = <DeleteObjectives e.Val1><DeleteObjectives e.Val2>;
    s.1 e.Val = <DeleteObjectives e.Val>;
    (par e e.pardata) e.Val = (par e e.pardata) <DeleteObjectives e.Val>;
    (par e.pardata) e.Val = <DeleteObjectives e.Val>; 
*/

}

/*
    Проверка двух конфигураций на совпадение по модулю имен параметров.
   ([Substitutions])([Expression])([Expression]|False)=>([ParAssignment]^*)|False 
*/

$ENTRY IfEquivalentConf {
/* 1. Завершена успешно. Проверяем, есть ли разные подстановки в один и тот же параметр. */
    (e.subst)(e.1)(e.1) = <IfCorrectSubs e.subst>;
/*
   2. Параметры равных типов считаются эквивалентными. Это правило стоит выше правила 3 (о равных термах), 
   чтобы не терялась подстановка параметра в себя. 
*/
    (e.subst)((t.sort s.type e.x)e.Conf1)((t.sort s.type e.y)e.Conf2)
    , par weval var : e.1 t.sort e.2
        = <IfEquivalentConf 
                (e.subst (assign (t.sort s.type e.x)((t.sort s.type e.y))))
                (e.Conf1)(e.Conf2)
        >;
/* 3. Равные термы эквиваленты. */
    (e.subst)(t.1 e.Conf1)(t.1 e.Conf2)
        = <IfEquivalentConf (e.subst)(e.Conf1)(e.Conf2)>;
/*
   4. Сопоставление друг другу выражений со скобками успешно, если части выражений, отделенные скобками, эквивалентны.
   Через LogAnd --- поскольку нам важно, где именно стоят скобки.
   Т.е. ('A')'B' не эквивалентно ('AB'), из-за положения скобок. 
*/
    (e.subst)(('*' e.Conf11) e.Conf12)(('*' e.Conf21) e.Conf22)
    , <IfEquivalentConf (e.subst)(e.Conf11)(e.Conf21)> : (e.newSubst) 
        = <IfEquivalentConf (e.newSubst)(e.Conf12)(e.Conf22)>;
/* 5. Эквивалентность вызовов = эквивалентность аргументов и совпадение имен функций. */
    (e.subst)((call t.fname1 (args (arg e.Conf1Arg))) e.Conf1)((call t.fname2 (args (arg e.Conf2Arg))) e.Conf2)
    , <CompareCalls t.fname1 t.fname2> : 'T'
    , <IfEquivalentConf (e.subst)(e.Conf1Arg)(e.Conf2Arg)> : (e.newSubst)
        = <IfEquivalentConf (e.newSubst)(e.Conf1)(e.Conf2)>;
/* 6. Иначе эквивалентности нет. */
    (e.subst)(e.1) e.2 = False;
}

/* Удаление повторных подстановок параметров и выход в противоречие, если в один и тот же подставляются различные. */
IfCorrectSubs {
    e.1 t.1 e.2 t.1 e.3 = <IfCorrectSubs e.1 t.1 e.2 e.3>;
    e.1 (assign t.data t.val) e.2 (assign t.data t.otherval) e.3 
        = False;
    e.Z = (e.Z);
}

/*---------------------------------------------------------------------------------
                                  ФУНКЦИИ ВЛОЖЕНИЯ
-----------------------------------------------------------------------------------*/

/*
    Вход: 
   [CurrentNodeName]([CurrentConfiguration])([CurrentStack])([Path])[Tree]
   Выход:
   Driven | (Generalized [CurrentNodeName] (Looped [AncestorNodeName]) ([Configuration])([Stack])
   (Children ([NodeName] Undriven (([Eqs])([Restrs])([Config])([Stack])))^*))
   Конфигурация, являющаяся MGU (обобщенная конфигурация), в список Children не входит.
*/
$ENTRY CheckNode4Generalization {
 /* Перед тем как обобщать, проверяем, не является ли активный вызов в конфигурации вызовом функции без рекурсии. */
    t.SuccName s.Flag (e.Eqs)(e.FullConf)(e.Stack)(e.Path)t.Tree
    , s.Flag :
        {'T'
            = Driven;
        s.OtherFlag
            = <CheckNode4Generalization Started t.SuccName (e.Eqs)(e.FullConf)(e.Stack)(e.Path)t.Tree>;
        };
/* 1. Дошли до корня, и кандидатов на обобщение нет -> узел прогнан. */
    Started t.SuccName (e.Eqs)(e.FullConf)(e.Stack)(/* NO MORE NODES */)t.Tree = Driven;
/* 2. Проверяем наличие сходства с очередным узлом предка. Если оно есть, запускаем процесс обобщения. */
    Started t.SuccName (e.Eqs)(e.FullConf)(e.Stack)(e.Path t.NodeName)t.Tree
    , <FindNode (e.Path t.NodeName) t.Tree> : t.ImbeddingNode
    , <GetFullConfPlusStack t.ImbeddingNode> : (e.UpperConf)(e.UpperStack)
    , <GetNodeEqs t.ImbeddingNode> : e.Eqs2
    , <Collapse <TimeElapsed 0>>
      <EmbeddingConfs 
        <Putout 1 '  Trying to embed: '>
        ((e.Eqs2)(e.UpperConf)(e.UpperStack))
        ((e.Eqs)(e.FullConf)(e.Stack))
      >
      <Collapse <AddTime ('emb_time') <TimeElapsed>>>
        : s.Depth 'T'
        = <Putout 1 '  EMBEDDING IS SUCCESSFUL.'>
        <YieldGeneralization (Depth s.Depth) t.SuccName t.NodeName
            (e.Eqs2)(e.UpperConf)(e.UpperStack)
            <Collapse <TimeElapsed 0>>        
            (e.Eqs)(e.FullConf)(e.Stack)
        >
        <AddTime ('mgu_time')<TimeElapsed>>;
/* 3. В противном случае осуществляем проверку на сходство очередной конфигурации предка. */
    Started t.SuccName (e.Eqs)(e.FullConf)(e.Stack)(e.Path t.NodeName)t.Tree
        = <CheckNode4Generalization Started t.SuccName (e.Eqs)(e.FullConf)(e.Stack)(e.Path)t.Tree>;
}

/*
    Выделение из конфигурации узла стека и полного выражения.
   [Node] => ([Expression])([Stack])
*/
GetFullConfPlusStack {
    t.Node
    , <GetNodeConfig t.Node> : e.FullConf
    , <GetNodeStack t.Node> : e.Stack
        = (e.FullConf)(e.Stack);
}

/*
    Функция-формат для запуска обобщения
   t.NameOfTheLowerNode t.NameOfTheUpperNode ([UpperConfigurationExpr])([LowerConfigurationExpr])
    =>
*/
YieldGeneralization {
/*
    (Depth s.1) t.SuccessorName t.UpperNodeName (e.UpperConf)(e.UpperStack)(e.LowerConf)(e.LowerStack) = 
                <AnalyzeMGUResults t.SuccessorName t.UpperNodeName (e.UpperConf) 
                    <MGUAssoc 
                            ((par e <FreshIndex 'pare_ind'>))
                            ((assign (par e <CurrentIndex 'pare_ind'>)
                                (ToUnify (e.UpperConf)(e.LowerConf))
                            ))
                    >
                >; 
*/

    (Depth s.Depth) t.SuccessorName t.UpperNodeName (e.UpperEqs)(e.UpperConf)(e.UpperStack)(e.LowerEqs)(e.LowerConf)(e.LowerStack)
    , <IfEquivalentConf (/* EMPTY */)(e.UpperConf)(e.LowerConf)> : (e.Asgs)
        = <RandomizedSaveTest e.LowerConf><Putout 1 'Depth is 's.Depth>
        <AnalyzeMGUResults 
            t.SuccessorName t.UpperNodeName (e.UpperEqs)(e.LowerEqs)(e.UpperConf)(e.UpperConf)(<GenerateTrivialMGUs e.Asgs>)(/* EMPTY */)
        >;
            
   (Depth s.Depth) t.SuccessorName t.UpperNodeName (e.UpperEqs)(e.UpperConf)(e.UpperStack)(e.LowerEqs)(e.LowerConf)(e.LowerStack) 
        = <RandomizedSaveTest e.LowerConf>               
        <AnalyzeMGUResults t.SuccessorName t.UpperNodeName (e.UpperEqs)(e.LowerEqs)(e.UpperConf) 
            <Putout 1 '  Depth is 's.Depth>
                <FormatUnification (e.UpperEqs)(e.LowerEqs)(e.UpperConf)(e.LowerConf)>
        >;
}

/* (e.Pattern)(e.MGUs) => (e.Pattern)(e.MGUs) */
MergeFreeParameters {
/* e.1 = e.1; */
    (e.Pattern)(e.MGUs)
        = <SubstituteMergedPars (e.Pattern)(e.MGUs)(/* EMPTY */)<SortFreeSeq (e.MGUs)<FindFreeSeq e.Pattern>>>;
    e.1 = e.1;
}

/* e.ParameterizedExpression => ((par e t.name1)(par e t.name2))^* */
FindFreeSeq {
    e.1 (par e t.name1)(par e t.name2) e.2
        = ((par e t.name1)(par e t.name2)) 
        <FindFreeSeq e.1>
        <FindFreeSeq (par e t.name2) e.2>;
    e.1 (call t.fname (args (arg e.arg))) e.2 
        = <FindFreeSeq e.1><FindFreeSeq e.arg><FindFreeSeq e.2>;
    e.1 ('*' e.inbr) e.2
        = <FindFreeSeq e.inbr><FindFreeSeq e.2>;
    e.Z = /* EMPTY */;
}

/*
    Дан список пар открытых параметров, стоящих рядом. Перевести их в формат, входной для SubstituteMergedPars.
   (e.MGUs) ((par e t.name1)(par e t.name2))^* => (ToMerge (par e t.name1)(par e t.name2))^* 
*/

SortFreeSeq {
    (e.MGUs) = /* EMPTY */;
    (e.MGUs)e.1 t.1 e.2 t.1 e.3
        = <SortFreeSeq (e.MGUs) e.1 t.1 e.2 e.3>;
/*
    (e.MGUs)(t.par1 t.par2) e.triples,
    e.MGUs : e.1 (assign t.par1 e.data) e.2,
    e.MGUs : e.1 (assign t.par3 e.data) e.2 = <SortFreeSeq (e.MGUs) e.triples>;
    (e.MGUs)(t.par1 t.par2 t.par3) e.triples,
    e.MGUs : e.1 (assign t.par2 e.data) e.2 = <SortFreeSeq (e.MGUs) e.triples>; 
*/
    (e.MGUs)(t.par1 t.par2) e.pairs
        = (ToMerge t.par1 t.par2)<SortFreeSeq (e.MGUs) e.pairs>;
    (e.MGUs) t.triple e.triples
        = <SortFreeSeq (e.MGUs)e.triples>;
}

/*
    Удаление тех подстановок в обобщении, которые не встречаются в структуре.
   ([Expression])([Assignment]^*) => ([Expression])([Assignment]^*)
*/
DeleteNonInfMGUs {
    (e.Pattern)(e.1 (assign t.par e.data) e.2)
    , <IsInStructure t.par e.Pattern> : 'F'
        = <DeleteNonInfMGUs (e.Pattern)(e.1 e.2)>;
    e.Z = e.Z;
}

/*
    Дан список пар е-параметров, стоящих рядом и нуждающихся в слиянии (после обобщения).
   Построить это слияние.
   (e.Pattern)(e.MGUs)(e.Equations)(ToMerge (par e s.Name1)(par e s.Name2))^* => (e.Pattern)(e.MGUs)(e.Equations)
*/
SubstituteMergedPars {
    (e.Pattern)(e.MGUs)(e.Equations) = <DeleteNonInfMGUs (e.Pattern)(e.MGUs)>(e.Equations);
    (e.Pattern)(e.MGUs)(e.Equations)e.1 t.1 e.2 t.1 e.3 = <SubstituteMergedPars (e.Pattern)(e.MGUs)(e.Equations) e.1 t.1 e.2 e.3>;
    (e.Pattern)(e.MGUs)(e.Equations)(ToMerge t.par1 t.par2) e.ToMerge
    , <FindMGU t.par1 e.MGUs> : (assign t.par1 (e.Val11)(e.Val12))
    , <FindMGU t.par2 e.MGUs> : (assign t.par2 (e.Val21)(e.Val22))
    , <FreshIndex 'pare_ind'> : t.newind
        = <SubstituteMergedPars 
            (<SubstituteOnCond (t.par1)()((assign t.par1 ((par e t.newind)))(assign t.par2 ())) e.Pattern>)
            (e.MGUs (assign (par e t.newind) (e.Val11 e.Val21)(e.Val12 e.Val22)))
            (e.Equations /* (AreEqual ('F')((par e t.newind))(t.par1 t.par2))*/ )            
            e.ToMerge
        >;
/*   (e.Pattern)(e.MGUs)(ToMerge (1) t.par1 t.par2) e.ToMerge,
    e.MGUs : e.1 (assign t.par2 (e.val1)(e.val2)) e.2
     = 
        <SubstituteMergedPars 
            (<SubstituteOnCond ()(t.par2)((assign t.par1 ())) e.Pattern>)
            (e.1 (assign t.par2 (t.par1 e.val1)(t.par1 e.val2)) e.2) 
            e.ToMerge
        >; 
*/
}

/*
    Подстановка при условии определенного соседства. Имеется пара подстановок и она подставляется в выражение,
   если и только если переменные в этом выражении, на которые есть подстановка, встречаются в нём рядом и в том же порядке.
*/
SubstituteOnCond {
    (e.Before)(e.After)(e.Subst) = ;
    (e.Before)(e.After)(e.Subst) ('*'e.1)e.2
    , <SubstituteOnCond (e.Before)(e.After)(e.Subst)e.1> : e.InBr
        = ('*'e.InBr)<SubstituteOnCond (e.Before)(e.After)(e.Subst)e.2>;
    (e.Before)(e.After)(e.Subst) (call t.fname (args (arg e.1)))e.2
    , <SubstituteOnCond (e.Before)(e.After)(e.Subst)e.1> : e.Arg
        = (call t.fname (args (arg e.Arg)))<SubstituteOnCond (e.Before)(e.After)(e.Subst)e.2>;
    (t.pred)(e.After)((assign t.pred (e.Val1)) (assign t.par (e.Val2))) t.pred t.par e.1
        = e.Val1 e.Val2 <SubstituteOnCond (t.pred)(e.After)((assign t.pred (e.Val1)) (assign t.par (e.Val2))) e.1>;
/*
    (e.Before)(t.post)((assign t.par (e.Val))) t.par t.post e.1 =
        e.Val t.post <SubstituteOnCond (e.Before)(t.post)((assign t.par (e.Val))) e.1>; 
*/
    (e.Before)(e.After)(e.Subst) t.1 e.1
        = t.1 <SubstituteOnCond (e.Before)(e.After)(e.Subst) e.1>;
}

/*
    Замена стековой переменной свежим параметром.
   (s.Depth)(e.Stack)=>{(assign t.par (e.LowerExpr))|(NOTHING)}(e.OuterExpr)
   e.LowerExpr --- выражение, являющееся сверткой части стека, присвоенной параметру.
   e.OuterExpr --- свертка стека, лежащего ниже той части, которая была свернута в параметр. Теперь она содержит вхождение этого нового параметра.
*/
ReplaceStackLevelWithNewPar {
    (0)(((assign (var l t.name)(e.Val))e.LowerLevel))
    , <FreshIndex 'pare_ind'> : t.newparname 
        = (assign (par e t.newparname)(e.Val))((par e t.newparname));
    (0)(((assign (var l t.name)(e.Val))e.LowerLevel)e.OtherStack)
    , <FreshIndex 'pare_ind'> : t.newparname
        = 
        (assign (par e t.newparname)(e.Val))
        (<FoldStackIntoConf
            <Substitute ((assign (var l t.name)((par e t.newparname)))e.LowerLevel) e.OtherStack>>
        );
    (s.x)((e.LowerLevel)(e.UpperLevel)e.OtherStack) 
        = <ReplaceStackLevelWithNewPar (<Sub s.x 1>)((<Substitute (e.LowerLevel)e.UpperLevel>)e.OtherStack)>;
}

GenerateTrivialMGUs {
    /* EMPTY */ = /* EMPTY */;
    (assign t.par (e.Expr)) e.Rest = (assign t.par (t.par)(e.Expr)) <GenerateTrivialMGUs e.Rest>;
}

/* Функция, вызывающая функцию обобщения по результатам анализа и разбивки стека по отношению Турчина. */
FormatUnification {
/*
    (e.Asgs)(e.Top1)(e.UpperConf)(NOTHING)(e.LowerConf)
        = (e.UpperConf)(<GenerateTrivialMGUs e.Asgs>);   
*/
    
/*    (e.Bottom1)(e.UpperConf)(NOTHING)(e.LowerConf)
        = <MGUAssoc ((par e <FreshIndex 'pare_ind'>))
                            ((assign (par e <CurrentIndex 'pare_ind'>)
                                (ToUnify (e.UpperConf)(e.LowerConf))
                            ))()>;
    (NOTHING)(e.Bottom1)(assign t.parname2 t.STop2)(e.Bottom2) 
        = <MGUAssoc ((par e <FreshIndex 'pare_ind'>))
                            ((assign (par e <CurrentIndex 'pare_ind'>)
                                (ToUnify (e.Bottom1)(<Substitute ((assign t.parname2 t.STop2)) e.Bottom2>))
                            ))()>;
*/
    (e.Eqs1)(e.Eqs2)(e.Conf1)(e.Conf2)
    , <FreshIndex 'pare_ind'> : s.newpar
    , <MGUAssoc 
        ((par e s.newpar)) /* Обобщенное выражение пока тривиально. */
        (
            (assign (par e s.newpar)
            (ToUnify (e.Conf1)(e.Conf2))
            )
        )
        (/* Список подстановок в параметры обобщенного выражения пока пуст. */)
        > : 
        {
        (False)(False) = False;
        (e.Pattern)(e.MGUs)
        , e.Eqs1 : e.OtherEqs1 (Generic e.GenEqs1)
        , <GenerateNewEquations (/* NO Eqs */)(/* NO NegEqs */)(e.Eqs1)(e.Eqs2)(e.Pattern)e.MGUs> : (e.PosNewEqs)(e.NegNewEqs)
        , <MergeFreeParameters <PushUnaryPars (e.GenEqs1 e.PosNewEqs)(e.Pattern)(e.MGUs)>>
            : (e.NewPattern)(e.NewMGUs)(e.EqMerging) 
        , e.Eqs2 : 
            { e.SomeEqs (Generic t.AtLeastOneEq e.GenEqs)
                = <UseEqLemmas (t.AtLeastOneEq e.GenEqs)(e.NewPattern)(e.NewMGUs)>(e.EqMerging);
            e.NoGenEqs
                = (e.NewPattern)(e.NewMGUs)(e.EqMerging);
            };
        };

/*
    (assign t.parname1 t.STop1)(e.Bottom1)(assign t.parname2 t.STop2)(e.Bottom2),
    <FreshIndex 'pare_ind'> : t.BottomPar,
    <MGUAssoc ((par e t.BottomPar))
    ((assign (par e t.BottomPar)
        (ToUnify (e.Bottom1)(e.Bottom2))))()
    > : (e.Pattern)(e.MGUs) 
        = (e.Pattern)(<SubstituteInMGUs ((assign t.parname1 t.STop1)(assign t.parname2 t.STop2))e.MGUs>);*/
}

/*
    Попытка заменить обобщение вложением, используя уравнения.
    Вход - (уравнения)(обобщенное выражение)(пары подстановок).
    Выход - (обобщенное выражение)(пары подстановок).
*/
UseEqLemmas {
    (e.Eqs)(e.Pattern)(e.MGUs)
        = <UnfoldMainEq ((e.Pattern)(e.Eqs))(Expression Undriven (0) (e.MGUs))>;
}

PushUnaryPars {
    ((AreEqual (s.Log)(e.1 t.par t.1 e.Expr e.2)(e.1 t.1 e.Expr t.par e.2))e.Eqs)(e.Pattern)(e.MGUs)
        = <PushUnaryPars (e.Eqs)(<ApplyEquationToPush ((t.par t.1 e.Expr)(t.1 e.Expr t.par)) e.Pattern>)(e.MGUs)>;
    (t.Other e.Eqs)(e.Pattern)(e.MGUs)
        = <PushUnaryPars (e.Eqs)(e.Pattern)(e.MGUs)>;
    (/* EMPTY */)(e.Pattern)(e.MGUs)
        = (e.Pattern)(e.MGUs);
}

ApplyEquationToPush {
    ((t.par e.Expr)(e.Expr t.par))e.BeforeBr ('*' e.InBr)e.OutBr
        = <ApplyEquationToPush ((t.par e.Expr)(e.Expr t.par))e.BeforeBr>
        ('*'<ApplyEquationToPush ((t.par e.Expr)(e.Expr t.par))e.InBr>)
        <ApplyEquationToPush ((t.par e.Expr)(e.Expr t.par))e.OutBr>;
    ((t.par e.Expr)(e.Expr t.par))e.BeforeCall (call t.fname (args (arg e.Arg)))e.OutCall
        = <ApplyEquationToPush ((t.par e.Expr)(e.Expr t.par))e.BeforeCall>
        (call t.fname (args (arg <ApplyEquationToPush ((t.par e.Expr)(e.Expr t.par))e.Arg>)))
        <ApplyEquationToPush ((t.par e.Expr)(e.Expr t.par))e.OutCall>;
    ((t.par e.Expr)(e.Expr t.par)) e.1 (par e t.name) e.Expr e.Syms t.par e.2
    , e.Expr e.Syms : e.Syms e.Expr
    , <Putout 2 'Unary parameter is pushed:'>
    <Putout 2 e.1 (par e t.name) e.Expr e.Syms t.par e.2 ' to ' e.1 (par e t.name) t.par e.Expr e.Syms e.2> : /* NOTHING */
        = e.1 (par e t.name) <ApplyEquationToPush ((t.par e.Expr)(e.Expr t.par)) t.par e.Expr e.Syms e.2>;
    ((t.par e.Expr)(e.Expr t.par)) e.1 t.par e.Expr e.Syms (par e t.name) e.2
    , e.Expr e.Syms : e.Syms e.Expr
    , <Putout 2 'Unary parameter is pushed:'>
    <Putout 2 e.1 t.par e.Expr e.Syms (par e t.name) e.2 ' to ' e.1 e.Expr e.Syms t.par (par e t.name) e.2> : /* NOTHING */
        = e.1  e.Expr e.Syms t.par <ApplyEquationToPush ((t.par e.Expr)(e.Expr t.par)) (par e t.name) e.2>;
    (e.Eq)e.Other = e.Other;
}

SubstituteInMGUs {
    (e.Subst) = /* EMPTY */;
    (e.Subst)(assign t.par (e.Val1)(e.Val2)) e.Rest
        = (assign t.par (<Substitute (e.Subst) e.Val1>)(<Substitute (e.Subst) e.Val2>))
        <SubstituteInMGUs (e.Subst)e.Rest>;
}

/*
    Смотрим результат построения обобщения: обобщение сверху или снизу?
   t.SuccessorName t.UpperNodeName (e.UpperConf)(e.Pattern)(e.MGUs) => 
   (Generalized t.GenNodeName (UpperGeneralization | Looped t.AncestorNodeName) ([Configuration])[Stack] (Children [Node]^*))
*/
AnalyzeMGUResults {
/* 0. Обобщение тривиально. */
    t.SuccessorName t.UpperNodeName (e.UpperEqs)(e.LowerEqs)(e.UpperConf)((par e t.name))(e.MGUs)(e.EquationsFromMerging) = Driven;
*    t.SuccessorName t.UpperNodeName (e.UpperEqs)(e.LowerEqs)(e.UpperConf)False e.1 = Driven;

/* 1. Вложение. */
    t.SuccessorName t.UpperNodeName (e.UpperEqs)(e.LowerEqs)(e.UpperConf)(e.Pattern)(e.MGUs)(e.EquationsFromMerging)
    , <IfEquivalentConf (/*No substitutions for now */)(e.UpperConf)(e.Pattern)> : (e.Subs)
    , <SplitMGUs 1 e.MGUs> : e.Assignments
    , <DeleteTrivialSubs (e.Assignments)(e.Subs)e.Pattern> : (e.CheckedSubs) e.CheckedPattern
    , <GenerateNewEquations ()()(e.UpperEqs)(e.LowerEqs)(e.Pattern)e.MGUs> : (e.Pos)(e.NSNeg)
    , <ScreenNegatives Init e.NSNeg> : e.Neg
        =
        <Putout 2 '================================================================================='>
        <Putout 2 '  FOLDING ATTEMPT: 't.SuccessorName' and 't.UpperNodeName' with upper config'>
        <Putout 2 '    '<ConvertPrefal e.UpperConf>>
        <Putout 2>
        <Putout 2 '  Generalized Pattern: '>
        <Putout 2 '    '<ConvertPrefal e.CheckedPattern>>
        <Putout 2 '  Generalized MGUs: '<AddNewLines e.MGUs>>
        <Putout 2 '  Generalized Equations: '<AddNewLines e.EquationsFromMerging e.Pos e.Neg>>
        <Putout 2 '********************************************************************************'>
        <Putout 2>
        (Generalized 
            t.SuccessorName 
            (<Put 2 Looped To t.UpperNodeName With e.CheckedSubs and (Generic e.Pos e.EquationsFromMerging)(Negative e.Neg)>) 
        <ExtractStackAndConf e.CheckedPattern>
        <GatherChildrenInfo  (/* EMPTY */) (/* EMPTY */) 
            <GenerateChildrenOfGenNode <SortNegPosEqs (e.EquationsFromMerging)()> t.SuccessorName 1
            e.Assignments
            >
        >
        );
/* 2. Обобщение сверху. */
    t.SuccessorName t.UpperNodeName (e.UpperEqs)(e.LowerEqs)(e.UpperConf)(e.Pattern)(e.MGUs)(e.EquationsFromMerging)
    , <SplitMGUs 0 e.MGUs> : e.Assignments
    , <DeleteTrivialSubs (e.Assignments)()e.Pattern> : (e.CheckedMGUs) e.CheckedPattern
    , <GenerateNewEquations ()()(e.UpperEqs)(e.LowerEqs)(e.Pattern)e.MGUs> : (e.Pos)(e.Neg)
        =
        <Putout 2 '================================================================================='>
        <Putout 2 '  GENERALIZED UPWARDS: 't.SuccessorName' and 't.UpperNodeName' with upper config'>
        <Putout 2 '    '<ConvertPrefal e.UpperConf>>
        <Putout 2>
        <Putout 2 '  Generalized Pattern: '>
        <Putout 2 '    '<ConvertPrefal e.CheckedPattern>>
        <Putout 2 '  Generalized MGUs: '<AddNewLines e.MGUs>>
        <Putout 2 '  Generalized Equations: '<AddNewLines e.EquationsFromMerging e.Pos e.Neg>>
        <Putout 2>
        <Putout 2 '*********************************************************************************'>
        <Putout 2>
        (Generalized t.UpperNodeName (UpperGeneralization With ((Generic e.EquationsFromMerging e.Pos)(Negative e.Neg))) <ExtractStackAndConf e.CheckedPattern>
        <GatherChildrenInfo  (/* EMPTY */) (/* EMPTY */) 
            <GenerateChildrenOfGenNode (e.EquationsFromMerging e.Pos)(e.Neg) t.UpperNodeName 1
                e.Assignments
            >
        >
        );
}

MayBeEmpty {
    (t.sort e e.data) = 'T';
    t.Other = 'F';
}

SortNegPosEqs {
    (e.PosEqs (Not t.Clash) e.Other)(e.Neg)
        = <SortNegPosEqs (e.PosEqs e.Other)(e.Neg (OR ('T')t.Clash))>;
    (e.Pos)(e.Neg) = (e.Pos)(e.Neg); 
}

NegativeLinear {
    (par t.type t.name) e.N1 (OR (s.Log)(((par t.type t.name)) to (e.1 t.Term e.2))) e.N2
    , <MayBeEmpty t.Term> : 'F'
    , <IsInStructure t.type t s> :
        {'F'
            = (OR (s.Log)(((par t.type t.name)) to (e.1 t.Term e.2))) 
                <NegativeLinear (par t.type t.name) e.N2>;
        'T'
        , e.1 e.2 : 
            {t.s e.x
                = <NegativeLinear (par t.type t.name) e.N2>;
            /* EMPTY */
                = (OR 
                    ('D')
                    (((par t.type t.name))
                        to 
                        ((var e (t.Term <FreshIndex 'vare_ind'>)) t.Term (var e (t.Term <FreshIndex 'vare_ind'>))))
                    )<NegativeLinear (par t.type t.name) e.N2>;
            };
        };
    t.par e.Other = /* EMPTY */;
}

StringTypisation {
    (e.CurrGram)(e.UpperGramm)(e.LowerGramm)(assign (par e t.name)(e.Expr1)(e.Expr2)) e.OtherMGUs
    , <LogAnd <StringType (e.UpperGramm)e.Expr1><StringType (e.LowerGramm)e.Expr2>>
    : {
        'T' = <StringTypisation (e.CurrGram (String (par e t.name)))(e.UpperGramm)(e.LowerGramm)e.OtherMGUs>;
        'F' = <StringTypisation (e.CurrGram)(e.UpperGramm)(e.LowerGramm)e.OtherMGUs>;
    };
    (e.CurrGram)(e.UpperGramm)(e.LowerGramm) /* NO MORE MGUs */ = e.CurrGram; /*Output syntax: (String (par e t.name))* */
}

StringType {
    (e.Grammar)s.X e.Y = <StringType (e.Grammar)e.Y>;
    (e.Grammar)(par s t.name) e.Y = <StringType (e.Grammar)e.Y>;
    (e.Grammar)(par e t.name) e.Y
    , e.Grammar
    : {
        e.G1 (String (par e t.name)) e.G2 = <StringType (e.Grammar) e.Y>;
        e.NotContainingStringType = 'F';
    };
    (e.Grammar) /* EMPTY */ = 'T';
    (e.Grammar) t.Other e.Y = 'F';
}

/* Переменная называется плавающей, если:
 1. Это t-переменная, не встречающаяся больше нигде в образцах данного блока, соседствующая с неповторной е-переменной. 
 2. Это s-переменная, не встречающаяся больше нигде в образцах данного блока, соседствующая с неповторной е-переменной,
    причем условие (не)-сопоставления с образцом ставится для параметра типа строка. 
    
    Положение таких переменных нормализуется, то есть со стороны, отличной от той, где они соседствуют со свободной е-переменной,
    добавляется еще одна е-переменная.
    Пример: e.x s.y нормализуется до e.x s.y e.z.
    s.y1 e.x s.y2 A - до e.x1 s.y1 e.x s.y2 e.x2 A.
    s.y s.z e.x s.z - до s.y s.z e.x s.z.
    */

/* (assign (e.pardata)(e.Val1)(e.Val2))^* => (AreEqual ('F')(e.1)(e.2)) */
GenerateNewEquations {
    (e.GenEqs)(e.GenNeqs)(e.UpperEqs)(e.LowerEqs)(e.Pattern) e.MGUs1 (assign (par e t.name)()(e.Expr))e.MGUs2 
    , <IfConstant e.Expr> : 'T'
    , <WordRoot e.Expr> : e.Root
    , (AreEqual ('F')((par e t.name) e.Root)(e.Root (par e t.name))) : t.NewEq
    , (OR ('D')
            (((par e t.name)) to 
            (<GenerateFiniteCondition <CountLength e.Expr>>))
        ) : t.NewNeq
        =
        <GenerateNewEquations (e.GenEqs t.NewEq)(e.GenNeqs)(e.UpperEqs)(e.LowerEqs)(e.Pattern) e.MGUs1 e.MGUs2>;
    
    (e.GenEqs)(e.GenNeqs)(e.UpperEqs)(e.LowerEqs)(e.Pattern)e.MGUs1 (assign (par e t.name)()((par t.type t.name2)))e.MGUs2
    , e.LowerEqs : e.L1 (Negative e.LNeg) e.L2
    , <NegativeLinear (par t.type t.name2) e.LNeg > : e.LinearNeg
    , <SubstituteInNegative ((assign (par t.type t.name2)((par e t.name)))) e.LinearNeg> : e.NewLNeg
    , <IfThenElse
        <IsInStructure t.type t s>
        ((OR ('D')
            (((par e t.name)) to 
            (<GenerateFiniteCondition 1>))
        ))
        /* EMPTY */
    > : e.NewNeg
    , <IfThenElse 
        <IsInStructure (par t.type t.name2) e.Pattern /* e.MGUs1 e.MGUs2 */>
        ((AreEqual ('F')((par e t.name) (par t.type t.name2))((par t.type t.name2)(par e t.name))))
        /* EMPTY */
    > : e.NewEq
        =
        <GenerateNewEquations (e.GenEqs e.NewEq)(e.GenNeqs e.NewLNeg)(e.UpperEqs)(e.LowerEqs)(e.Pattern) e.MGUs1 e.MGUs2>;

    (e.GenEqs)(e.GenNeqs)(e.UpperEqs)(e.LowerEqs)(e.Pattern)e.MGUs1 (assign (par e t.name)()(e.HighlyParameterized))e.MGUs2
    , e.LowerEqs : e.L1 (Negative e.LNeg) e.L2
    , <GetNewNegativesFromLin (par e t.name)(e.LNeg)(e.LNeg)e.HighlyParameterized> : e.NewNeg
    , <GetNewEndmarkNegatives (par e t.name)(e.HighlyParameterized)(e.LNeg)e.NewNeg> : e.EndNeg
        =
        <GenerateNewEquations (e.GenEqs)(e.GenNeqs e.NewNeg e.EndNeg)(e.UpperEqs)(e.LowerEqs)(e.Pattern) e.MGUs1 e.MGUs2>;
        
    (e.GenEqs)(e.GenNeqs)(e.UpperEqs)(e.LowerEqs)(e.Pattern) e.MGUs1 (assign (par e t.name)((par e t.name1))(e.HighlyParameterized))e.MGUs2
    , e.UpperEqs : e.U1 (Negative e.UNeg) e.U2 (Generic e.UGen)
    , e.LowerEqs : e.L1 (Negative e.LNeg) e.L2 (Generic e.LGen)
    , <NegativeLinear (par e t.name1) e.UNeg> : e.LinNeg
    , <GetNewNegativesFromLin (par e t.name)(e.LinNeg)(e.LNeg)e.HighlyParameterized> : e.NewNeg
    , <GetNewCommuting (par e t.name)((par e t.name1))(e.UGen)(e.HighlyParameterized)(e.LGen)> : e.NewCommute
        = <GenerateNewEquations (e.GenEqs e.NewCommute)(e.GenNeqs e.NewNeg)(e.UpperEqs)(e.LowerEqs)(e.Pattern) e.MGUs1 e.MGUs2>;        
 /*   
    (e.GenEqs)(e.GenNeqs)(e.UpperEqs)(e.LowerEqs)(e.Pattern) e.MGUs1 (assign (par e t.name)((par e t.name1))(e.0(par e t.name2)e.1))e.MGUs2
    , e.0 e.1 : t.x e.xx
    , <IfBounded e.0 e.1> : 'T' 
    , e.UpperEqs : e.U1 (Negative e.UNeg) e.U2
    , e.LowerEqs : e.L1 (Negative e.LNeg) e.L2
    , <FiniteCounter (par e t.name2) e.LNeg> : s.2
    , <IfThenElse
        <LogAnd 
            <AllPositive
                <FiniteCounter (par e t.name1) e.UNeg>
                s.2>
            <MyIfNotLess <CurrentIndex 'MaxConst'><MyAdd s.2 <CountLength e.xx>>>
            >
        
         ((OR ('D')(((par e t.name)) to (<GenerateFiniteCondition <MyAdd s.2 <CountLength t.x e.xx>>>))))
        /* EMPTY */ 
/*    > : e.NewNeg
    , ((par e t.name) to (e.0(par e t.name2)e.1)) : t.NotNegClash
    , <SetIntersect
        (<NotCondition t.NotNegClash e.UNeg>)(<NotCondition t.NotNegClash e.LNeg>)
    > : (e.OtherNewNeg)
        = 
        <GenerateNewEquations (e.GenEqs)(e.GenNeqs e.NewNeg e.OtherNewNeg)(e.UpperEqs)(e.LowerEqs)(e.Pattern) e.MGUs1 e.MGUs2>;*/
    (e.GenEqs)(e.GenNeqs)(e.UpperEqs)(e.LowerEqs)(e.Pattern) e.MGUs1 (assign (par e t.name)(e.Parameterized1 (par e t.name1)e.Parameterized2)
        (e.HighlyParameterized))e.MGUs2
    , e.UpperEqs : e.U1 (Negative e.UNeg) e.U2
    , e.LowerEqs : e.L1 (Negative e.LNeg) e.L2
    , <NegativeLinear (par e t.name1) e.UNeg> : e.LinNeg
    , <GetNewNegativesFromLin (par e t.name)(e.LinNeg)(e.UNeg)e.Parameterized1 (par e t.name1)e.Parameterized2> : e.AuxNeg
    , <GetNewNegativesFromLin (par e t.name)(e.AuxNeg)(e.LNeg)e.HighlyParameterized> : e.NewNeg
        = <GenerateNewEquations (e.GenEqs)(e.GenNeqs e.NewNeg)(e.UpperEqs)(e.LowerEqs)(e.Pattern) e.MGUs1 e.MGUs2>;        

    (e.GenEqs)(e.GenNeqs)(e.UpperEqs)(e.LowerEqs)(e.Pattern) e.MGU = (e.GenEqs)(<NegativeCleaning e.GenNeqs>);
}

GetNewCommuting {
    (par e t.name)((par e t.name1))(e.UGen)(e.HighlyParameterized)(e.LGen)
    , e.UGen : (AreEqual e.Log ((par e t.name1) e.Expr)(e.Expr (par e t.name1)))
        = <GetNewCommuting Started (e.Expr)(par e t.name)(e.HighlyParameterized)(e.LGen)>;
    (par e t.name)((par e t.name1))(e.UGen)(e.HighlyParameterized)(e.LGen) = ;
    Started (e.Expr)(par e t.name)(e.Expr e.HighlyParameterized)(e.LGen)
        = <GetNewCommuting Started (e.Expr)(par e t.name)(e.HighlyParameterized)(e.LGen)>;
    Started (e.Expr)(par e t.name)((par e t.name1) e.HighlyParameterized)(e.LGen)
    , e.LGen : e.LGen1 (AreEqual (s.Log) ((par e t.name1) e.Expr)(e.Expr (par e t.name1))) e.LGen2
        = <GetNewCommuting Started (e.Expr)(par e t.name)(e.HighlyParameterized)(e.LGen)>;
    Started (e.Expr)(par e t.name)( )(e.LGen) = (AreEqual ('F')((par e t.name)e.Expr)(e.Expr(par e t.name)));
    Started (e.Expr)(par e t.name)(e.HighlyParameterized)(e.LGen) = ;
}

$ENTRY NegativeCleaning {
    e.1 t.1 e.2 t.1 e.3 = <NegativeCleaning e.1 t.1 e.2 e.3>;
    e.1 (OR (s.Log) e.21 t.Clash e.22) e.2 (OR (s.Log2) t.Clash) e.3
        = <NegativeCleaning e.1 e.2 (OR (s.Log2) t.Clash) e.3>;
    e.1 (OR (s.Log2) t.Clash) e.2 (OR (s.Log) e.21 t.Clash e.22) e.3
        = <NegativeCleaning e.1 (OR (s.Log2) t.Clash)e.2 e.3>;
    e.1 (OR (s.Log)) e.2 = <NegativeCleaning e.1 e.2>;
    e.Z = e.Z;
}
/* ВВЕСТИ ДОПОЛНИТЕЛЬНЫЕ КОНЦЕВЫЕ УСЛОВИЯ!!!! */
GetNewEndmarkNegatives { 
    t.par (e.Expression)(e.LNeg)(OR (s.Log) ((t.par) to ((var e t.name1) e.Const t.2 t.1 (var e t.name2)))) e.Other
    , <IfBounded e.Const t.2 t.1> : 'T'
    , <GenerateFreshPRTC ((e.Expression) to ((var e t.name1) e.Const t.2))> : t.NegativePRTC
    , <AddPRTCNegativeInfo t.NegativePRTC e.LNeg> : t.NPRTC1
    , <Putout 1 'Driving GENERALIZING ENDMARK negative clash No. '<FreshIndex 'prtc_ind'>><Putout 1 ((e.Expression) to ((var e t.name1) e.Const t.2))> : 
    , <Drive 'T' ( ) <ClashLeft 'T' 0 t.NPRTC1>>
        : { 
            /* EMPTY */
                = (OR ('T')((t.par) to ((var e t.name1) e.Const t.2)))
                <GetNewEndmarkNegatives t.par (e.Expression)(e.LNeg)(OR (s.Log)((t.par) to ((var e t.name1) e.Const t.2 (var e t.name2)))) e.Other>;
            e.PRTCsWithRestrictions
                = <GetNewEndmarkNegatives t.par (e.Expression)(e.LNeg)(OR (s.Log)((t.par) to ((var e t.name1) e.Const t.2 (var e t.name2)))) e.Other>;
            };
    t.par (e.Expression)(e.LNeg) t.SomeOtherNegative e.Other =<GetNewEndmarkNegatives t.par (e.Expression)(e.LNeg) e.Other>;
    t.par (e.Expression)(e.LNeg) = ;
}

/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

GetNewNegativesFromLin {
    t.ThisPar((OR (s.Log)((t.par) to (e.Pattern))) e.TheseNeg)(e.AllNeg) e.Expr
    , <GenerateFreshPRTC ((e.Expr) to (e.Pattern))> : t.NegativePRTC
    , <AddPRTCNegativeInfo t.NegativePRTC e.AllNeg> : t.NPRTC1
    , <Putout 1 'Driving GENERALIZING negative clash No. '<FreshIndex 'prtc_ind'>> : 
    , <Drive s.Log ( ) <ClashLeft s.Log 0 t.NPRTC1>>
        : { 
            /* EMPTY */
                = (OR (s.Log)((t.ThisPar) to (e.Pattern)))<GetNewNegativesFromLin t.ThisPar(e.TheseNeg)(e.AllNeg)e.Expr>;
            e.PRTCsWithRestrictions
                = <GetNewNegativesFromLin t.ThisPar(e.TheseNeg)(e.AllNeg)e.Expr>;
            };
    t.ThisPar(t.ComplexNegative e.TheseNeg)(e.AllNeg)e.Expr
        = <GetNewNegativesFromLin t.ThisPar (e.TheseNeg)(e.AllNeg)e.Expr>;
    t.ThisPar (/* EMPTY */)(e.AllNeg)e.Expr
        = /* EMPTY */;
}

WordRoot {
    t.1 e.2 e.3
    , t.1 e.2 e.3 : e.3 t.1 e.2
        = t.1 e.2;
}

NotCondition {
    ((par e t.name) to (e.Finite01 (par e t.newname)e.Finite02))
    e.1 (OR (s.Log)(((par e t.name)) to ((var e t.freeName0) e.Finite2 (var e t.freeName1)))) e.2
    , <IfBounded e.Finite2> : 'T'
    , <NoClash e.Finite01 (par e t.newname)e.Finite02 (e.Finite2)> : 'T'
         = (OR (s.Log)(((par e t.name)) to ((var e t.freeName0)e.Finite2(var e t.freeName1)))) 
         <NotCondition ((par e t.name) to (e.Finite01 (par e t.newname)e.Finite02)) e.2>;
    (e.Cond) e.Other = /* EMPTY */;
}

NoClash {
    e.1 (par e t.newname) e.2 (e.3)
    , e.1 e.2 : e.01 (par e.pardata) e.02
        = 'F';
    e.1 e.2 e.3 (e.2) = 'F';
    t.1 e.1 (par e e.data) e.3 (e.2 t.1 e.1) = 'F';
    e.1 (par e e.data) t.2 e.3 (t.2 e.3 e.2) = 'F';
    e.Z = 'T';
    }

AllPositive {
 e.1 Null e.2 = 'F';
 e.Z = 'T';
}

FiniteCounter {
    (par e t.name)
    (OR (s.Log)(((par e t.name)) to ((var e t.freeName0)(var t t.freeName1)e.Z))) e.OtherNeg
        = <FiniteCounter Started 1 ((par e t.name) e.OtherNeg) e.Z>;
    (par e t.name) t.Other e.Z = <FiniteCounter (par e t.name) e.Z>;
    (par e t.name) /* EMPTY */ = Null;
    Started s.Counter (e.SavedData)(var e t.name)
    ,  <MyMax s.Counter <Add <CurrentIndex 'MaxConst'> 1>> :
        { s.Counter = Null;
          s.Other = s.Counter;
        };
    Started s.Counter (e.SavedData)(var e t.name)(var t t.name1) e.Z
        = <FiniteCounter Started <Add s.Counter 1> (e.SavedData) e.Z>;
    Started s.Counter (e.SavedData)e.Other = <FiniteCounter e.SavedData>;
}

GenerateFiniteCondition {
    Null = ;
    0 = (var e <FreshIndex 'vare_ind'>)(var t <FreshIndex 'vare_ind'>)(var e <FreshIndex 'vare_ind'>);
    s.Other = (var e <FreshIndex 'vare_ind'>)(var t <FreshIndex 'vare_ind'>)<GenerateFiniteCondition <Sub s.Other 1>>;
}

/*
    Проверка, входит ли параметр в выражение.
   (par e.pardata)[Expression] => s.Log 
*/

IsInStructure {
    t.par e.1 t.par e.2 = 'T';
    t.par e.1 (assign t.par1 (e.val1)) e.2 = <IsInStructure t.par e.1 t.par1 e.val1 e.2>;
    t.par e.1 (AreEqual ((s.Log)(e.MSet1)(e.Val1))((s.Log2)(e.MSet2)(e.Val2))) e.2 
        =  <IsInStructure t.par e.1 e.Val1 e.Val2 e.2>;
    t.par e.1 (AreEqual (s.Log)(e.Val1)(e.Val2)) e.2 = <IsInStructure t.par e.1 e.Val1 e.Val2 e.2>;
    t.par e.1 ('*' e.3) e.2 = <IsInStructure t.par e.1 e.3 e.2>;
    t.par e.1 (call t.fname (args (arg e.Arg))) e.2 = <IsInStructure t.par e.1 e.Arg e.2>;
    t.par e.Z = 'F';
}

/* Пока заглушка. */
DeleteTrivialSubs {
/*
    	(e.subs1 (assign (par t.type t.newname)((par t.type t.oldname))) e.subs2)(e.Asgnts) e.Pattern = 
		<DeleteTrivialSubs 
			(e.subs1 e.subs2)
			(<Substitute ((assign (par t.type t.newname)((par t.type t.oldname)))) e.Asgnts>)
			<Substitute ((assign (par t.type t.newname)((par t.type t.oldname)))) e.Pattern>
		>; 
*/

    (e.asgnts)(/* EMPTY */) e.Pattern = (e.asgnts)e.Pattern;
    (e.asgnts) (e.subs)e.Pattern = (e.subs) e.Pattern;
}

/*
    Куски, обобщенные до е-выражений, выделяются в дочерние узлы (Форматирующая функция типа Zip).
   ([NewAssignment]^*)([Node]^*)([assignment][Node])^* =>([NewAssignment]^*)([Node]^*)
*/
GatherChildrenInfo {
    (e.assignments)(e.children) = (e.assignments)(e.children);
    (e.assignments)(e.children)((assign (par e.data)t.Val)(Node t.Status t.Name e.NodeData))e.others
     = <GatherChildrenInfo 
         (e.assignments (t.Name(assign (par e.data) t.Val)))
         (e.children (Node t.Status t.Name e.NodeData))
         e.others
        >;
}

/*
   */
GenerateChildrenOfGenNode {
/*1. Все дети по let порождены. */
    (e.NewEquations)(e.NegEquations) t.UpperNodeName t.Counter = /* EMPTY */;
/* 2. Очередной дочерний узел порождается: в нем нет сужений, let-выражений, есть только стек и обшая конфигурация. */
/*
    	(e.NewEquations) (e.UpperNodeName) t.Counter (assign (par e.pardata)(e.Val))e.Others,
        <GenerateNewNode (e.UpperNodeName t.Counter)> : t.BlankNode,
        <PutNodeNewEqsToOld <PutNodeNewEqs <PutNodeLets t.BlankNode (par e.pardata)> e.NewEquations>> : t.NewChildNode,
        <ExtractStackAndConf e.Val> : (e.ChildConf)(e.ChildStack) =
            <CheckForCalls
                ((assign (par e.pardata) (e.Val))
                <PutNodeStack <PutNodeConfig t.NewChildNode e.ChildConf> e.ChildStack>)
            >
            <GenerateChildrenOfGenNode (e.NewEquations)(e.UpperNodeName) <MyInc t.Counter> e.Others>; 
*/
    (e.NewEquations)(e.NegEquations) (e.UpperNodeName) t.Counter (assign (par e.pardata)(e.Val))e.Others
    , <GenerateNewNode (e.UpperNodeName t.Counter)> : t.BlankNode
    , <PutNodeNegEqs <PutNodeNewEqsToOld <PutNodeNewEqs t.BlankNode e.NewEquations>> e.NegEquations> : t.NewChildNode
    , <ExtractStackAndConf e.Val> : (e.ChildConf)(e.ChildStack)
        = <CheckForCalls
            ((assign (par e.pardata) (e.Val))
            <PutNodeStack <PutNodeConfig t.NewChildNode e.ChildConf> e.ChildStack>)
        >
        <GenerateChildrenOfGenNode (e.NewEquations)(e.NegEquations)(e.UpperNodeName) <MyInc t.Counter> e.Others>;
}

/* Проверка, не пуст ли стек у вновь порожденного узла. */
CheckForCalls {
/* 1. Стек пуст => неразложенная конфигурация является финальной конфигурацией. */
/*   ((assign e.assignment)(Node e.Node (e.Data()(e.Stack)))) = ((assign e.assignment)); */
/* 2. Стек непуст => оставляем все как есть. */
    e.Z = e.Z;
}

/*
    Дано выражение. Построить стек, соответствующий этому выражению, и это же выражение без внешних объектных термов.
   [Expression] => ([Expression])[Stack]
*/
ExtractStackAndConf {
    e.Value
    , <YieldDecomposition ((assign (var l (0))(e.Value)))> : e.Stack
        = (<FoldStackIntoConf e.Stack>)(e.Stack);
}

/*
    Расщепление подстановок в обобщении.
   s.Flag (assign t.Name ([FirstExpr])([SecondExpr]))^* => (assign t.Name ([Expr]))^*
   s.Flag=0 => выбираем первое значение в подстановке;
   s.Flag=1 => выбираем второе.
*/
SplitMGUs {
    s.Flag = /* EMPTY */;
    0 (assign (e.pardata)(e.Val1)(e.Val2)) e.MGUs = (assign (e.pardata)(e.Val1))<SplitMGUs 0 e.MGUs>;
    1 (assign (e.pardata)(e.Val1)(e.Val2)) e.MGUs = (assign (e.pardata)(e.Val2))<SplitMGUs 1 e.MGUs>;
}


/*
    Преобразование слоистого стека в список конечных списков имён функций.
   ((t.FunName^+)^*)((assign (var l t.id)(e.Val))^+)^* => (t.FunName^+)^* 
*/
StackForm4TurRel {
/* 1. Весь стек обработан, на верхнем уровне вызовов не было. */
    (e.NewForm)(/* EMPTY */) = e.NewForm;
/* 2. Весь стек обработан, на верхнем уровне вызовы имелись. */
    (e.NewForm)(e.NewTerm) = e.NewForm;
/* 3. Текущий слой стека исчерпан без формирования нового терма -- списка вызовов функций (на слое были только объектные выражения). */
    (e.NewForm)(/* EMPTY */)(/* EMPTY */)e.OtherLevels = <StackForm4TurRel (e.NewForm ((Constant 0)))()e.OtherLevels>;
/* 4. Текущий слой стека исчерпан, сформирован список вызовов функций в нем. Помещаем этот список в плоскую форму и переходим к другому слою. */
    (e.NewForm)(e.NewTerm)(/* EMPTY */)e.OtherLevels = <StackForm4TurRel (e.NewForm (e.NewTerm))()e.OtherLevels>;
/* 5. Вставляем имя функции в терм, перечисляющий все имена вызванных функций на слое. */
    (e.NewForm)(e.NewTerm)((assign (var l t.name)((call (t.fname t.timestamp) e.call)))e.ThisLevel)e.OtherLevels
        = <StackForm4TurRel (e.NewForm)(<InsertNewFunName (t.fname t.timestamp) e.NewTerm>)(e.ThisLevel)e.OtherLevels>;
/* 6. Если очередная стековая переменная не есть вызов, игнорируем ее. */
    (e.NewForm)(e.NewTerm)((assign (var l t.name)(e.NotCall))e.ThisLevel)e.OtherLevels
        = <StackForm4TurRel (e.NewForm)(e.NewTerm)(e.ThisLevel)e.OtherLevels>;
}

/*
    Вставка имени функции в список, если его там еще не было.
   t.NewName t.name^* => t.name^*
*/
InsertNewFunName {
    (t.fname t.timestamp1) e.Names1 (t.fname t.timestamp2) e.Names2 = e.Names1 (t.fname t.timestamp1) e.Names2;
    t.fname e.Names = e.Names t.fname;
}


/*
   Проверка, вкладывается ли информация узла в информацию о другом узле 
   по композиции отношений на стеках, уравнениях и термах. 
   ((e.Equations)(e.Config)(e.Stack))((e.Equations)(e.Config)(e.Stack)) => s.Log
*/
EmbeddingConfs {
/*
	((e.Equations)(e.Config)(e.Stack))((e.Equations2)(e.Config2)(e.Stack2)) =
		<LogAnd <SingleGapFHE (e.Stack)e.Stack2>
			<LogAnd 
				<HomeomorphicEmb (e.Config)e.Config2>
				<FHE4AllEqs 
					(<CurrentIndex 'EqGen_Complex'>)
					(e.Equations)(e.Equations2)
				>
			>
		>; 
*/
    ((e.Eqs)(e.Config)(e.Stack))((e.Eqs2)(e.Config2)(e.Stack2))
    , <SingleGapFHE (<Put 1 <StackForm4TurRel ()()e.Stack>>)
        <Putout 1 ' and '>
        <Put 1 <StackForm4TurRel ()()e.Stack2>>> : 
        { 'F' = 'F';
        s.Depth
        , <HomeomorphicEmb (<Put 1 e.Config>)<Putout 1 ' and '><Put 1 e.Config2>> :
            {'F' = 'F';
            'T'
            , <ReplaceStackLevelWithNewPar (s.Depth)(e.Stack)> : (e.asg)(e.Bottom1)
            , <ReplaceStackLevelWithNewPar (s.Depth)(e.Stack2)> : (e.asg2)(e.Bottom2)
                = s.Depth <HomeomorphicEmb (e.Bottom1)e.Bottom2>;
            };
        };
}

/*
    Проверка на одноразрывное отношение в строке.
   Начинаться обе строки должны с одного и того же терма.
   ([Term]^*)[Term]^* => s.Log 
*/

SingleGapFHE {
    (((t.1 t.TS1) e.1) e.11) ((t.1 t.TS2) e.21) e.22 = <TurRelat (0)(e.11) e.22>; 
    e.X = 'F';
}

TurRelat {
    (s.Depth)(e.1 t.1) e.2 t.1 = <TurRelat (s.Depth)(e.1) e.2>;
    (s.Depth)(e.1) e.2 = <TurRelatAux (s.Depth)(e.1) e.2>;
}

TurRelatAux {
    (s.Depth)(/* EMPTY */) e.2 = s.Depth;
    (s.Depth)(((t.1 t.TS1) e.11) e.1)((t.1 t.TS2) e.12) e.2 = <TurRelatAux (<MyInc s.Depth>)(e.1)e.2>;
    (s.Depth)(e.1) e.2 = 'F';
}

/*
    Проверка, вкладывается ли выражение [Expr1] в выражение [Expr2] по Крускалу.
   Это гомеоморфное вложение примитивное --- оно не различает имена параметров.
   ([Expr1])[Expr2] => s.Log 
*/

$ENTRY HomeomorphicEmb {
    (/* EMPTY */)e.2 = 'T';
    (e.1) = 'F';
/* 0. Равное вкладывается в равное. */
    (t.1)t.1 = 'T';
/* 1. Два параметра или две переменные одного типа всегда вкладываются друг в друга. */
    ((t.sort s.type e.par1))(t.sort s.type e.par2)
        , par var weval : e.1 t.sort e.2 = 'T';
/* 2. вызов f вкладывается в вызов f, если аргумент вкладывается в аргумент. */
    ((call t.fdata1 (args (arg e.call1))))(call t.fdata2 (args (arg e.call2)))
    , t.fdata1 : (t.fname t.TS1)
    , t.fdata2 : (t.fname t.TS2)
        = <HomeomorphicEmb (e.call1)e.call2>;
/* 4. выражение, не имеющее вызова f во внешней части, вкладывается в вызов f, если вкладывается в его аргумент. */
    (e.Expr1)(call t.fname2 (args (arg e.call2))) 
        = <HomeomorphicEmb (e.Expr1) e.call2>;
/* 5. выражения в скобках. */
    (('*' e.11))('*' e.21) = <HomeomorphicEmb (e.11)e.21>;

/*
   6. Все прочее - выражение в скобках
   вкладывается, если вкладывается либо в скобки, либо во внешнюю часть. 
*/

    (e.11)('*' e.21)
        = <HomeomorphicEmb (e.11)e.21>;
/*
   7. Неравное не вкладывается в неравное. 
   Здесь t.2 --- не вызов (см. пр-е 4), не скобочное выражение (см. пр-е 6). 
*/
    (t.1 e.1) t.2 = 'F';
/*
   8. терм + что-то ещё - терм+что-то ещё вкладываются либо последовательно;
   либо все вместе в терм, либо все вместе в что-то ещё. 
*/
    (t.1 e.otherConf1)t.2 e.otherConf2
        = <KruskalAux2 
            <HomeomorphicEmb (t.1 e.otherConf1) t.2>
            (t.1 e.otherConf1)t.2 e.otherConf2
        >;
} /* HomeomorphicEmb */


/* Вспомогательная функция HomeomorphicEmb, имитирующая ленивое исполнение функции LogOr. Предложение 9. */
KruskalAux2 {
    'T'e.1 = 'T';
    'F'(t.1 e.otherConf1)t.2 e.otherConf2
        = <HomeomorphicEmb
            <IfThenElse 
                <HomeomorphicEmb (t.1)t.2>
                ((e.otherConf1)e.otherConf2) 
                (t.1 e.otherConf1) e.otherConf2
            >
        >;
}

/* s.Log (e.1)e.2 */
IfThenElse {
    'T'(e.1) e.2 = e.1;
    'F'(e.1) e.2 = e.2;
}

/*
    Проверка вложения по уравнениям.
   [Equation] ::= (AreEqual (([MultiSet])([Expression]))(([MultiSet])([Expression]))) 
   ([Card])([Equation]^*)([Equation]^*) => s.Log
   [Card] --- натуральное число или Inf.
*/
FHE4AllEqs {
/* 1. Все уравнения исчерпаны. */
    (t.EqGenComplexity)(/* EMPTY */)(e.Eqs2) = 'T';
/*
   2. Если уравнение в первом аргументе имеет сложность меньше или равную ограничивающей, 
   оно должно вкладываться в какое-нибудь уравнение во втором аргументе. 
*/
    (t.EqGenComplexity)((e.Equation1)e.OtherEqs1)(e.Eqs2)
    , <MyIfNotLess t.EqGenComplexity <EqGenComplexity e.Equation1>> :'T'
        = <LogAnd
            <HomeomorphicEmb4Equations ((e.Equation1))e.Eqs2>
            <FHE4AllEqs (t.EqGenComplexity)(e.OtherEqs1)(e.Eqs2)>
        >;
/* 3. Если уравнение в первом аргументе имеет более высокую сложность, его игнорируем. */
    (t.EqGenComplexity)((e.Equation1)e.OtherEqs1)(e.Eqs2)
        = <FHE4AllEqs (t.EqGenComplexity)(e.OtherEqs1)(e.Eqs2)>;
}

/*
    Проверка вложимости уравнения в группу уравнений.
   Выполняется, если уравнение вкладывается в какое-либо уравнение из группы гомеоморфно,
   причём либо левая часть в правую и наоборот, либо левая в левую и правая в правую.
   [Equation] [Equation]^* => s.Log
*/
HomeomorphicEmb4Equations {
    t.Eq  = 'F';
    t.Eq1 t.Eq2 e.OtherEqs
    , t.Eq1 : (AreEqual ((e.CompLHS1)(e.LHS1))((e.CompRHS1)(e.RHS1)))
    , t.Eq2 : (AreEqual ((e.CompLHS2)(e.LHS2))((e.CompRHS2)(e.RHS2)))
        = <LogOr
            <LogOr 
                <LogAnd
                    <HomeomorphicEmb (e.LHS1)e.LHS2>
                    <HomeomorphicEmb (e.RHS1)e.RHS2>
                >
                <LogAnd
                    <HomeomorphicEmb (e.RHS1)e.LHS2>
                    <HomeomorphicEmb (e.LHS1)e.RHS2>
                >
            >
            <HomeomorphicEmb4Equations t.Eq1 e.OtherEqs>
        >;
}

/*
    Функция вычисления сложности уравнения.
   Сложность уравнения --- это суммарное количество вхождений в него всех параметров.
   Здесь также считается, что если в уравнение входит строковая переменная (не параметр), оно имеет сложность Nat (Inf).
   Поэтому такие уравнения всегда игнорируются (упрощение!).
   [Equation] => [Card] 
*/


EqGenComplexity {
    (AreEqual (s.Log)(e.LHS)(e.RHS))
        = <MyAdd <SEGCompl e.LHS><SEGCompl e.RHS>>;
}

/*
    Функция вычисления сложности одной части уравнения.
   [MultiSet] => [Card]
*/
SEGCompl {
    /* EMPTY */ = <MyZero>;
    (weval e.Z) e.Other = Inf;
    (par e.Z) e.Rest = <MyAdd 1 <SEGCompl e.Rest>>;
    ('*'e.InBr) e.OutBr = <MyAdd <SEGCompl e.InBr><SEGCompl e.OutBr>>;
    t.Other e.Rest = <SEGCompl e.Rest>;
}

/*
    ([Pattern])((assign (e.Name) (ToUnify (e.1)(e.2)) => ([Pattern])((assign (e.Name) (ToUnify (e.1)(e.2))
   Самый первый вызов --- [Pattern] всегда e-параметр. 
*/

FindMaxContext {
/* 0. Обобщать больше нечего. Этой ситуации в программе быть не должно, выделена для теста! */
/*    (e.Pattern)((ToUnify ()())) = (e.Pattern)(); */

/* 1a. Полностью одинаковые термы слева образуют общий контекст. */
    (e.Pattern)((assign (e.Name)(ToUnify (t.1 e.1)(t.1 e.2))))
        = <FindMaxContext 
            (<Substitute ((assign (e.Name)(t.1 (e.Name)))) e.Pattern>)
            ((assign (e.Name)(ToUnify (e.1)(e.2))))
        >;
/* 1б. Полностью одинаковые термы справа образуют общий контекст. */
    (e.Pattern)((assign (e.Name)(ToUnify (e.1 t.1)(e.2 t.1))))
        = <FindMaxContext 
            (<Substitute ((assign (e.Name)((e.Name) t.1))) e.Pattern>)
            ((assign (e.Name)(ToUnify (e.1)(e.2))))
        >;
/* 2. Одинаковые вызовы функций, если кроме этих функций на данном уровне ничего нет, также образуют общий контекст. */
    (e.Pattern)((assign (e.Name)(ToUnify ((call t.fname (args (arg e.1))))((call t.fname (args (arg e.2)))))))
        = <FindMaxContext 
            (<Substitute ((assign (e.Name)((call t.fname (args (arg (e.Name))))))) e.Pattern>)
            ((assign (e.Name)(ToUnify (e.1)(e.2))))
        >;
/* 3. Во всех остальных случаях общего контекста нет. */
    (e.Pattern)(e.ToUnify) = (e.Pattern)(e.ToUnify);
}

/*
----------------------------------------------------------------------------------------------------------------------------
   Most Generic Unification для ассоциативных данных.
   
   [MGUSub] ::= (assign (par s.type t.name)([Expr1])([Expr2]))
   [ToUnify] ::= (assign t.Name (ToUnify ([Expr])([Epr])))
   
   ([Expr])([ToUnify]^*)([MGUSub]^*)
   =>
   ([Expr])([MGUSub]^*)
   
   1ый аргумент --- текущий вариант Most Generic Unification (шаблон).
   2ой аргумент --- список кусков --- параметров из первого аргумента, которые ещё нужно обобщить.
   3ий аргумент --- текущий набор порожденных подстановок.
-------------------------------------------------------------------------------------------------------------------------------
*/

$ENTRY MGUAssoc {
/* 1. Обобщать больше нечего. */
    (e.Pattern)()(e.MGUs)
    , <WeightMGU (0) e.MGUs> :
        {/* Nil = (False)(False); */
        e.1 = (e.Pattern)(e.MGUs);
        };
/* 2. Обобщаются равные выражения --- это выражение просто подставляется в шаблон вместо параметра. */
    (e.Pattern)(e.Other1 (assign (t.sort e t.Name)(ToUnify t.val t.val))e.Other)(e.MGUs)
        = <MGUAssoc (<Substitute ((assign (t.sort e t.Name)t.val)) e.Pattern>)(e.Other1 e.Other)(e.MGUs)>;
/* 3. Обобщаются термы, вызовы, параметры либо выражения в скобках --- передача управления MGUObject. */
    (e.Pattern)((assign (t.sort e t.Name)(ToUnify (t.Object1)(t.Object2)))e.Other)(e.MGUs)
    , <HomeomorphicEmb (t.Object1) t.Object2> : 'T'
        = <MGUAssoc
                <MGUObject (e.Pattern)((assign (t.sort e t.Name)(ToUnify (t.Object1)(t.Object2)))e.Other)
                    (e.MGUs)
                >
        >;
/* 4. Пустое выражение обобщается с непустым --- до e-выражения. */
    (e.Pattern)((assign (t.sort e t.Name)(ToUnify ()(e.Object)))e.Other)(e.MGUs)
        = <MGUAssoc 
            <IntroduceEMGU (<FindAllPredInPattern ()()(t.sort e t.Name)e.Pattern>)(assign (t.sort e t.Name)()(e.Object))(e.Pattern)(e.Other)(e.MGUs)>
        >;
/* 5. Выражение и терм обобщаются успешно, только если выражение вкладывается в этот терм. В этом случае они обобщаются до e-переменной. */
    (e.Pattern)((assign (t.sort e t.Name)(ToUnify (t.Object1 e.Expr1)(t.Object)))e.Other)(e.MGUs)
    , <HomeomorphicEmb (t.Object1 e.Expr1)t.Object> : 'T'
        = <MGUAssoc <IntroduceEMGU (<FindAllPredInPattern ()()(t.sort e t.Name)e.Pattern>)(assign (t.sort e t.Name)(t.Object1 e.Expr1)(t.Object))(e.Pattern)(e.Other)(e.MGUs)
            >>;
    (e.Pattern)((assign (t.sort e t.Name)(ToUnify (t.Object1 e.Expr1)(t.Object)))e.Other)(e.MGUs)
    , <HomeomorphicEmb (t.Object1 e.Expr1)t.Object> : 'F'
        = (False)(False); 
            
/* 4а. Пустое выражение обобщается с непустым --- до e-выражения. */
/*  (e.Pattern)((assign (par e t.Name)(ToUnify (e.Object)()))e.Other)
        (e.MGUs) = 
            <MGUAssoc <IntroduceEMGU (<FindAllPredInPattern ()()(par e t.Name)e.Pattern>)(assign (par e t.Name)(e.Object)())(e.Pattern)(e.Other)(e.MGUs)
            >>; 
*/

/* 6. Все остальные случаи: либо объекты обобщаются друг с другом, остальное друг с другом, либо объект + выражение со всем, другой объект - с пустым. */
    (e.Pattern)((assign (t.sort e t.Name)(ToUnify (t.Object1 e.Expr1)(t.Object2 e.Expr2)))e.Other)(e.MGUs)
    , <HomeomorphicEmb (t.Object1)t.Object2> : 'T'
        = <MinMGU
            (<MGUAssoc <ProceedMGU 
                (<FreshIndex <ClassIdentifier t.sort e>>)(<FreshIndex <ClassIdentifier t.sort e>>)
                (t.sort e t.Name)
                ((t.Object1)(t.Object2))
                ((e.Expr1)(e.Expr2))
                (e.Pattern)
                (e.Other)
                (e.MGUs)
            >>)
            (<MinMGU    
                (<MGUAssoc <ProceedMGU 
                    (<FreshIndex <ClassIdentifier t.sort e>>)(<FreshIndex <ClassIdentifier t.sort e>>)
                    (t.sort e t.Name)
                    (()(t.Object2))
                    ((t.Object1 e.Expr1)(e.Expr2))
                    (e.Pattern)
                    (e.Other)
                    (e.MGUs)
                >>)
                (<MGUAssoc <ProceedMGU 
                    (<FreshIndex <ClassIdentifier t.sort e>>)(<FreshIndex <ClassIdentifier t.sort e>>)
                    (t.sort e t.Name)
                    ((t.Object1 e.Expr1)(t.Object2))
                    (()(e.Expr2))
                    (e.Pattern)
                    (e.Other)
                    (e.MGUs)
                >>)
            >)
        >;
    (e.Pattern)((assign (t.sort e t.Name)(ToUnify (t.Object1 e.Expr1)(t.Object2 e.Expr2)))e.Other)(e.MGUs)
        = <MGUAssoc <ProceedMGU 
            (<FreshIndex <ClassIdentifier t.sort e>>)(<FreshIndex <ClassIdentifier t.sort e>>)
            (t.sort e t.Name)
            (()(t.Object2))
            ((t.Object1 e.Expr1)(e.Expr2))
            (e.Pattern)
            (e.Other)
            (e.MGUs)
        >>;
    (e.Pattern)(e.ToUnify)(e.MGUs) = (False)(False); 
}/* MGUAssoc */

/*
    Функция передачи построения обобщения другой функции.
   (t.ParName)(t.ParName)(par e t.Name)(([Expr1])([Expr2]))([Expr3])([Expr4])([ExprPattern])([ToUnify])([MGUSub]^*) =>
   ([Expr])([ToUnify]^*)([MGUSub]^*)
   Первые два имени --- два новых имени переменных, на которых разбивается третья.
*/
ProceedMGU {
/* 1. Передаем управление MGUObject. */
    (t.NewName1)(t.NewName2)(t.sort e t.Name)((t.Expr11)(t.Expr12))((e.Expr21)(e.Expr22))(e.Pattern)(e.ToUnify)(e.MGUs)
        = <MGUObject 
            (<Substitute ((assign (t.sort e t.Name)((t.sort e t.NewName1)(t.sort e t.NewName2))))e.Pattern>)
            (
                (assign (t.sort e t.NewName1) (ToUnify (t.Expr11)(t.Expr12)))
                (assign (t.sort e t.NewName2) (ToUnify (e.Expr21)(e.Expr22))) 
                e.ToUnify
            )
            (e.MGUs)
        >;
/* 1. Передаем управление IntroduceEMGU. */
    (t.NewName1)(t.NewName2)(t.sort e t.Name)((e.Expr11)(e.Expr12))((e.Expr21)(e.Expr22))(e.Pattern)(e.ToUnify)(e.MGUs)
        = <IntroduceEMGU 
            (<FindAllPredInPattern ()()(t.sort e t.Name)e.Pattern>)
            (assign (t.sort e t.NewName1)(e.Expr11)(e.Expr12))
            (<Substitute ((assign (t.sort e t.Name)((t.sort e t.NewName1)(t.sort e t.NewName2))))e.Pattern>)
            ((assign (t.sort e t.NewName2) (ToUnify (e.Expr21)(e.Expr22))) e.ToUnify)
            (e.MGUs)
        >;
/*   (t.NewName1)(t.NewName2)(par e t.Name)(e.E1)(e.E2)(e.Pattern)(e.ToUnify)(e.MGUs) = (False)()(False); */
}

/*
    Обобщение двух единичных термов.
   ([Expr])((assign (par e t.Name)([Term])([Term]))[ToUnify]^*)([MGUSub]^*) =>
   ([Expr])([ToUnify]^*)([MGUSub]^*)
*/
MGUObject {
/* 1. Обобщение двух равных термов --- просто подстановка терма вместо е-переменной. */
    (e.Pattern)((assign (t.sort e t.Name)(ToUnify (t.Val)(t.Val)))e.Other)(e.MGUs) 
        = (<Substitute ((assign (t.sort e t.Name)(t.Val)))e.Pattern>)
        (e.Other)
        (e.MGUs);

/* 2. Обобщение двух разных символов или s-параметров до s-параметра (4 случая). */
    (e.Pattern)((assign (t.sort e t.Name)(ToUnify (s.Sym1)(s.Sym2)))e.Other)(e.MGUs) 
        = <ProceedNewObjectMGU 
            (t.sort <FreshIndex <ClassIdentifier t.sort s>>)
            (e.Pattern)((assign (t.sort e t.Name)(ToUnify (s.Sym1)(s.Sym2)))e.Other)(e.MGUs)
        >;
    (e.Pattern)((assign (t.sort e t.Name)(ToUnify (s.Sym1)((t.sort s t.sname))))e.Other)(e.MGUs)
        = <ProceedNewObjectMGU 
            (t.sort s <FreshIndex <ClassIdentifier t.sort s>>)
            (e.Pattern)((assign (t.sort e t.Name)(ToUnify (s.Sym1)((t.sort s t.sname))))e.Other)(e.MGUs)
        >;
/*
    (e.Pattern)((assign (par e t.Name)(ToUnify ((par s t.sname))(s.Sym2)))e.Other)(e.MGUs) =
                    <ProceedNewObjectMGU 
                        (par s <FreshIndex 'pars_ind'>)
                        (e.Pattern)((assign (par e t.Name)(ToUnify ((par s t.sname))(s.Sym2)))e.Other)(e.MGUs)
                    >; 
*/

    (e.Pattern)((assign (t.sort e t.Name)(ToUnify ((t.sort s t.sname1))((t.sort s t.sname2))))e.Other)(e.MGUs) 
        = <ProceedNewObjectMGU 
            (t.sort s <FreshIndex <ClassIdentifier t.sort s>>)
            (e.Pattern)((assign (t.sort e t.Name)(ToUnify ((t.sort s t.sname1))((t.sort s t.sname2))))e.Other)(e.MGUs)
        >;
/* 3. Обобщение двух вызовов одинаковых функций до вызова функции. */
    (e.Pattern)((assign (par e t.Name)(ToUnify ((call (t.fname t.TS1) (args (arg e.Arg1))))((call (t.fname t.TS2) (args (arg e.Arg2))))))e.Other)(e.MGUs)
        = (<Substitute ((assign (par e t.Name)((call (t.fname <FreshIndex 'time_stamp'>) (args (arg (par e t.Name)))))))e.Pattern>)
        ((assign (par e t.Name)(ToUnify (e.Arg1)(e.Arg2)))e.Other)
        (e.MGUs);
/* 4. Обобщение двух выражений в скобках до выражения в скобках. */
    (e.Pattern)((assign (t.sort e t.Name)(ToUnify (('*' e.Expr1))(('*' e.Expr2))))e.Other)(e.MGUs)
        = (<Substitute ((assign (t.sort e t.Name)(('*' (t.sort e t.Name)))))e.Pattern>)
        ((assign (t.sort e t.Name)(ToUnify (e.Expr1)(e.Expr2)))e.Other)
        (e.MGUs);
/* 5. Вызов функции и что-то ещё обобщаются до e-параметра (2 случая). */
    (e.Pattern)((assign (par e t.Name)(ToUnify ((call e.call))(e.Expr2)))e.Other)(e.MGUs) 
        = <IntroduceEMGU 
            (<FindAllPredInPattern ()()(par e t.Name)e.Pattern>)
            (assign (par e t.Name)((call e.call))(e.Expr2))(e.Pattern)
            (e.Other)(e.MGUs)
        >;
    (e.Pattern)((assign (par e t.Name)(ToUnify (e.Expr1)((call e.call))))e.Other)(e.MGUs) 
        =
        <IntroduceEMGU 
            (<FindAllPredInPattern ()()(par e t.Name)e.Pattern>)
            (assign (par e t.Name)(e.Expr1)((call e.call)))(e.Pattern)
            (e.Other)(e.MGUs)
        >;
/* 6. е-параметр и что-то ещё обобщаются до e-параметра (2 случая). */
    (e.Pattern)((assign (t.sort e t.Name)(ToUnify ((t.sort e t.EName))(e.Expr2)))e.Other)(e.MGUs) 
        =
        <IntroduceEMGU 
            (<FindAllPredInPattern ()()(t.sort e t.Name)e.Pattern>)
            (assign (t.sort e t.Name)((t.sort e t.EName))(e.Expr2))(e.Pattern)
            (e.Other)(e.MGUs)
        >;
    (e.Pattern)((assign (t.sort e t.Name)(ToUnify (e.Expr1)((t.sort e t.EName))))e.Other)(e.MGUs) 
        =
        <IntroduceEMGU 
            (<FindAllPredInPattern ()()(t.sort e t.Name)e.Pattern>)
            (assign (t.sort e t.Name)(e.Expr1)((t.sort e t.EName)))(e.Pattern)
            (e.Other)(e.MGUs)
        >;
/* 7. Во всех прочих случаях обобщаемся до t-параметра. */
    (e.Pattern)((assign (t.sort e t.Name)(ToUnify (t.Obj1)(t.Obj2)))e.Other)(e.MGUs) 
        =
        <ProceedNewObjectMGU 
            (t.sort t <FreshIndex <ClassIdentifier t.sort t>>)
            (e.Pattern)
            ((assign (t.sort e t.Name)(ToUnify (t.Obj1)(t.Obj2)))e.Other)
            (e.MGUs)
        >;    
}/* MGUObject */

/*
    Обобщение до t- или s-параметра.
   (par t.type t.NewName)([Expr])([ToUnify2Objects][ToUnify]^*)([MGUSub]^*) => 
   ([Expr])([ToUnify]^*)([MGUSub]^*)
   
   t.type ::= t|s
*/
ProceedNewObjectMGU {
    (t.sort t.type t.NewName)(e.Pattern)((assign (t.sort e t.Name)(ToUnify (t.Obj1)(t.Obj2)))e.Other)(e.MGUs) 
        =
        <CheckRepeatedMGUs 
            (/* EMPTY */)(<Substitute ((assign (t.sort e t.Name)((t.sort t.type t.NewName))))e.Pattern>)
                (e.Other)
                (<DeleteMGU (t.sort e t.Name)e.MGUs> (assign (t.sort t.type t.NewName)(t.Obj1)(t.Obj2)))
        >;
}

/* Функция для трассировки. */
AAA { = ;}

/*
    Введение обобщения до е-переменной.
   Если эта e-переменная следует в шаблоне после другой e-переменной, следует их слить.
   (t.ParName^*)[MGUSub]([Expr])([ToUnify]^*)([MGUSub]^*) => 
   ([Expr])([ToUnify]^*)([MGUSub]^*)
*/
IntroduceEMGU {
/* КОСТЫЛЬ! Если нашлась повторная подстановка, стираем возможность сливать переменную. */
    ((e.Arbitrary1)(e.Arbitrary2))(assign (t.sort e t.Name)(e.Expr1)(e.Expr2))(e.Pattern)(e.Other)(e.MGUs)
    , e.MGUs : e.MGUs1 (assign (t.sort e t.OtherName)(e.Expr1)(e.Expr2)) e.MGUs2
        = <IntroduceEMGU ()(assign (t.sort e t.Name)(e.Expr1)(e.Expr2))(e.Pattern)(e.Other)(e.MGUs)>;
    /* 1. У е-параметра, который обобщаем, в шаблоне ровно 1 предшественник --- тоже е-параметр.
   Сливаем эти параметры, после чего проверяем подстановку на повторность. 
*/
    (((t.sort e t.Name2))(e.Post))(assign (t.sort e t.Name)(e.Expr1)(e.Expr2))(e.Pattern)(e.Other)(e.MGUs)
    , <PatternParameter (t.sort e t.Name2) e.Other> : 'F'
        = <CheckRepeatedMGUs ()<ConcatenateMGUs (1)
            <FindMGU (t.sort e t.Name2) e.MGUs>
            (assign (t.sort e t.Name)(e.Expr1)(e.Expr2))(e.Pattern)(e.Other)(<DeleteMGU (t.sort e t.Name2) e.MGUs>)
        >>;
    ((e.Pred)((t.sort e t.Name2)))(assign (t.sort e t.Name)(e.Expr1)(e.Expr2))(e.Pattern)(e.Other)(e.MGUs)
    , <PatternParameter (t.sort e t.Name2) e.Other> : 'F' 
        =
        <CheckRepeatedMGUs ()<ConcatenateMGUs (0)
            (assign (t.sort e t.Name)(e.Expr1)(e.Expr2))<FindMGU (t.sort e t.Name2) e.MGUs>(e.Pattern)(e.Other)
            (<DeleteMGU (t.sort e t.Name2) e.MGUs>)
        >>;
/* 2. Во всех других случаях просто проверяем новую подстановку на повторность и записываем в список ([MGUSub]^*) (последний аргумент). */
    (e.Arbitrary)(assign (t.sort e t.Name)(e.Expr1)(e.Expr2))(e.Pattern)(e.Other)(e.MGUs) 
        =
        <CheckRepeatedMGUs ()(e.Pattern)(e.Other)(<DeleteMGU (t.sort e t.Name) e.MGUs> (assign (t.sort e t.Name)(e.Expr1)(e.Expr2)))>;
}

PatternParameter {
    t.name e.ToUn1 (assign t.name e.Vals) e.ToUn2 = 'T';
    e.other = 'F';
}

/*
    Проверка, нет ли уже введенного параметра, обе подстановки в который совпадают с имеющимися в [CurrentNewMGUSub].
   ([MGUSub]^*)([Expr])([ToUnify]^*)[MGUSub]^* [CurrentNewMGUSub] => ([Expr])([ToUnify]^*)([MGUSub]^*) 
*/

CheckRepeatedMGUs {
/* 1. Все подстановки проверены. */
    (e.Checked)(e.Pattern)(e.ToUnify)((assign (e.pardata) t.Val1 t.Val2)) 
        = (e.Pattern)(e.ToUnify)(e.Checked (assign (e.pardata) t.Val1 t.Val2));
/* 2. Нашлась подстановка с такими же значениями --- значит, наша подстановка есть просто подстановка одного е-параметра. */
    (e.Checked)(e.Pattern)(e.ToUnify)((assign (e.pardata1) t.Val1 t.Val2) e.Other (assign (e.pardata) t.Val3 t.Val4))
    , <LogAnd <ComplexCompareCalls  t.Val1 t.Val3><ComplexCompareCalls  t.Val2 t.Val4>> : 'T'
        = (<Substitute ((assign (e.pardata)((e.pardata1))))e.Pattern>)
        (e.ToUnify)
        (e.Checked (assign (e.pardata1) t.Val1 t.Val2) e.Other);
/* 3. Пока не нашлась --- ищем дальше. */
    (e.Checked)(e.Pattern)(e.ToUnify)((assign (e.pardata1) t.Val11 t.Val22) e.Other (assign (e.pardata) t.Val1 t.Val2))
        = <CheckRepeatedMGUs (e.Checked (assign (e.pardata1) t.Val11 t.Val22))(e.Pattern)(e.ToUnify)(e.Other (assign (e.pardata) t.Val1 t.Val2))>;
}


/*
    Поиск подстановки данного параметра.
   (par e.pardata)[MGUSub]^* => [MGUSub] 
*/

FindMGU {
/* 1. Нашли --- возвращаем. */
    t.Parameter e.First (assign t.Parameter e.Data)e.Other = (assign t.Parameter e.Data);
/* 2. Не нашли --- возвращаем тривиальную подстановку. */
    t.Parameter e.Subs = (assign t.Parameter (t.Parameter)(t.Parameter));
}

/*
    Удаление подстановки параметра.
   (par e.pardata)[MGUSub]^* => [MGUSub]^*
*/
DeleteMGU {
    t.parameter e.First (assign t.parameter e.Data) e.Other = e.First e.Other;
    t.parameter e.Other = e.Other;
}

/*
    Слияние двух е-параметров в один.
   [MGUSub][MGUSub]([Expr])([ToUnify]^*)([MGUSub]^*) => ([Expr])([ToUnify]^*)([MGUSub]^*)
*/
ConcatenateMGUs {
    (0)(assign (t.sort e t.Name1)(e.Expr11)(e.Expr12))(assign (t.sort e t.Name2)(e.Expr21)(e.Expr22))(e.Pattern)(e.Other)(e.MGUs)
        = (<Substitute ((assign (t.sort e t.Name2)())) e.Pattern>)(e.Other)
        (e.MGUs (assign (t.sort e t.Name1)(e.Expr11 e.Expr21)(e.Expr12 e.Expr22)));
    (1)(assign (t.sort e t.Name1)(e.Expr11)(e.Expr12))(assign (t.sort e t.Name2)(e.Expr21)(e.Expr22))(e.Pattern)(e.Other)(e.MGUs)
        = (<Substitute ((assign (t.sort e t.Name1)())) e.Pattern>)(e.Other)
        (e.MGUs (assign (t.sort e t.Name2)(e.Expr11 e.Expr21)(e.Expr12 e.Expr22)));
}

FirstEVar {
    (t.sort e e.par) e.other = (t.sort e e.par);
    e.other = 'F';
}

/*
    Для данного е-параметра ищем предшествующие ему термы в выражении.
   Если они все --- один и тот же е-параметр, это отмечается в выходе.
   (par e t.Name)e.Expr => [(False)|(par e t.Name1)]^*
*/
FindAllPredInPattern {
/* 1. Всё смотрено. */
    (e.Pred)(e.Post)(t.sort e t.Name) = (e.Pred)(e.Post); 
/*
   2. В образце хотя бы перед одним вхождением этой переменной стоит символ, выражение в скобках, параметр узкого типа или вызов -> 
   присоединять не к чему (5 случаев). 
*/
    (e.Pred)(e.Post)(t.sort e t.Name)t.pred (t.sort e t.Name) e.Expr
    , <FirstEVar t.pred> : 'F'
    , <FirstEVar e.Expr> : 'F'
        = (False)(False); 
    (e.Pred)(e.Post)(t.sort e t.Name)t.pred (t.sort e t.Name) e.Expr
    , <FirstEVar t.pred> : 'F'
    , <FirstEVar e.Expr> : (t.sort e t.Name2) 
        = <FindAllPredInPattern (e.Pred)(e.Post (t.sort e t.Name2))(t.sort e t.Name) e.Expr>; 
/* 3. перед вхождением этого параметра стоит другой е-параметр --- возвращаем его и продолжаем искать дальше. */
    (e.Pred)(e.Post)(t.sort e t.Name)(t.sort e t.Name2) (t.sort e t.Name) e.Expr
    , <FirstEVar e.Expr> : (t.sort e t.Name3)  
        = <FindAllPredInPattern (e.Pred (t.sort e t.Name2))(e.Post (t.sort e t.Name3))(t.sort e t.Name) e.Expr>;
/* 3. перед вхождением этого параметра стоит другой е-параметр --- возвращаем его и продолжаем искать дальше. */
    (e.Pred)(e.Post)(t.sort e t.Name)(t.sort e t.Name2) (t.sort e t.Name) e.Expr 
        = <FindAllPredInPattern (e.Pred (t.sort e t.Name2))(e.Post)(t.sort e t.Name) e.Expr>;
/* 4. За ближайшим термом не стоит проверяемый параметр --- продолжаем поиск. */    
    (e.Pred)(e.Post)(t.sort e t.Name)s.Sym e.Expr
        = <FindAllPredInPattern (e.Pred)(e.Post)(t.sort e t.Name)e.Expr>; 
    (e.Pred)(e.Post)(t.sort e t.Name)('*'e.Expr1) e.Expr
    , <FindAllPredInPattern ()()(t.sort e t.Name)e.Expr1> : (e.Pred1)(e.Post1) 
        = 
        <FindAllPredInPattern (e.Pred e.Pred1)(e.Post e.Post1)(t.sort e t.Name)e.Expr>; 
    (e.Pred)(e.Post)(t.sort e t.Name)(call t.fname (args (arg e.Expr1))) e.Expr
    , <FindAllPredInPattern ()()(t.sort e t.Name)e.Expr1> : (e.Pred1)(e.Post1) 
        = 
        <FindAllPredInPattern (e.Pred e.Pred1)(e.Post e.Post1)(t.sort e t.Name)e.Expr>; 
    (e.Pred)(e.Post)(t.sort e t.Name)(t.sort e.pardata) e.Expr
        = <FindAllPredInPattern (e.Pred)(e.Post)(t.sort e t.Name)e.Expr>; 
}

/*
    Выбор обобщения с наибольшим весом. Вес считается как вес (точность) подстановок минус вес (неточность) образца.
   (([Expr])([MGUSub]^*))(([Expr])([MGUSub]^*)) => (([Expr])([MGUSub]^*))
*/
MinMGU {
    e.MaybeMGU1 ((False)(False)) e.MaybeMGU2, e.MaybeMGU1 e.MaybeMGU2 : ((e.Pattern)(e.Assignments))
    , <WeightNewMGU (0)e.Assignments> :
        {/* Nil = (False)(False); */
        e.Other = (e.Pattern)(e.Assignments);
        };
    ((e.Pattern1)(e.Assignments1))((e.Pattern2)(e.Assignments2))
    , <WeightNewMGU (1000)e.Assignments1> : s.W1
    , <WeightNewMGU (1000)e.Assignments2> : s.W2
    , s.W1 s.W2 :
        { /* Nil Nil = (False)(False);*/
        Nil s.W2 = (e.Pattern2)(e.Assignments2);
        s.W1 Nil = (e.Pattern1)(e.Assignments1);
        e.Z
            = <ChooseLeastMGU 
                ((e.Pattern1)(e.Assignments1))
                ((e.Pattern2)(e.Assignments2))
                <Compare 
                    <Sub s.W1 <WeightPattern (500)(e.Assignments1)e.Pattern1>>
                    <Sub s.W2 <WeightPattern (500)(e.Assignments2)e.Pattern2>>
                >
            >;
        };
}

/*
    Функция назначения весов для полученного обобщения - в доработке!
   ([Number])[Expr] => [Number]
*/
WeightPattern {
/* 1. Все посчитано. */
    (s.Weight)(e.Asgs) = s.Weight;
/* 4. Скобки в шаблоне. */
    (s.Weight)(e.Asgs) e.Pt1 ('*' e.InBracks) e.Pattern
        = <WeightPattern (<Add s.Weight 25>)(e.Asgs) e.Pt1 e.InBracks e.Pattern>; /* Было 80 */
/* 5. Вызов функции в шаблоне. */
    (s.Weight)(e.Asgs)e.Pt1 (call t.fname (args (arg e.arg))) e.Pattern
        = <WeightPattern (<Add s.Weight 30>)(e.Asgs) e.Pt1 e.arg e.Pattern>; /* Было 120 */
/* 2. Символ в шаблоне. */
    (s.Weight)(e.Asgs)s.Sym e.Pattern = <WeightPattern (<Add s.Weight 25>)(e.Asgs) e.Pattern>; /* Было 250  */
/* 3. Параметр в шаблоне. */
    (s.Weight)(e.Asgs)(t.sort t.type t.name) e.Pat1 (t.sort t.type t.name) e.Pattern
    , weval var par : e.1 t.sort e.2
    , t.type :
            {s = <WeightPattern (<Add s.Weight 20>)(e.Asgs) e.Pat1 (t.sort t.type t.name) e.Pattern>; /* Было 170  */
             t = <WeightPattern (<Add s.Weight 15>)(e.Asgs) e.Pat1 (t.sort t.type t.name) e.Pattern>; /* Было 130  */
             e = <WeightPattern (<Add s.Weight 10>)(e.Asgs) e.Pat1 (t.sort t.type t.name) e.Pattern>; /* Было 50  */
            };
    (s.Weight)(e.Asgs)(t.sort t.type t.name) e.Pattern
    , weval var par : e.1 t.sort e.2
    , t.type :
            {s = <WeightPattern (<Add s.Weight 10>)(e.Asgs) e.Pattern>; /* Было 120  */
             t = <WeightPattern (<Add s.Weight 5>)(e.Asgs) e.Pattern>; /* Было 80  */
             e = <WeightPattern (s.Weight)(e.Asgs) e.Pattern>; /* Было 0  */
            };
/*
    , e.Asgs :
        {e.x1 (assign (par t.type t.parname)e.Val) e.x2
        , t.type :
            {s = <WeightPattern (<Add s.Weight 120>)(e.Asgs) e.Pattern>;
             t = <WeightPattern (<Add s.Weight 80>)(e.Asgs) e.Pattern>;
             e = <WeightPattern (s.Weight)(e.Asgs) e.Pattern>;
            };
        e.Other = <WeightPattern (<Add s.Weight 200>)(e.Asgs) e.Pattern>;
        };
*/
}

ShortTerms {
    e.1 (t.sort e e.data) e.2 = 'F';
    s.1 t.1 e.1 = <ShortTerms <Add s.1 1> e.1>;
    s.1
    , <MyMax s.1 <Add <CurrentIndex 'MaxConst'> 1>> : 
        { s.1 = 'T';
        s.Other = 'F';
        };
}

/* Вспомогательная для MinMGU. */
ChooseLeastMGU {
    ((e.Pattern1)(e.Assignments1))((e.Pattern2)(e.Assignments2))'+' = (e.Pattern2)(e.Assignments2);
    ((e.Pattern1)(e.Assignments1))((e.Pattern2)(e.Assignments2))s.0 = (e.Pattern1)(e.Assignments1);
}

WeightNewMGU {
    (e.Weight)False = Nil;
    (e.Weight)(assign (e.Var)(e.Val1)(e.Val2))e.Others 
        = <WeightNewMGU (<Add e.Weight 10>)(assign (e.Val1))(assign (e.Val2))e.Others >;
    (e.Weight)(assign (t.Val1 t.1 e.ValOther)) e.Others
        = <WeightNewMGU (<Add e.Weight 10>)(assign (t.Val1))(assign (t.1 e.ValOther))e.Others>;
    (e.Weight)(assign ( )) e.Others
        = <WeightNewMGU (e.Weight) e.Others>;
    (e.Weight)(assign (s.X)) e.Others
        = <WeightNewMGU (e.Weight) e.Others>;
    (e.Weight)(assign ((par s t.Name))) e.Others
        = <WeightNewMGU (e.Weight) e.Others>;
    (e.Weight)(assign ((par t t.Name))) e.Others
        = <WeightNewMGU (e.Weight) e.Others>;
    (e.Weight)(assign ((par e t.Name))) e.Others
        = <WeightNewMGU (e.Weight) e.Others>;
    (e.Weight)(assign (('*' e.InBr))) e.Others
        = <WeightNewMGU (e.Weight)(assign (e.InBr)) e.Others>;
    (e.Weight)(assign ((call t.call (args (arg e.Arg))))) e.Others
        = <WeightNewMGU (e.Weight)(assign (e.Arg)) e.Others>;
    (e.Weight) /* EMPTY */
        = e.Weight;
    
}

/*
    Функция назначения веса сопоставлений --- в доработке!
   ([Number])[MGUSub]^* => [Number]
*/
WeightMGU {
/* 0. Подстановки "символ - пустое множество" весят мало. */
    (e.Weight)False = Nil;
 /*   (e.Weight)e.Oth1 (assign (e.Var)(e.Terms1)(e.Terms2))e.Others
    , <LogAnd <ShortTerms 0 e.Terms1><ShortTerms 0 e.Terms2>> : 'T'
        = Nil;*/
    (e.Weight)e.Oth1 (assign (e.Var)()(s.Sym))e.Others
        = <WeightMGU (<Add e.Weight 10>)e.Oth1 e.Others>;
/*    (e.Weight)e.Oth1 (assign (e.Var)(s.Sym)())e.Others
        = <WeightMGU (<Add e.Weight 10>)e.Oth1 e.Others>;*/
/* 1. Расщепление каждой подстановки на две подстановки. */
    (e.Weight)(assign (e.Var)(e.Val1)(e.Val2))e.Others 
        = <WeightMGU (<Add e.Weight 10>)(assign (e.Var)(e.Val1))(assign (e.Var)(e.Val2))e.Others >;
/* 2. Прошлись по всем, посчитали. */
    (e.Weight) = e.Weight;
/* 3. Назначение параметру параметра того же типа --- хорошо. Это значит, были повторные подстановки. */
    (e.Weight)(assign (t.sort s.type t.parname)((t.sort s.type t.parname2)))e.Assignments 
        = <WeightMGU (<Sub e.Weight 10>) e.Assignments>;
/* 4. Назначение параметру выражения, с двух сторон окруженного е-параметрами. */
    (e.Weight)(assign (t.sort e t.parname)((t.sort e t.parname2)e.Expr(t.sort e t.parname3)))e.Assignments 
        = <WeightMGU (<Add e.Weight 10>) e.Assignments>;
/* 5. Назначение параметру выражения, содержащего символ и е-параметр с краю (2 случая). */
    (e.Weight)(assign (t.sort e t.parname)((t.sort e t.parname2)e.Expr s.Sym))e.Assignments 
        = <WeightMGU (<Add e.Weight 20>) e.Assignments>;
    (e.Weight)(assign (t.sort e t.parname)(s.Sym e.Expr (t.sort e t.parname2)))e.Assignments 
        = <WeightMGU (<Add e.Weight 20>) e.Assignments>;
/* 6. Назначение параметру выражения, содержащего вызов. */
    (e.Weight)(assign (t.sort e t.parname)((call e.call)))e.Assignments 
        = <WeightMGU (<Add e.Weight 5>) e.Assignments>;
/* 7. Назначение параметру выражения, содержащего s-параметр и е-параметр с краю (2 случая). */
    (e.Weight)(assign (t.sort e t.parname)((t.sort e t.parname2)e.Expr(t.sort s t.sparname)))e.Assignments 
        = <WeightMGU (<Add e.Weight 15>) e.Assignments>;
    (e.Weight)(assign (t.sort e t.parname)((t.sort s t.sparname)e.Expr(t.sort e t.parname2)))e.Assignments 
        = <WeightMGU (<Add e.Weight 15>) e.Assignments>;
/* 8. Назначение параметру выражения, содержащего t-параметр либо скобки и е-параметр с краю (2 случая). */
    (e.Weight)(assign (t.sort e t.parname)((t.sort e t.parname2)e.Expr t.Term))e.Assignments 
        = <WeightMGU (<Add e.Weight 10>) e.Assignments>;
    (e.Weight)(assign (t.sort e t.parname)(t.Term e.Expr(t.sort e t.parname2)))e.Assignments 
        = <WeightMGU (<Add e.Weight 10>) e.Assignments>;
/* 9. Назначение параметру пустого выражения или символа (2 случая). */
    (e.Weight)(assign (t.sort e t.parname)())e.Assignments 
        = <WeightMGU (<Add e.Weight 60>) e.Assignments>;    
    (e.Weight)(assign (t.sort e t.parname)(s.Sym))e.Assignments 
        = <WeightMGU (<Add e.Weight 60>) e.Assignments>;    
/* 10. Назначение параметру параметра более узкого типа или выражения в скобках - 3 случая. */
    (e.Weight)(assign (t.sort e t.parname)((t.sort s t.sparname)))e.Assignments 
        = <WeightMGU (<Add e.Weight 30>) e.Assignments>;    
    (e.Weight)(assign (t.sort e t.parname)(t.Term))e.Assignments 
        = <WeightMGU (<Add e.Weight 20>) e.Assignments>;    
    (e.Weight)(assign (t.sort t t.parname)((t.sort s t.sparname)))e.Assignments 
        = <WeightMGU (<Add e.Weight 5>) e.Assignments>;   
/* 11. Назначение t-параметру выражения в скобках либо символа. */
    (e.Weight)(assign (t.sort t t.parname)(t.BracksOrSym))e.Assignments 
        = <WeightMGU (<Add e.Weight 10>) e.Assignments>;
/* 12. Назначение s-параметру символа. */	
    (e.Weight)(assign (t.sort s t.parname)(s.Sym))e.Assignments 
        = <WeightMGU (<Add e.Weight 5>) e.Assignments>;    
/* 13. Назначение e-параметру выражения, содержащего хотя бы один вызов внутри. */	
    (e.Weight)(assign (t.sort e t.parname)(e.Expr1 (call e.call) e.Expr2))e.Assignments 
        = <WeightMGU (<Add e.Weight 10>) e.Assignments>;
/* 14. Назначение e-параметру выражения, содержащего термы с двух сторон и е-параметр внутри. */	
    (e.Weight)(assign (t.sort e t.parname)(e.Expr1 (t.sort e t.parname) e.Expr2))e.Assignments 
        = <WeightMGU (<Add e.Weight 20>) e.Assignments>;
/* 15. Назначение e-параметру выражения, содержащего лишь объектные выражения либо вызовы. */	
    (e.Weight)(assign (t.sort e t.parname)(e.Expr))e.Assignments 
        = <WeightMGU (<Add e.Weight 30>) e.Assignments>;
}/* WeightMGU */