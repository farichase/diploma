$ENTRY Go {
    , <Arg 1> : e.input0 /* После запятой --- условие, но здесь оно тривиально истинно, поскольку e.input0 --- e-переменная в общем положении, и нужно, чтобы считать имя входного файла из потока в переменную e.input0 */
    , <Arg 2> : e.output0 /* Та же история с выходным файлом */
     = <Open r 1 e.input0> /* Открываем на чтение файл с именем e.input0, присваиваем этому IO-потоку идентификатор 1 */
       <Open w 2 e.output0> /* Открываем на запись файл с именем e.output0, присваиваем этому IO-потоку идентификатор 2 */
        <CopyFile 1 2> /* Тупо копируем из первого потока во второй */
        <Close 1><Close 2> /* Закрываем все IO-потоки. */;
}

CopyFile {
   s.Input s.OutPut, <Get s.Input> : e.x 0 = <Put s.OutPut e.x><Put s.OutPut '/* Это результат тестовой суперкомпиляции. */'>; /* Встретился EOF-маркер, завершаем работу. */
   s.Input s.OutPut, <Get s.Input> : e.x = <Put s.OutPut e.x><CopyFile s.Input s.OutPut>; /* EOF-маркера нет, вызываем следующую итерацию копирования. */
}

